   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB15:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  55:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  58:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  59:tmk_core/common/action.c **** #endif
  60:tmk_core/common/action.c **** /** \brief Called to execute an action.
  61:tmk_core/common/action.c ****  *
  62:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  63:tmk_core/common/action.c ****  */
  64:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 64 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  65:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 65 5 view .LVU1
  66:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:tmk_core/common/action.c ****         dprint("EVENT: ");
  68:tmk_core/common/action.c ****         debug_event(event);
  69:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 69 19 view .LVU2
  70:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  71:tmk_core/common/action.c ****         retro_tapping_counter++;
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c **** 
  75:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  76:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  77:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  78:tmk_core/common/action.c ****     }
  79:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  80:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c ****     fauxclicky_check();
  83:tmk_core/common/action.c **** #endif
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  86:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  87:tmk_core/common/action.c ****         process_hand_swap(&event);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 91 5 view .LVU3
  51               		.loc 1 91 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  94:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  95:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  96:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  99:tmk_core/common/action.c ****         clear_oneshot_mods();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 102:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 103:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 104:tmk_core/common/action.c ****     }
 105:tmk_core/common/action.c **** #        endif
 106:tmk_core/common/action.c **** #    endif
 107:tmk_core/common/action.c **** #endif
 108:tmk_core/common/action.c **** 
 109:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 110:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 110 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 110 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 110 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 111:tmk_core/common/action.c **** #else
 112:tmk_core/common/action.c ****     process_record(&record);
 113:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 114:tmk_core/common/action.c ****         dprint("processed: ");
 115:tmk_core/common/action.c ****         debug_record(record);
 116:tmk_core/common/action.c ****         dprintln();
 117:tmk_core/common/action.c ****     }
 118:tmk_core/common/action.c **** #endif
 119:tmk_core/common/action.c **** }
  76               		.loc 1 119 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
 110:tmk_core/common/action.c **** #else
  85               		.loc 1 110 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE15:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB17:
 120:tmk_core/common/action.c **** 
 121:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 122:tmk_core/common/action.c **** bool swap_hands = false;
 123:tmk_core/common/action.c **** bool swap_held  = false;
 124:tmk_core/common/action.c **** 
 125:tmk_core/common/action.c **** /** \brief Process Hand Swap
 126:tmk_core/common/action.c ****  *
 127:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 128:tmk_core/common/action.c ****  */
 129:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 130:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 131:tmk_core/common/action.c **** 
 132:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 133:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 134:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 135:tmk_core/common/action.c **** 
 136:tmk_core/common/action.c ****     if (do_swap) {
 137:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 138:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 139:tmk_core/common/action.c ****     } else {
 140:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:tmk_core/common/action.c ****     }
 142:tmk_core/common/action.c **** }
 143:tmk_core/common/action.c **** #endif
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:tmk_core/common/action.c **** bool disable_action_cache = false;
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:tmk_core/common/action.c ****     disable_action_cache = true;
 150:tmk_core/common/action.c ****     process_record(record);
 151:tmk_core/common/action.c ****     disable_action_cache = false;
 152:tmk_core/common/action.c **** }
 153:tmk_core/common/action.c **** #else
 154:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:tmk_core/common/action.c **** #endif
 156:tmk_core/common/action.c **** 
 157:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 157 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 157 74 view .LVU11
 104               		.loc 1 157 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 157 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE17:
 113               		.section	.text.post_process_record_quantum,"ax",@progbits
 114               		.weak	post_process_record_quantum
 116               	post_process_record_quantum:
 117               	.LVL6:
 118               	.LFB18:
 158:tmk_core/common/action.c **** 
 159:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 119               		.loc 1 159 77 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 125               		.loc 1 159 78 view .LVU15
 126               	/* epilogue start */
 127               		.loc 1 159 1 is_stmt 0 view .LVU16
 128 0000 0895      		ret
 129               		.cfi_endproc
 130               	.LFE18:
 132               		.section	.text.process_record_tap_hint,"ax",@progbits
 133               	.global	process_record_tap_hint
 135               	process_record_tap_hint:
 136               	.LVL7:
 137               	.LFB19:
 160:tmk_core/common/action.c **** 
 161:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 162:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:tmk_core/common/action.c ****  *
 164:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 165:tmk_core/common/action.c ****  */
 166:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 138               		.loc 1 166 51 is_stmt 1 view -0
 139               		.cfi_startproc
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 167:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 144               		.loc 1 167 5 view .LVU18
 145               		.loc 1 167 23 is_stmt 0 view .LVU19
 146 0000 FC01      		movw r30,r24
 147 0002 8081      		ld r24,Z
 148 0004 9181      		ldd r25,Z+1
 149               	.LVL8:
 150               		.loc 1 167 23 view .LVU20
 151 0006 0C94 0000 		jmp layer_switch_get_action
 152               	.LVL9:
 153               		.loc 1 167 23 view .LVU21
 154               		.cfi_endproc
 155               	.LFE19:
 157               		.section	.text.register_code,"ax",@progbits
 158               	.global	register_code
 160               	register_code:
 161               	.LVL10:
 162               	.LFB23:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c ****     switch (action.kind.id) {
 170:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 172:tmk_core/common/action.c ****             switch (action.swap.code) {
 173:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 174:tmk_core/common/action.c ****                     break;
 175:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:tmk_core/common/action.c ****                 default:
 177:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 178:tmk_core/common/action.c ****                     swap_held  = true;
 179:tmk_core/common/action.c ****             }
 180:tmk_core/common/action.c ****             break;
 181:tmk_core/common/action.c **** #    endif
 182:tmk_core/common/action.c ****     }
 183:tmk_core/common/action.c **** }
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:tmk_core/common/action.c ****  *
 188:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 189:tmk_core/common/action.c ****  */
 190:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 191:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 192:tmk_core/common/action.c ****         return;
 193:tmk_core/common/action.c ****     }
 194:tmk_core/common/action.c **** 
 195:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 196:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 197:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:tmk_core/common/action.c ****         }
 200:tmk_core/common/action.c **** #endif
 201:tmk_core/common/action.c ****         return;
 202:tmk_core/common/action.c ****     }
 203:tmk_core/common/action.c **** 
 204:tmk_core/common/action.c ****     process_record_handler(record);
 205:tmk_core/common/action.c ****     post_process_record_quantum(record);
 206:tmk_core/common/action.c **** }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 209:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 210:tmk_core/common/action.c ****     dprint("ACTION: ");
 211:tmk_core/common/action.c ****     debug_action(action);
 212:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 213:tmk_core/common/action.c ****     dprint(" layer_state: ");
 214:tmk_core/common/action.c ****     layer_debug();
 215:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 216:tmk_core/common/action.c ****     default_layer_debug();
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c ****     dprintln();
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     process_action(record, action);
 221:tmk_core/common/action.c **** }
 222:tmk_core/common/action.c **** 
 223:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 224:tmk_core/common/action.c ****  *
 225:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 226:tmk_core/common/action.c ****  */
 227:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 228:tmk_core/common/action.c ****     keyevent_t event = record->event;
 229:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 230:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 231:tmk_core/common/action.c **** #endif
 232:tmk_core/common/action.c **** 
 233:tmk_core/common/action.c ****     if (event.pressed) {
 234:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 235:tmk_core/common/action.c ****         clear_weak_mods();
 236:tmk_core/common/action.c ****     }
 237:tmk_core/common/action.c **** 
 238:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 239:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 240:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 241:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 242:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 243:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 244:tmk_core/common/action.c **** #    endif
 245:tmk_core/common/action.c ****     ) {
 246:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 247:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 248:tmk_core/common/action.c ****     }
 249:tmk_core/common/action.c **** #endif
 250:tmk_core/common/action.c **** 
 251:tmk_core/common/action.c ****     switch (action.kind.id) {
 252:tmk_core/common/action.c ****         /* Key and Mods */
 253:tmk_core/common/action.c ****         case ACT_LMODS:
 254:tmk_core/common/action.c ****         case ACT_RMODS: {
 255:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 256:tmk_core/common/action.c ****             if (event.pressed) {
 257:tmk_core/common/action.c ****                 if (mods) {
 258:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 259:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 260:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 261:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 262:tmk_core/common/action.c ****                         add_mods(mods);
 263:tmk_core/common/action.c ****                     } else {
 264:tmk_core/common/action.c ****                         add_weak_mods(mods);
 265:tmk_core/common/action.c ****                     }
 266:tmk_core/common/action.c ****                     send_keyboard_report();
 267:tmk_core/common/action.c ****                 }
 268:tmk_core/common/action.c ****                 register_code(action.key.code);
 269:tmk_core/common/action.c ****             } else {
 270:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 271:tmk_core/common/action.c ****                 if (mods) {
 272:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 273:tmk_core/common/action.c ****                         del_mods(mods);
 274:tmk_core/common/action.c ****                     } else {
 275:tmk_core/common/action.c ****                         del_weak_mods(mods);
 276:tmk_core/common/action.c ****                     }
 277:tmk_core/common/action.c ****                     send_keyboard_report();
 278:tmk_core/common/action.c ****                 }
 279:tmk_core/common/action.c ****             }
 280:tmk_core/common/action.c ****         } break;
 281:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 282:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 283:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 284:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 285:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 286:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 287:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 288:tmk_core/common/action.c ****                     // Oneshot modifier
 289:tmk_core/common/action.c ****                     if (event.pressed) {
 290:tmk_core/common/action.c ****                         if (tap_count == 0) {
 291:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 292:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 293:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 294:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 295:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 296:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 297:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 299:tmk_core/common/action.c ****                             clear_oneshot_mods();
 300:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 301:tmk_core/common/action.c ****                             register_mods(mods);
 302:tmk_core/common/action.c **** #        endif
 303:tmk_core/common/action.c ****                         } else {
 304:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 305:tmk_core/common/action.c ****                         }
 306:tmk_core/common/action.c ****                     } else {
 307:tmk_core/common/action.c ****                         if (tap_count == 0) {
 308:tmk_core/common/action.c ****                             clear_oneshot_mods();
 309:tmk_core/common/action.c ****                             unregister_mods(mods);
 310:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 311:tmk_core/common/action.c ****                             // Retain Oneshot mods
 312:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 313:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 314:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 315:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 316:tmk_core/common/action.c ****                                 unregister_mods(mods);
 317:tmk_core/common/action.c ****                             }
 318:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 319:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 320:tmk_core/common/action.c **** #        endif
 321:tmk_core/common/action.c ****                         } else {
 322:tmk_core/common/action.c ****                             clear_oneshot_mods();
 323:tmk_core/common/action.c ****                             unregister_mods(mods);
 324:tmk_core/common/action.c ****                         }
 325:tmk_core/common/action.c ****                     }
 326:tmk_core/common/action.c ****                     break;
 327:tmk_core/common/action.c **** #    endif
 328:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 329:tmk_core/common/action.c ****                     if (event.pressed) {
 330:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 331:tmk_core/common/action.c ****                             register_mods(mods);
 332:tmk_core/common/action.c ****                         }
 333:tmk_core/common/action.c ****                     } else {
 334:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 335:tmk_core/common/action.c ****                             unregister_mods(mods);
 336:tmk_core/common/action.c ****                         }
 337:tmk_core/common/action.c ****                     }
 338:tmk_core/common/action.c ****                     break;
 339:tmk_core/common/action.c ****                 default:
 340:tmk_core/common/action.c ****                     if (event.pressed) {
 341:tmk_core/common/action.c ****                         if (tap_count > 0) {
 342:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 343:tmk_core/common/action.c ****                             if (
 344:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 345:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 346:tmk_core/common/action.c **** #        endif
 347:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 348:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 349:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 350:tmk_core/common/action.c ****                                 record->tap.count = 0;
 351:tmk_core/common/action.c ****                                 register_mods(mods);
 352:tmk_core/common/action.c ****                             } else
 353:tmk_core/common/action.c **** #    endif
 354:tmk_core/common/action.c ****                             {
 355:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 356:tmk_core/common/action.c ****                                 register_code(action.key.code);
 357:tmk_core/common/action.c ****                             }
 358:tmk_core/common/action.c ****                         } else {
 359:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 360:tmk_core/common/action.c ****                             register_mods(mods);
 361:tmk_core/common/action.c ****                         }
 362:tmk_core/common/action.c ****                     } else {
 363:tmk_core/common/action.c ****                         if (tap_count > 0) {
 364:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 365:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 366:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 367:tmk_core/common/action.c ****                             } else {
 368:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 369:tmk_core/common/action.c ****                             }
 370:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 371:tmk_core/common/action.c ****                         } else {
 372:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 373:tmk_core/common/action.c ****                             unregister_mods(mods);
 374:tmk_core/common/action.c ****                         }
 375:tmk_core/common/action.c ****                     }
 376:tmk_core/common/action.c ****                     break;
 377:tmk_core/common/action.c ****             }
 378:tmk_core/common/action.c ****         } break;
 379:tmk_core/common/action.c **** #endif
 380:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 381:tmk_core/common/action.c ****         /* other HID usage */
 382:tmk_core/common/action.c ****         case ACT_USAGE:
 383:tmk_core/common/action.c ****             switch (action.usage.page) {
 384:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 385:tmk_core/common/action.c ****                     if (event.pressed) {
 386:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 387:tmk_core/common/action.c ****                     } else {
 388:tmk_core/common/action.c ****                         host_system_send(0);
 389:tmk_core/common/action.c ****                     }
 390:tmk_core/common/action.c ****                     break;
 391:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 392:tmk_core/common/action.c ****                     if (event.pressed) {
 393:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 394:tmk_core/common/action.c ****                     } else {
 395:tmk_core/common/action.c ****                         host_consumer_send(0);
 396:tmk_core/common/action.c ****                     }
 397:tmk_core/common/action.c ****                     break;
 398:tmk_core/common/action.c ****             }
 399:tmk_core/common/action.c ****             break;
 400:tmk_core/common/action.c **** #endif
 401:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 402:tmk_core/common/action.c ****         /* Mouse key */
 403:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 404:tmk_core/common/action.c ****             if (event.pressed) {
 405:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 406:tmk_core/common/action.c ****                 switch (action.key.code) {
 407:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 408:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 409:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 410:tmk_core/common/action.c ****                         break;
 411:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 412:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 413:tmk_core/common/action.c ****                         break;
 414:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 415:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 416:tmk_core/common/action.c ****                         break;
 417:tmk_core/common/action.c **** #    endif
 418:tmk_core/common/action.c ****                     default:
 419:tmk_core/common/action.c ****                         mousekey_send();
 420:tmk_core/common/action.c ****                         break;
 421:tmk_core/common/action.c ****                 }
 422:tmk_core/common/action.c ****             } else {
 423:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 424:tmk_core/common/action.c ****                 switch (action.key.code) {
 425:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 426:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 427:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 428:tmk_core/common/action.c ****                         break;
 429:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 430:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 431:tmk_core/common/action.c ****                         break;
 432:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 433:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 434:tmk_core/common/action.c ****                         break;
 435:tmk_core/common/action.c **** #    endif
 436:tmk_core/common/action.c ****                     default:
 437:tmk_core/common/action.c ****                         mousekey_send();
 438:tmk_core/common/action.c ****                         break;
 439:tmk_core/common/action.c ****                 }
 440:tmk_core/common/action.c ****             }
 441:tmk_core/common/action.c ****             break;
 442:tmk_core/common/action.c **** #endif
 443:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 444:tmk_core/common/action.c ****         case ACT_LAYER:
 445:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 446:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 447:tmk_core/common/action.c ****                 if (!event.pressed) {
 448:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 449:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 450:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 451:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 452:tmk_core/common/action.c ****                         case OP_BIT_AND:
 453:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 454:tmk_core/common/action.c ****                             break;
 455:tmk_core/common/action.c ****                         case OP_BIT_OR:
 456:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 457:tmk_core/common/action.c ****                             break;
 458:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 459:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 460:tmk_core/common/action.c ****                             break;
 461:tmk_core/common/action.c ****                         case OP_BIT_SET:
 462:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 463:tmk_core/common/action.c ****                             break;
 464:tmk_core/common/action.c ****                     }
 465:tmk_core/common/action.c ****                 }
 466:tmk_core/common/action.c ****             } else {
 467:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 468:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 469:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 470:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 471:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 472:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 473:tmk_core/common/action.c ****                         case OP_BIT_AND:
 474:tmk_core/common/action.c ****                             layer_and(bits | mask);
 475:tmk_core/common/action.c ****                             break;
 476:tmk_core/common/action.c ****                         case OP_BIT_OR:
 477:tmk_core/common/action.c ****                             layer_or(bits | mask);
 478:tmk_core/common/action.c ****                             break;
 479:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 480:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 481:tmk_core/common/action.c ****                             break;
 482:tmk_core/common/action.c ****                         case OP_BIT_SET:
 483:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 484:tmk_core/common/action.c ****                             break;
 485:tmk_core/common/action.c ****                     }
 486:tmk_core/common/action.c ****                 }
 487:tmk_core/common/action.c ****             }
 488:tmk_core/common/action.c ****             break;
 489:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 490:tmk_core/common/action.c ****             if (event.pressed) {
 491:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 492:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 493:tmk_core/common/action.c ****             } else {
 494:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 495:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 496:tmk_core/common/action.c ****             }
 497:tmk_core/common/action.c ****             break;
 498:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 499:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 500:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 501:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 502:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 503:tmk_core/common/action.c ****                     /* tap toggle */
 504:tmk_core/common/action.c ****                     if (event.pressed) {
 505:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 506:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 507:tmk_core/common/action.c ****                         }
 508:tmk_core/common/action.c ****                     } else {
 509:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 510:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 511:tmk_core/common/action.c ****                         }
 512:tmk_core/common/action.c ****                     }
 513:tmk_core/common/action.c ****                     break;
 514:tmk_core/common/action.c ****                 case OP_ON_OFF:
 515:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 516:tmk_core/common/action.c ****                     break;
 517:tmk_core/common/action.c ****                 case OP_OFF_ON:
 518:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 519:tmk_core/common/action.c ****                     break;
 520:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 521:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 522:tmk_core/common/action.c ****                     break;
 523:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 524:tmk_core/common/action.c ****                 case OP_ONESHOT:
 525:tmk_core/common/action.c ****                     // Oneshot modifier
 526:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 527:tmk_core/common/action.c ****                     do_release_oneshot = false;
 528:tmk_core/common/action.c ****                     if (event.pressed) {
 529:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 530:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 531:tmk_core/common/action.c ****                             reset_oneshot_layer();
 532:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 533:tmk_core/common/action.c ****                             break;
 534:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 535:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 536:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 537:tmk_core/common/action.c ****                         }
 538:tmk_core/common/action.c ****                     } else {
 539:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 540:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 541:tmk_core/common/action.c ****                             reset_oneshot_layer();
 542:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 543:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 544:tmk_core/common/action.c ****                         } else {
 545:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     }
 548:tmk_core/common/action.c **** #            else
 549:tmk_core/common/action.c ****                     if (event.pressed) {
 550:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 551:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 552:tmk_core/common/action.c ****                     } else {
 553:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 554:tmk_core/common/action.c ****                         if (tap_count > 1) {
 555:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 556:tmk_core/common/action.c ****                         }
 557:tmk_core/common/action.c ****                     }
 558:tmk_core/common/action.c **** #            endif
 559:tmk_core/common/action.c ****                     break;
 560:tmk_core/common/action.c **** #        endif
 561:tmk_core/common/action.c ****                 default:
 562:tmk_core/common/action.c ****                     /* tap key */
 563:tmk_core/common/action.c ****                     if (event.pressed) {
 564:tmk_core/common/action.c ****                         if (tap_count > 0) {
 565:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 566:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 567:tmk_core/common/action.c ****                         } else {
 568:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 569:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 570:tmk_core/common/action.c ****                         }
 571:tmk_core/common/action.c ****                     } else {
 572:tmk_core/common/action.c ****                         if (tap_count > 0) {
 573:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 574:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 575:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 576:tmk_core/common/action.c ****                             } else {
 577:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 578:tmk_core/common/action.c ****                             }
 579:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 580:tmk_core/common/action.c ****                         } else {
 581:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 582:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 583:tmk_core/common/action.c ****                         }
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c ****                     break;
 586:tmk_core/common/action.c ****             }
 587:tmk_core/common/action.c ****             break;
 588:tmk_core/common/action.c **** #    endif
 589:tmk_core/common/action.c **** #endif
 590:tmk_core/common/action.c ****             /* Extentions */
 591:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 592:tmk_core/common/action.c ****         case ACT_MACRO:
 593:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 594:tmk_core/common/action.c ****             break;
 595:tmk_core/common/action.c **** #endif
 596:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 597:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 598:tmk_core/common/action.c ****             switch (action.swap.code) {
 599:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 602:tmk_core/common/action.c ****                     }
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 605:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 608:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 609:tmk_core/common/action.c ****                     break;
 610:tmk_core/common/action.c ****                 case OP_SH_ON:
 611:tmk_core/common/action.c ****                     if (!event.pressed) {
 612:tmk_core/common/action.c ****                         swap_hands = true;
 613:tmk_core/common/action.c ****                     }
 614:tmk_core/common/action.c ****                     break;
 615:tmk_core/common/action.c ****                 case OP_SH_OFF:
 616:tmk_core/common/action.c ****                     if (!event.pressed) {
 617:tmk_core/common/action.c ****                         swap_hands = false;
 618:tmk_core/common/action.c ****                     }
 619:tmk_core/common/action.c ****                     break;
 620:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 621:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 622:tmk_core/common/action.c ****                     if (event.pressed) {
 623:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 624:tmk_core/common/action.c ****                     } else {
 625:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 626:tmk_core/common/action.c ****                     }
 627:tmk_core/common/action.c ****                     break;
 628:tmk_core/common/action.c **** #    endif
 629:tmk_core/common/action.c **** 
 630:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 631:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 632:tmk_core/common/action.c ****                     /* tap toggle */
 633:tmk_core/common/action.c **** 
 634:tmk_core/common/action.c ****                     if (event.pressed) {
 635:tmk_core/common/action.c ****                         if (swap_held) {
 636:tmk_core/common/action.c ****                             swap_held = false;
 637:tmk_core/common/action.c ****                         } else {
 638:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 639:tmk_core/common/action.c ****                         }
 640:tmk_core/common/action.c ****                     } else {
 641:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 642:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 643:tmk_core/common/action.c ****                         }
 644:tmk_core/common/action.c ****                     }
 645:tmk_core/common/action.c ****                     break;
 646:tmk_core/common/action.c ****                 default:
 647:tmk_core/common/action.c ****                     /* tap key */
 648:tmk_core/common/action.c ****                     if (tap_count > 0) {
 649:tmk_core/common/action.c ****                         if (swap_held) {
 650:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 651:tmk_core/common/action.c ****                             swap_held  = false;
 652:tmk_core/common/action.c ****                         }
 653:tmk_core/common/action.c ****                         if (event.pressed) {
 654:tmk_core/common/action.c ****                             register_code(action.swap.code);
 655:tmk_core/common/action.c ****                         } else {
 656:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 657:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 658:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 659:tmk_core/common/action.c ****                         }
 660:tmk_core/common/action.c ****                     } else {
 661:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 662:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 663:tmk_core/common/action.c ****                             swap_held  = false;
 664:tmk_core/common/action.c ****                         }
 665:tmk_core/common/action.c ****                     }
 666:tmk_core/common/action.c **** #    endif
 667:tmk_core/common/action.c ****             }
 668:tmk_core/common/action.c **** #endif
 669:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 670:tmk_core/common/action.c ****         case ACT_FUNCTION:
 671:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 672:tmk_core/common/action.c ****             break;
 673:tmk_core/common/action.c **** #endif
 674:tmk_core/common/action.c ****         default:
 675:tmk_core/common/action.c ****             break;
 676:tmk_core/common/action.c ****     }
 677:tmk_core/common/action.c **** 
 678:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 679:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 680:tmk_core/common/action.c ****     switch (action.kind.id) {
 681:tmk_core/common/action.c ****         case ACT_LAYER:
 682:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 683:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 684:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 685:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 686:tmk_core/common/action.c **** #    endif
 687:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 688:tmk_core/common/action.c ****             break;
 689:tmk_core/common/action.c ****         default:
 690:tmk_core/common/action.c ****             break;
 691:tmk_core/common/action.c ****     }
 692:tmk_core/common/action.c **** #endif
 693:tmk_core/common/action.c **** 
 694:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 695:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 696:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 697:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 698:tmk_core/common/action.c ****     } else {
 699:tmk_core/common/action.c ****         if (event.pressed) {
 700:tmk_core/common/action.c ****             if (tap_count > 0) {
 701:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 702:tmk_core/common/action.c ****             } else {
 703:tmk_core/common/action.c ****             }
 704:tmk_core/common/action.c ****         } else {
 705:tmk_core/common/action.c ****             if (tap_count > 0) {
 706:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 707:tmk_core/common/action.c ****             } else {
 708:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 709:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 710:tmk_core/common/action.c ****                 }
 711:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 712:tmk_core/common/action.c ****             }
 713:tmk_core/common/action.c ****         }
 714:tmk_core/common/action.c ****     }
 715:tmk_core/common/action.c **** #    endif
 716:tmk_core/common/action.c **** #endif
 717:tmk_core/common/action.c **** 
 718:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 719:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 720:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 721:tmk_core/common/action.c ****         use_oneshot_swaphands();
 722:tmk_core/common/action.c ****     }
 723:tmk_core/common/action.c **** #    endif
 724:tmk_core/common/action.c **** #endif
 725:tmk_core/common/action.c **** 
 726:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 727:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 728:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 729:tmk_core/common/action.c ****      */
 730:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 731:tmk_core/common/action.c ****         record->event.pressed = false;
 732:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 733:tmk_core/common/action.c ****         process_record(record);
 734:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 735:tmk_core/common/action.c ****     }
 736:tmk_core/common/action.c **** #endif
 737:tmk_core/common/action.c **** }
 738:tmk_core/common/action.c **** 
 739:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 740:tmk_core/common/action.c ****  *
 741:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 742:tmk_core/common/action.c ****  */
 743:tmk_core/common/action.c **** void register_code(uint8_t code) {
 163               		.loc 1 743 34 is_stmt 1 view -0
 164               		.cfi_startproc
 165               		.loc 1 743 34 is_stmt 0 view .LVU23
 166 0000 CF93      		push r28
 167               	.LCFI4:
 168               		.cfi_def_cfa_offset 3
 169               		.cfi_offset 28, -2
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               	/* stack size = 1 */
 173               	.L__stack_usage = 1
 174 0002 C82F      		mov r28,r24
 744:tmk_core/common/action.c ****     if (code == KC_NO) {
 175               		.loc 1 744 5 is_stmt 1 view .LVU24
 176               		.loc 1 744 8 is_stmt 0 view .LVU25
 177 0004 8823      		tst r24
 178 0006 01F0      		breq .L5
 745:tmk_core/common/action.c ****         return;
 746:tmk_core/common/action.c ****     }
 747:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 748:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 749:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 750:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 751:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 752:tmk_core/common/action.c **** #    endif
 753:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 754:tmk_core/common/action.c ****         send_keyboard_report();
 755:tmk_core/common/action.c ****         wait_ms(100);
 756:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 757:tmk_core/common/action.c ****         send_keyboard_report();
 758:tmk_core/common/action.c ****     }
 759:tmk_core/common/action.c **** 
 760:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 761:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 762:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 763:tmk_core/common/action.c **** #    endif
 764:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 765:tmk_core/common/action.c ****         send_keyboard_report();
 766:tmk_core/common/action.c ****         wait_ms(100);
 767:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 768:tmk_core/common/action.c ****         send_keyboard_report();
 769:tmk_core/common/action.c ****     }
 770:tmk_core/common/action.c **** 
 771:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 772:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 773:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 774:tmk_core/common/action.c **** #    endif
 775:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 776:tmk_core/common/action.c ****         send_keyboard_report();
 777:tmk_core/common/action.c ****         wait_ms(100);
 778:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 779:tmk_core/common/action.c ****         send_keyboard_report();
 780:tmk_core/common/action.c ****     }
 781:tmk_core/common/action.c **** #endif
 782:tmk_core/common/action.c **** 
 783:tmk_core/common/action.c ****     else if
 179               		.loc 1 783 10 is_stmt 1 view .LVU26
 784:tmk_core/common/action.c ****         IS_KEY(code) {
 180               		.loc 1 784 9 is_stmt 0 view .LVU27
 181 0008 8CEF      		ldi r24,lo8(-4)
 182               	.LVL11:
 183               		.loc 1 784 9 view .LVU28
 184 000a 8C0F      		add r24,r28
 185 000c 813A      		cpi r24,lo8(-95)
 186 000e 00F4      		brsh .L7
 785:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 786:tmk_core/common/action.c ****             if (command_proc(code)) return;
 187               		.loc 1 786 13 is_stmt 1 view .LVU29
 787:tmk_core/common/action.c **** 
 788:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 789:tmk_core/common/action.c **** /* TODO: remove
 790:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 791:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 792:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 793:tmk_core/common/action.c **** 
 794:tmk_core/common/action.c ****             add_key(code);
 795:tmk_core/common/action.c ****             send_keyboard_report();
 796:tmk_core/common/action.c **** 
 797:tmk_core/common/action.c ****             set_mods(tmp_mods);
 798:tmk_core/common/action.c ****             send_keyboard_report();
 799:tmk_core/common/action.c ****             oneshot_cancel();
 800:tmk_core/common/action.c ****         } else
 801:tmk_core/common/action.c **** */
 802:tmk_core/common/action.c **** #endif
 803:tmk_core/common/action.c ****             {
 804:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 805:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 806:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 807:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 188               		.loc 1 807 17 view .LVU30
 189               		.loc 1 807 21 is_stmt 0 view .LVU31
 190 0010 6C2F      		mov r22,r28
 191 0012 8091 0000 		lds r24,keyboard_report
 192 0016 9091 0000 		lds r25,keyboard_report+1
 193 001a 0E94 0000 		call is_key_pressed
 194               	.LVL12:
 195               		.loc 1 807 20 view .LVU32
 196 001e 8823      		tst r24
 197 0020 01F0      		breq .L8
 808:tmk_core/common/action.c ****                     del_key(code);
 198               		.loc 1 808 21 is_stmt 1 view .LVU33
 199 0022 8C2F      		mov r24,r28
 200 0024 0E94 0000 		call del_key
 201               	.LVL13:
 809:tmk_core/common/action.c ****                     send_keyboard_report();
 202               		.loc 1 809 21 view .LVU34
 203 0028 0E94 0000 		call send_keyboard_report
 204               	.LVL14:
 205               	.L8:
 810:tmk_core/common/action.c ****                 }
 811:tmk_core/common/action.c ****                 add_key(code);
 206               		.loc 1 811 17 view .LVU35
 207 002c 8C2F      		mov r24,r28
 208 002e 0E94 0000 		call add_key
 209               	.LVL15:
 812:tmk_core/common/action.c ****                 send_keyboard_report();
 210               		.loc 1 812 17 view .LVU36
 211               	.L16:
 813:tmk_core/common/action.c ****             }
 814:tmk_core/common/action.c ****         }
 815:tmk_core/common/action.c ****     else if
 816:tmk_core/common/action.c ****         IS_MOD(code) {
 817:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 818:tmk_core/common/action.c ****             send_keyboard_report();
 212               		.loc 1 818 13 view .LVU37
 213               	/* epilogue start */
 819:tmk_core/common/action.c ****         }
 820:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 821:tmk_core/common/action.c ****     else if
 822:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 823:tmk_core/common/action.c ****     else if
 824:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 825:tmk_core/common/action.c **** #endif
 826:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 827:tmk_core/common/action.c ****     else if
 828:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 829:tmk_core/common/action.c ****             mousekey_on(code);
 830:tmk_core/common/action.c ****             mousekey_send();
 831:tmk_core/common/action.c ****         }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** }
 214               		.loc 1 833 1 is_stmt 0 view .LVU38
 215 0032 CF91      		pop r28
 818:tmk_core/common/action.c ****         }
 216               		.loc 1 818 13 view .LVU39
 217 0034 0C94 0000 		jmp send_keyboard_report
 218               	.LVL16:
 219               	.L7:
 815:tmk_core/common/action.c ****         IS_MOD(code) {
 220               		.loc 1 815 10 is_stmt 1 view .LVU40
 816:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 221               		.loc 1 816 9 is_stmt 0 view .LVU41
 222 0038 80E2      		ldi r24,lo8(32)
 223 003a 8C0F      		add r24,r28
 224 003c 8830      		cpi r24,lo8(8)
 225 003e 00F4      		brsh .L9
 817:tmk_core/common/action.c ****             send_keyboard_report();
 226               		.loc 1 817 13 is_stmt 1 view .LVU42
 817:tmk_core/common/action.c ****             send_keyboard_report();
 227               		.loc 1 817 22 is_stmt 0 view .LVU43
 228 0040 C770      		andi r28,lo8(7)
 229               	.LVL17:
 817:tmk_core/common/action.c ****             send_keyboard_report();
 230               		.loc 1 817 13 view .LVU44
 231 0042 81E0      		ldi r24,lo8(1)
 232 0044 00C0      		rjmp 2f
 233               		1:
 234 0046 880F      		lsl r24
 235               		2:
 236 0048 CA95      		dec r28
 237 004a 02F4      		brpl 1b
 238 004c 0E94 0000 		call add_mods
 239               	.LVL18:
 240 0050 00C0      		rjmp .L16
 241               	.LVL19:
 242               	.L9:
 827:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 243               		.loc 1 827 10 is_stmt 1 view .LVU45
 828:tmk_core/common/action.c ****             mousekey_on(code);
 244               		.loc 1 828 9 is_stmt 0 view .LVU46
 245 0052 C03F      		cpi r28,lo8(-16)
 246 0054 00F0      		brlo .L5
 829:tmk_core/common/action.c ****             mousekey_send();
 247               		.loc 1 829 13 is_stmt 1 view .LVU47
 248 0056 8C2F      		mov r24,r28
 249 0058 0E94 0000 		call mousekey_on
 250               	.LVL20:
 830:tmk_core/common/action.c ****         }
 251               		.loc 1 830 13 view .LVU48
 252               	/* epilogue start */
 253               		.loc 1 833 1 is_stmt 0 view .LVU49
 254 005c CF91      		pop r28
 255               	.LVL21:
 830:tmk_core/common/action.c ****         }
 256               		.loc 1 830 13 view .LVU50
 257 005e 0C94 0000 		jmp mousekey_send
 258               	.LVL22:
 259               	.L5:
 260               	/* epilogue start */
 261               		.loc 1 833 1 view .LVU51
 262 0062 CF91      		pop r28
 263               	.LVL23:
 264               		.loc 1 833 1 view .LVU52
 265 0064 0895      		ret
 266               		.cfi_endproc
 267               	.LFE23:
 269               		.section	.text.unregister_code,"ax",@progbits
 270               	.global	unregister_code
 272               	unregister_code:
 273               	.LVL24:
 274               	.LFB24:
 834:tmk_core/common/action.c **** 
 835:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 836:tmk_core/common/action.c ****  *
 837:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 838:tmk_core/common/action.c ****  */
 839:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 275               		.loc 1 839 36 is_stmt 1 view -0
 276               		.cfi_startproc
 277               	/* prologue: function */
 278               	/* frame size = 0 */
 279               	/* stack size = 0 */
 280               	.L__stack_usage = 0
 840:tmk_core/common/action.c ****     if (code == KC_NO) {
 281               		.loc 1 840 5 view .LVU54
 282               		.loc 1 840 8 is_stmt 0 view .LVU55
 283 0000 8823      		tst r24
 284 0002 01F0      		breq .L17
 841:tmk_core/common/action.c ****         return;
 842:tmk_core/common/action.c ****     }
 843:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 844:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 845:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 846:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 847:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 848:tmk_core/common/action.c **** #    endif
 849:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 850:tmk_core/common/action.c ****         send_keyboard_report();
 851:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 852:tmk_core/common/action.c ****         send_keyboard_report();
 853:tmk_core/common/action.c ****     }
 854:tmk_core/common/action.c **** 
 855:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 856:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 857:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 858:tmk_core/common/action.c **** #    endif
 859:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 860:tmk_core/common/action.c ****         send_keyboard_report();
 861:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 862:tmk_core/common/action.c ****         send_keyboard_report();
 863:tmk_core/common/action.c ****     }
 864:tmk_core/common/action.c **** 
 865:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 866:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 867:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 868:tmk_core/common/action.c **** #    endif
 869:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 870:tmk_core/common/action.c ****         send_keyboard_report();
 871:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 872:tmk_core/common/action.c ****         send_keyboard_report();
 873:tmk_core/common/action.c ****     }
 874:tmk_core/common/action.c **** #endif
 875:tmk_core/common/action.c **** 
 876:tmk_core/common/action.c ****     else if
 285               		.loc 1 876 10 is_stmt 1 view .LVU56
 877:tmk_core/common/action.c ****         IS_KEY(code) {
 286               		.loc 1 877 9 is_stmt 0 view .LVU57
 287 0004 9CEF      		ldi r25,lo8(-4)
 288 0006 980F      		add r25,r24
 289 0008 913A      		cpi r25,lo8(-95)
 290 000a 00F4      		brsh .L19
 878:tmk_core/common/action.c ****             del_key(code);
 291               		.loc 1 878 13 is_stmt 1 view .LVU58
 292 000c 0E94 0000 		call del_key
 293               	.LVL25:
 879:tmk_core/common/action.c ****             send_keyboard_report();
 294               		.loc 1 879 13 view .LVU59
 295               	.L26:
 880:tmk_core/common/action.c ****         }
 881:tmk_core/common/action.c ****     else if
 882:tmk_core/common/action.c ****         IS_MOD(code) {
 883:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 884:tmk_core/common/action.c ****             send_keyboard_report();
 296               		.loc 1 884 13 view .LVU60
 297 0010 0C94 0000 		jmp send_keyboard_report
 298               	.LVL26:
 299               	.L19:
 881:tmk_core/common/action.c ****         IS_MOD(code) {
 300               		.loc 1 881 10 view .LVU61
 882:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 301               		.loc 1 882 9 is_stmt 0 view .LVU62
 302 0014 90E2      		ldi r25,lo8(32)
 303 0016 980F      		add r25,r24
 304 0018 9830      		cpi r25,lo8(8)
 305 001a 00F4      		brsh .L20
 883:tmk_core/common/action.c ****             send_keyboard_report();
 306               		.loc 1 883 13 is_stmt 1 view .LVU63
 883:tmk_core/common/action.c ****             send_keyboard_report();
 307               		.loc 1 883 22 is_stmt 0 view .LVU64
 308 001c 8770      		andi r24,lo8(7)
 309               	.LVL27:
 883:tmk_core/common/action.c ****             send_keyboard_report();
 310               		.loc 1 883 13 view .LVU65
 311 001e 91E0      		ldi r25,lo8(1)
 312 0020 00C0      		rjmp 2f
 313               		1:
 314 0022 990F      		lsl r25
 315               		2:
 316 0024 8A95      		dec r24
 317 0026 02F4      		brpl 1b
 318 0028 892F      		mov r24,r25
 319 002a 0E94 0000 		call del_mods
 320               	.LVL28:
 321 002e 00C0      		rjmp .L26
 322               	.LVL29:
 323               	.L20:
 885:tmk_core/common/action.c ****         }
 886:tmk_core/common/action.c ****     else if
 324               		.loc 1 886 10 is_stmt 1 view .LVU66
 887:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 325               		.loc 1 887 9 is_stmt 0 view .LVU67
 326 0030 9BE5      		ldi r25,lo8(91)
 327 0032 980F      		add r25,r24
 328 0034 9330      		cpi r25,lo8(3)
 329 0036 00F4      		brsh .L21
 330               		.loc 1 887 27 is_stmt 1 discriminator 1 view .LVU68
 331 0038 90E0      		ldi r25,0
 332 003a 80E0      		ldi r24,0
 333               	.LVL30:
 334               		.loc 1 887 27 is_stmt 0 discriminator 1 view .LVU69
 335 003c 0C94 0000 		jmp host_system_send
 336               	.LVL31:
 337               	.L21:
 888:tmk_core/common/action.c ****     else if
 338               		.loc 1 888 10 is_stmt 1 view .LVU70
 889:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 339               		.loc 1 889 9 is_stmt 0 view .LVU71
 340 0040 98E5      		ldi r25,lo8(88)
 341 0042 980F      		add r25,r24
 342 0044 9731      		cpi r25,lo8(23)
 343 0046 00F4      		brsh .L22
 344               		.loc 1 889 29 is_stmt 1 discriminator 1 view .LVU72
 345 0048 90E0      		ldi r25,0
 346 004a 80E0      		ldi r24,0
 347               	.LVL32:
 348               		.loc 1 889 29 is_stmt 0 discriminator 1 view .LVU73
 349 004c 0C94 0000 		jmp host_consumer_send
 350               	.LVL33:
 351               	.L22:
 890:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 891:tmk_core/common/action.c ****     else if
 352               		.loc 1 891 10 is_stmt 1 view .LVU74
 892:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 353               		.loc 1 892 9 is_stmt 0 view .LVU75
 354 0050 803F      		cpi r24,lo8(-16)
 355 0052 00F0      		brlo .L17
 893:tmk_core/common/action.c ****             mousekey_off(code);
 356               		.loc 1 893 13 is_stmt 1 view .LVU76
 357 0054 0E94 0000 		call mousekey_off
 358               	.LVL34:
 894:tmk_core/common/action.c ****             mousekey_send();
 359               		.loc 1 894 13 view .LVU77
 360 0058 0C94 0000 		jmp mousekey_send
 361               	.LVL35:
 362               	.L17:
 363               	/* epilogue start */
 895:tmk_core/common/action.c ****         }
 896:tmk_core/common/action.c **** #endif
 897:tmk_core/common/action.c **** }
 364               		.loc 1 897 1 is_stmt 0 view .LVU78
 365 005c 0895      		ret
 366               		.cfi_endproc
 367               	.LFE24:
 369               		.section	.text.tap_code,"ax",@progbits
 370               	.global	tap_code
 372               	tap_code:
 373               	.LVL36:
 374               	.LFB25:
 898:tmk_core/common/action.c **** 
 899:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 900:tmk_core/common/action.c ****  *
 901:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 902:tmk_core/common/action.c ****  */
 903:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 375               		.loc 1 903 29 is_stmt 1 view -0
 376               		.cfi_startproc
 377               		.loc 1 903 29 is_stmt 0 view .LVU80
 378 0000 CF93      		push r28
 379               	.LCFI5:
 380               		.cfi_def_cfa_offset 3
 381               		.cfi_offset 28, -2
 382               	/* prologue: function */
 383               	/* frame size = 0 */
 384               	/* stack size = 1 */
 385               	.L__stack_usage = 1
 386 0002 C82F      		mov r28,r24
 904:tmk_core/common/action.c ****     register_code(code);
 387               		.loc 1 904 5 is_stmt 1 view .LVU81
 388 0004 0E94 0000 		call register_code
 389               	.LVL37:
 905:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 390               		.loc 1 905 5 view .LVU82
 391               		.loc 1 905 8 is_stmt 0 view .LVU83
 392 0008 C933      		cpi r28,lo8(57)
 393 000a 01F4      		brne .L29
 906:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 394               		.loc 1 906 9 is_stmt 1 view .LVU84
 395               	.LVL38:
 396               	.LBB18:
 397               	.LBI18:
 398               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 399               		.loc 2 166 1 view .LVU85
 400               	.LBB19:
 167:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	double __tmp ;
 401               		.loc 2 168 2 view .LVU86
 169:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 402               		.loc 2 172 2 view .LVU87
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 403               		.loc 2 173 2 view .LVU88
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 404               		.loc 2 174 2 view .LVU89
 175:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 405               		.loc 2 184 3 view .LVU90
 185:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 406               		.loc 2 187 2 view .LVU91
 407 000c 2FEF      		ldi r18,lo8(255999)
 408 000e 87EE      		ldi r24,hi8(255999)
 409 0010 93E0      		ldi r25,hlo8(255999)
 410 0012 2150      	1:	subi r18,1
 411 0014 8040      		sbci r24,0
 412 0016 9040      		sbci r25,0
 413 0018 01F4      		brne 1b
 414 001a 00C0      		rjmp .
 415 001c 0000      		nop
 416               	.LVL39:
 417               	.L29:
 418               		.loc 2 187 2 is_stmt 0 view .LVU92
 419               	.LBE19:
 420               	.LBE18:
 907:tmk_core/common/action.c ****     } else {
 908:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 909:tmk_core/common/action.c ****     }
 910:tmk_core/common/action.c ****     unregister_code(code);
 421               		.loc 1 910 5 is_stmt 1 view .LVU93
 422 001e 8C2F      		mov r24,r28
 423               	/* epilogue start */
 911:tmk_core/common/action.c **** }
 424               		.loc 1 911 1 is_stmt 0 view .LVU94
 425 0020 CF91      		pop r28
 426               	.LVL40:
 910:tmk_core/common/action.c **** }
 427               		.loc 1 910 5 view .LVU95
 428 0022 0C94 0000 		jmp unregister_code
 429               	.LVL41:
 910:tmk_core/common/action.c **** }
 430               		.loc 1 910 5 view .LVU96
 431               		.cfi_endproc
 432               	.LFE25:
 434               		.section	.text.register_mods,"ax",@progbits
 435               	.global	register_mods
 437               	register_mods:
 438               	.LVL42:
 439               	.LFB26:
 912:tmk_core/common/action.c **** 
 913:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:tmk_core/common/action.c ****  *
 915:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 916:tmk_core/common/action.c ****  */
 917:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 440               		.loc 1 917 34 is_stmt 1 view -0
 441               		.cfi_startproc
 442               	/* prologue: function */
 443               	/* frame size = 0 */
 444               	/* stack size = 0 */
 445               	.L__stack_usage = 0
 918:tmk_core/common/action.c ****     if (mods) {
 446               		.loc 1 918 5 view .LVU98
 447               		.loc 1 918 8 is_stmt 0 view .LVU99
 448 0000 8823      		tst r24
 449 0002 01F0      		breq .L30
 919:tmk_core/common/action.c ****         add_mods(mods);
 450               		.loc 1 919 9 is_stmt 1 view .LVU100
 451 0004 0E94 0000 		call add_mods
 452               	.LVL43:
 920:tmk_core/common/action.c ****         send_keyboard_report();
 453               		.loc 1 920 9 view .LVU101
 454 0008 0C94 0000 		jmp send_keyboard_report
 455               	.LVL44:
 456               	.L30:
 457               	/* epilogue start */
 921:tmk_core/common/action.c ****     }
 922:tmk_core/common/action.c **** }
 458               		.loc 1 922 1 is_stmt 0 view .LVU102
 459 000c 0895      		ret
 460               		.cfi_endproc
 461               	.LFE26:
 463               		.section	.text.unregister_mods,"ax",@progbits
 464               	.global	unregister_mods
 466               	unregister_mods:
 467               	.LVL45:
 468               	.LFB27:
 923:tmk_core/common/action.c **** 
 924:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:tmk_core/common/action.c ****  *
 926:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:tmk_core/common/action.c ****  */
 928:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 469               		.loc 1 928 36 is_stmt 1 view -0
 470               		.cfi_startproc
 471               	/* prologue: function */
 472               	/* frame size = 0 */
 473               	/* stack size = 0 */
 474               	.L__stack_usage = 0
 929:tmk_core/common/action.c ****     if (mods) {
 475               		.loc 1 929 5 view .LVU104
 476               		.loc 1 929 8 is_stmt 0 view .LVU105
 477 0000 8823      		tst r24
 478 0002 01F0      		breq .L32
 930:tmk_core/common/action.c ****         del_mods(mods);
 479               		.loc 1 930 9 is_stmt 1 view .LVU106
 480 0004 0E94 0000 		call del_mods
 481               	.LVL46:
 931:tmk_core/common/action.c ****         send_keyboard_report();
 482               		.loc 1 931 9 view .LVU107
 483 0008 0C94 0000 		jmp send_keyboard_report
 484               	.LVL47:
 485               	.L32:
 486               	/* epilogue start */
 932:tmk_core/common/action.c ****     }
 933:tmk_core/common/action.c **** }
 487               		.loc 1 933 1 is_stmt 0 view .LVU108
 488 000c 0895      		ret
 489               		.cfi_endproc
 490               	.LFE27:
 492               		.section	.text.process_action,"ax",@progbits
 493               	.global	process_action
 495               	process_action:
 496               	.LVL48:
 497               	.LFB22:
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 498               		.loc 1 227 59 is_stmt 1 view -0
 499               		.cfi_startproc
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 500               		.loc 1 227 59 is_stmt 0 view .LVU110
 501 0000 BF92      		push r11
 502               	.LCFI6:
 503               		.cfi_def_cfa_offset 3
 504               		.cfi_offset 11, -2
 505 0002 CF92      		push r12
 506               	.LCFI7:
 507               		.cfi_def_cfa_offset 4
 508               		.cfi_offset 12, -3
 509 0004 DF92      		push r13
 510               	.LCFI8:
 511               		.cfi_def_cfa_offset 5
 512               		.cfi_offset 13, -4
 513 0006 EF92      		push r14
 514               	.LCFI9:
 515               		.cfi_def_cfa_offset 6
 516               		.cfi_offset 14, -5
 517 0008 FF92      		push r15
 518               	.LCFI10:
 519               		.cfi_def_cfa_offset 7
 520               		.cfi_offset 15, -6
 521 000a 0F93      		push r16
 522               	.LCFI11:
 523               		.cfi_def_cfa_offset 8
 524               		.cfi_offset 16, -7
 525 000c 1F93      		push r17
 526               	.LCFI12:
 527               		.cfi_def_cfa_offset 9
 528               		.cfi_offset 17, -8
 529 000e CF93      		push r28
 530               	.LCFI13:
 531               		.cfi_def_cfa_offset 10
 532               		.cfi_offset 28, -9
 533 0010 DF93      		push r29
 534               	.LCFI14:
 535               		.cfi_def_cfa_offset 11
 536               		.cfi_offset 29, -10
 537               	/* prologue: function */
 538               	/* frame size = 0 */
 539               	/* stack size = 9 */
 540               	.L__stack_usage = 9
 541 0012 7C01      		movw r14,r24
 542 0014 D62F      		mov r29,r22
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 543               		.loc 1 227 59 view .LVU111
 544 0016 C72F      		mov r28,r23
 228:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 545               		.loc 1 228 5 is_stmt 1 view .LVU112
 546               	.LVL49:
 230:tmk_core/common/action.c **** #endif
 547               		.loc 1 230 5 view .LVU113
 230:tmk_core/common/action.c **** #endif
 548               		.loc 1 230 36 is_stmt 0 view .LVU114
 549 0018 FC01      		movw r30,r24
 550 001a 0581      		ldd r16,Z+5
 551 001c 0295      		swap r16
 552 001e 0F70      		andi r16,lo8(15)
 553               	.LVL50:
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 554               		.loc 1 233 5 is_stmt 1 view .LVU115
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 555               		.loc 1 233 14 is_stmt 0 view .LVU116
 556 0020 1281      		ldd r17,Z+2
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 557               		.loc 1 233 8 view .LVU117
 558 0022 1111      		cpse r17,__zero_reg__
 235:tmk_core/common/action.c ****     }
 559               		.loc 1 235 9 is_stmt 1 view .LVU118
 560 0024 0E94 0000 		call clear_weak_mods
 561               	.LVL51:
 562               	.L35:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 563               		.loc 1 239 5 view .LVU119
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 564               		.loc 1 241 5 view .LVU120
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 565               		.loc 1 241 9 is_stmt 0 view .LVU121
 566 0028 0E94 0000 		call is_oneshot_layer_active
 567               	.LVL52:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 568               		.loc 1 241 9 view .LVU122
 569 002c D82E      		mov r13,r24
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 570               		.loc 1 241 8 view .LVU123
 571 002e 8823      		tst r24
 572 0030 01F0      		breq .L36
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 573               		.loc 1 241 35 discriminator 1 view .LVU124
 574 0032 1123      		tst r17
 575 0034 01F0      		breq .L107
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 576               		.loc 1 241 71 discriminator 2 view .LVU125
 577 0036 8C2F      		mov r24,r28
 578 0038 807F      		andi r24,lo8(-16)
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 579               		.loc 1 241 52 discriminator 2 view .LVU126
 580 003a 8034      		cpi r24,lo8(64)
 581 003c 01F0      		breq .L37
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 582               		.loc 1 241 87 discriminator 3 view .LVU127
 583 003e 80E2      		ldi r24,lo8(32)
 584               	.LVL53:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 585               		.loc 1 241 87 discriminator 3 view .LVU128
 586 0040 8D0F      		add r24,r29
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 587               		.loc 1 241 84 discriminator 3 view .LVU129
 588 0042 8830      		cpi r24,lo8(8)
 589 0044 00F0      		brlo .L107
 590               	.L37:
 246:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 591               		.loc 1 246 9 is_stmt 1 view .LVU130
 592 0046 82E0      		ldi r24,lo8(2)
 593 0048 0E94 0000 		call clear_oneshot_layer_state
 594               	.LVL54:
 247:tmk_core/common/action.c ****     }
 595               		.loc 1 247 9 view .LVU131
 247:tmk_core/common/action.c ****     }
 596               		.loc 1 247 31 is_stmt 0 view .LVU132
 597 004c 0E94 0000 		call is_oneshot_layer_active
 598               	.LVL55:
 247:tmk_core/common/action.c ****     }
 599               		.loc 1 247 9 view .LVU133
 600 0050 91E0      		ldi r25,lo8(1)
 601 0052 D82E      		mov r13,r24
 602 0054 D926      		eor r13,r25
 603               	.LVL56:
 604               	.L36:
 251:tmk_core/common/action.c ****         /* Key and Mods */
 605               		.loc 1 251 5 is_stmt 1 view .LVU134
 251:tmk_core/common/action.c ****         /* Key and Mods */
 606               		.loc 1 251 24 is_stmt 0 view .LVU135
 607 0056 CC2E      		mov r12,r28
 608 0058 C294      		swap r12
 609 005a 9FE0      		ldi r25,lo8(15)
 610 005c C922      		and r12,r25
 251:tmk_core/common/action.c ****         /* Key and Mods */
 611               		.loc 1 251 5 view .LVU136
 612 005e FBE0      		ldi r31,lo8(11)
 613 0060 FC15      		cp r31,r12
 614 0062 00F0      		brlo .L38
 615 0064 EC2D      		mov r30,r12
 616 0066 F0E0      		ldi r31,0
 617 0068 E050      		subi r30,lo8(-(gs(.L40)))
 618 006a F040      		sbci r31,hi8(-(gs(.L40)))
 619 006c 0C94 0000 		jmp __tablejump2__
 620               		.section	.jumptables.gcc.process_action,"a",@progbits
 621               		.p2align	1
 622               	.L40:
 623 0000 0000      		.word gs(.L45)
 624 0002 0000      		.word gs(.L45)
 625 0004 0000      		.word gs(.L44)
 626 0006 0000      		.word gs(.L44)
 627 0008 0000      		.word gs(.L38)
 628 000a 0000      		.word gs(.L43)
 629 000c 0000      		.word gs(.L38)
 630 000e 0000      		.word gs(.L38)
 631 0010 0000      		.word gs(.L42)
 632 0012 0000      		.word gs(.L41)
 633 0014 0000      		.word gs(.L39)
 634 0016 0000      		.word gs(.L39)
 635               		.section	.text.process_action
 636               	.LVL57:
 637               	.L107:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 638               		.loc 1 239 10 view .LVU137
 639 0070 D12C      		mov r13,__zero_reg__
 640 0072 00C0      		rjmp .L36
 641               	.LVL58:
 642               	.L45:
 643               	.LBB20:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 644               		.loc 1 255 13 is_stmt 1 view .LVU138
 645 0074 0C2F      		mov r16,r28
 646               	.LVL59:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 647               		.loc 1 255 13 is_stmt 0 view .LVU139
 648 0076 0F70      		andi r16,lo8(15)
 255:tmk_core/common/action.c ****             if (event.pressed) {
 649               		.loc 1 255 44 view .LVU140
 650 0078 C07F      		andi r28,lo8(-16)
 651               	.LVL60:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 652               		.loc 1 255 21 view .LVU141
 653 007a 01F0      		breq .L46
 255:tmk_core/common/action.c ****             if (event.pressed) {
 654               		.loc 1 255 21 discriminator 2 view .LVU142
 655 007c 0295      		swap r16
 656 007e 007F      		andi r16,lo8(-16)
 657               	.L46:
 658               	.LVL61:
 256:tmk_core/common/action.c ****                 if (mods) {
 659               		.loc 1 256 13 is_stmt 1 discriminator 4 view .LVU143
 256:tmk_core/common/action.c ****                 if (mods) {
 660               		.loc 1 256 16 is_stmt 0 discriminator 4 view .LVU144
 661 0080 1123      		tst r17
 662 0082 01F0      		breq .L47
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 663               		.loc 1 257 17 is_stmt 1 view .LVU145
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 664               		.loc 1 257 20 is_stmt 0 view .LVU146
 665 0084 0023      		tst r16
 666 0086 01F0      		breq .L140
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 667               		.loc 1 258 21 is_stmt 1 view .LVU147
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 668               		.loc 1 258 25 is_stmt 0 view .LVU148
 669 0088 80E2      		ldi r24,lo8(32)
 670 008a 8D0F      		add r24,r29
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 671               		.loc 1 258 24 view .LVU149
 672 008c 8830      		cpi r24,lo8(8)
 673 008e 00F0      		brlo .L49
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 674               		.loc 1 258 49 discriminator 1 view .LVU150
 675 0090 D111      		cpse r29,__zero_reg__
 676 0092 00C0      		rjmp .L50
 677               	.L49:
 262:tmk_core/common/action.c ****                     } else {
 678               		.loc 1 262 25 is_stmt 1 view .LVU151
 679 0094 802F      		mov r24,r16
 680 0096 0E94 0000 		call add_mods
 681               	.LVL62:
 682               	.L51:
 266:tmk_core/common/action.c ****                 }
 683               		.loc 1 266 21 view .LVU152
 684 009a 0E94 0000 		call send_keyboard_report
 685               	.LVL63:
 268:tmk_core/common/action.c ****             } else {
 686               		.loc 1 268 17 view .LVU153
 687               	.L140:
 268:tmk_core/common/action.c ****             } else {
 688               		.loc 1 268 17 is_stmt 0 view .LVU154
 689               	.LBE20:
 565:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 690               		.loc 1 565 75 is_stmt 1 view .LVU155
 566:tmk_core/common/action.c ****                         } else {
 691               		.loc 1 566 29 view .LVU156
 692 009e 8D2F      		mov r24,r29
 693 00a0 0E94 0000 		call register_code
 694               	.LVL64:
 695 00a4 00C0      		rjmp .L38
 696               	.LVL65:
 697               	.L50:
 698               	.LBB21:
 264:tmk_core/common/action.c ****                     }
 699               		.loc 1 264 25 view .LVU157
 700 00a6 802F      		mov r24,r16
 701 00a8 0E94 0000 		call add_weak_mods
 702               	.LVL66:
 703 00ac 00C0      		rjmp .L51
 704               	.L47:
 270:tmk_core/common/action.c ****                 if (mods) {
 705               		.loc 1 270 17 view .LVU158
 706 00ae 8D2F      		mov r24,r29
 707 00b0 0E94 0000 		call unregister_code
 708               	.LVL67:
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 709               		.loc 1 271 17 view .LVU159
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 710               		.loc 1 271 20 is_stmt 0 view .LVU160
 711 00b4 0023      		tst r16
 712 00b6 01F0      		breq .L38
 272:tmk_core/common/action.c ****                         del_mods(mods);
 713               		.loc 1 272 21 is_stmt 1 view .LVU161
 272:tmk_core/common/action.c ****                         del_mods(mods);
 714               		.loc 1 272 25 is_stmt 0 view .LVU162
 715 00b8 80E2      		ldi r24,lo8(32)
 716 00ba 8D0F      		add r24,r29
 272:tmk_core/common/action.c ****                         del_mods(mods);
 717               		.loc 1 272 24 view .LVU163
 718 00bc 8830      		cpi r24,lo8(8)
 719 00be 00F0      		brlo .L53
 272:tmk_core/common/action.c ****                         del_mods(mods);
 720               		.loc 1 272 49 discriminator 1 view .LVU164
 721 00c0 D111      		cpse r29,__zero_reg__
 722 00c2 00C0      		rjmp .L54
 723               	.L53:
 273:tmk_core/common/action.c ****                     } else {
 724               		.loc 1 273 25 is_stmt 1 view .LVU165
 725 00c4 802F      		mov r24,r16
 726 00c6 0E94 0000 		call del_mods
 727               	.LVL68:
 728               	.L55:
 277:tmk_core/common/action.c ****                 }
 729               		.loc 1 277 21 view .LVU166
 730 00ca 0E94 0000 		call send_keyboard_report
 731               	.LVL69:
 732               	.L38:
 277:tmk_core/common/action.c ****                 }
 733               		.loc 1 277 21 is_stmt 0 view .LVU167
 734               	.LBE21:
 680:tmk_core/common/action.c ****         case ACT_LAYER:
 735               		.loc 1 680 5 is_stmt 1 view .LVU168
 736 00ce EC2D      		mov r30,r12
 737 00d0 E850      		subi r30,8
 738 00d2 FF0B      		sbc r31,r31
 739 00d4 3497      		sbiw r30,4
 740 00d6 00F4      		brsh .L102
 687:tmk_core/common/action.c ****             break;
 741               		.loc 1 687 13 view .LVU169
 742 00d8 0E94 0000 		call host_keyboard_leds
 743               	.LVL70:
 744 00dc 0E94 0000 		call led_set
 745               	.LVL71:
 688:tmk_core/common/action.c ****         default:
 746               		.loc 1 688 13 view .LVU170
 747               	.L102:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 748               		.loc 1 730 5 view .LVU171
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 749               		.loc 1 730 8 is_stmt 0 view .LVU172
 750 00e0 DD20      		tst r13
 751 00e2 01F4      		brne .+2
 752 00e4 00C0      		rjmp .L34
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 753               		.loc 1 730 33 discriminator 1 view .LVU173
 754 00e6 0E94 0000 		call get_oneshot_layer_state
 755               	.LVL72:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 756               		.loc 1 730 28 discriminator 1 view .LVU174
 757 00ea 80FD      		sbrc r24,0
 758 00ec 00C0      		rjmp .L34
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 759               		.loc 1 731 9 is_stmt 1 view .LVU175
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 760               		.loc 1 731 31 is_stmt 0 view .LVU176
 761 00ee F701      		movw r30,r14
 762 00f0 1282      		std Z+2,__zero_reg__
 732:tmk_core/common/action.c ****         process_record(record);
 763               		.loc 1 732 9 is_stmt 1 view .LVU177
 764 00f2 0E94 0000 		call get_oneshot_layer
 765               	.LVL73:
 766 00f6 0E94 0000 		call layer_on
 767               	.LVL74:
 733:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 768               		.loc 1 733 9 view .LVU178
 769 00fa C701      		movw r24,r14
 770 00fc 0E94 0000 		call process_record
 771               	.LVL75:
 734:tmk_core/common/action.c ****     }
 772               		.loc 1 734 9 view .LVU179
 773 0100 0E94 0000 		call get_oneshot_layer
 774               	.LVL76:
 775               	/* epilogue start */
 737:tmk_core/common/action.c **** 
 776               		.loc 1 737 1 is_stmt 0 view .LVU180
 777 0104 DF91      		pop r29
 778               	.LVL77:
 737:tmk_core/common/action.c **** 
 779               		.loc 1 737 1 view .LVU181
 780 0106 CF91      		pop r28
 737:tmk_core/common/action.c **** 
 781               		.loc 1 737 1 view .LVU182
 782 0108 1F91      		pop r17
 783 010a 0F91      		pop r16
 784 010c FF90      		pop r15
 785 010e EF90      		pop r14
 786               	.LVL78:
 737:tmk_core/common/action.c **** 
 787               		.loc 1 737 1 view .LVU183
 788 0110 DF90      		pop r13
 789               	.LVL79:
 737:tmk_core/common/action.c **** 
 790               		.loc 1 737 1 view .LVU184
 791 0112 CF90      		pop r12
 792 0114 BF90      		pop r11
 734:tmk_core/common/action.c ****     }
 793               		.loc 1 734 9 view .LVU185
 794 0116 0C94 0000 		jmp layer_off
 795               	.LVL80:
 796               	.L54:
 797               	.LBB22:
 275:tmk_core/common/action.c ****                     }
 798               		.loc 1 275 25 is_stmt 1 view .LVU186
 799 011a 802F      		mov r24,r16
 800 011c 0E94 0000 		call del_weak_mods
 801               	.LVL81:
 802 0120 00C0      		rjmp .L55
 803               	.LVL82:
 804               	.L44:
 275:tmk_core/common/action.c ****                     }
 805               		.loc 1 275 25 is_stmt 0 view .LVU187
 806               	.LBE22:
 807               	.LBB23:
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 808               		.loc 1 284 13 is_stmt 1 view .LVU188
 809 0122 2C2F      		mov r18,r28
 810 0124 2F70      		andi r18,lo8(15)
 811 0126 B22E      		mov r11,r18
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 812               		.loc 1 284 44 is_stmt 0 view .LVU189
 813 0128 C07F      		andi r28,lo8(-16)
 814               	.LVL83:
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 815               		.loc 1 284 21 view .LVU190
 816 012a C032      		cpi r28,lo8(32)
 817 012c 01F0      		breq .L56
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 818               		.loc 1 284 21 discriminator 2 view .LVU191
 819 012e B294      		swap r11
 820 0130 80EF      		ldi r24,lo8(-16)
 821 0132 B822      		and r11,r24
 822               	.L56:
 823               	.LVL84:
 285:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 824               		.loc 1 285 13 is_stmt 1 discriminator 4 view .LVU192
 825 0134 DD23      		tst r29
 826 0136 01F0      		breq .L57
 827 0138 D130      		cpi r29,lo8(1)
 828 013a 01F0      		breq .L58
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 829               		.loc 1 340 21 view .LVU193
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 830               		.loc 1 340 24 is_stmt 0 view .LVU194
 831 013c 1123      		tst r17
 832 013e 01F0      		breq .L66
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 833               		.loc 1 341 25 is_stmt 1 view .LVU195
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 834               		.loc 1 341 28 is_stmt 0 view .LVU196
 835 0140 0023      		tst r16
 836 0142 01F0      		breq .L67
 837 0144 00C0      		rjmp .L140
 838               	.L57:
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 839               		.loc 1 289 21 is_stmt 1 view .LVU197
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 840               		.loc 1 289 24 is_stmt 0 view .LVU198
 841 0146 1123      		tst r17
 842 0148 01F0      		breq .L60
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 843               		.loc 1 290 25 is_stmt 1 view .LVU199
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 844               		.loc 1 290 28 is_stmt 0 view .LVU200
 845 014a 0111      		cpse r16,__zero_reg__
 846 014c 00C0      		rjmp .L61
 847               	.L62:
 304:tmk_core/common/action.c ****                         }
 848               		.loc 1 304 29 is_stmt 1 view .LVU201
 304:tmk_core/common/action.c ****                         }
 849               		.loc 1 304 50 is_stmt 0 view .LVU202
 850 014e 0E94 0000 		call get_oneshot_mods
 851               	.LVL85:
 304:tmk_core/common/action.c ****                         }
 852               		.loc 1 304 29 view .LVU203
 853 0152 8B29      		or r24,r11
 854               	.LVL86:
 855               	.L139:
 304:tmk_core/common/action.c ****                         }
 856               		.loc 1 304 29 view .LVU204
 857               	.LBE23:
 492:tmk_core/common/action.c ****             } else {
 858               		.loc 1 492 17 view .LVU205
 859 0154 0E94 0000 		call register_mods
 860               	.LVL87:
 861 0158 00C0      		rjmp .L38
 862               	.LVL88:
 863               	.L61:
 864               	.LBB26:
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 865               		.loc 1 293 32 is_stmt 1 view .LVU206
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 866               		.loc 1 293 35 is_stmt 0 view .LVU207
 867 015a 0130      		cpi r16,lo8(1)
 868 015c 01F4      		brne .L62
 294:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 869               		.loc 1 294 65 is_stmt 1 view .LVU208
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 870               		.loc 1 295 29 view .LVU209
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 871               		.loc 1 295 53 is_stmt 0 view .LVU210
 872 015e 0E94 0000 		call get_oneshot_mods
 873               	.LVL89:
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 874               		.loc 1 295 29 view .LVU211
 875 0162 8B29      		or r24,r11
 876 0164 0E94 0000 		call set_oneshot_mods
 877               	.LVL90:
 878 0168 00C0      		rjmp .L38
 879               	.L60:
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 880               		.loc 1 307 25 is_stmt 1 view .LVU212
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 881               		.loc 1 307 28 is_stmt 0 view .LVU213
 882 016a 0111      		cpse r16,__zero_reg__
 883 016c 00C0      		rjmp .L63
 884               	.L141:
 322:tmk_core/common/action.c ****                             unregister_mods(mods);
 885               		.loc 1 322 29 is_stmt 1 view .LVU214
 886 016e 0E94 0000 		call clear_oneshot_mods
 887               	.LVL91:
 323:tmk_core/common/action.c ****                         }
 888               		.loc 1 323 29 view .LVU215
 889               	.L68:
 372:tmk_core/common/action.c ****                             unregister_mods(mods);
 890               		.loc 1 372 67 view .LVU216
 373:tmk_core/common/action.c ****                         }
 891               		.loc 1 373 29 view .LVU217
 892 0172 8B2D      		mov r24,r11
 893 0174 0E94 0000 		call unregister_mods
 894               	.LVL92:
 895 0178 00C0      		rjmp .L38
 896               	.L63:
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 897               		.loc 1 310 32 view .LVU218
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 898               		.loc 1 310 35 is_stmt 0 view .LVU219
 899 017a 0130      		cpi r16,lo8(1)
 900 017c 01F4      		brne .+2
 901 017e 00C0      		rjmp .L38
 902 0180 00C0      		rjmp .L141
 903               	.L58:
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 904               		.loc 1 329 21 is_stmt 1 view .LVU220
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 905               		.loc 1 329 24 is_stmt 0 view .LVU221
 906 0182 1123      		tst r17
 907 0184 01F0      		breq .L65
 330:tmk_core/common/action.c ****                             register_mods(mods);
 908               		.loc 1 330 25 is_stmt 1 view .LVU222
 330:tmk_core/common/action.c ****                             register_mods(mods);
 909               		.loc 1 330 28 is_stmt 0 view .LVU223
 910 0186 0630      		cpi r16,lo8(6)
 911 0188 00F0      		brlo .+2
 912 018a 00C0      		rjmp .L38
 913               	.L67:
 359:tmk_core/common/action.c ****                             register_mods(mods);
 914               		.loc 1 359 67 is_stmt 1 view .LVU224
 360:tmk_core/common/action.c ****                         }
 915               		.loc 1 360 29 view .LVU225
 916 018c 8B2D      		mov r24,r11
 917 018e 00C0      		rjmp .L139
 918               	.L65:
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 919               		.loc 1 334 25 view .LVU226
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 920               		.loc 1 334 28 is_stmt 0 view .LVU227
 921 0190 0530      		cpi r16,lo8(5)
 922 0192 00F0      		brlo .+2
 923 0194 00C0      		rjmp .L38
 924 0196 00C0      		rjmp .L68
 925               	.L66:
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 926               		.loc 1 363 25 is_stmt 1 view .LVU228
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 927               		.loc 1 363 28 is_stmt 0 view .LVU229
 928 0198 0023      		tst r16
 929 019a 01F0      		breq .L68
 364:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 930               		.loc 1 364 71 is_stmt 1 view .LVU230
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 931               		.loc 1 365 29 view .LVU231
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 932               		.loc 1 365 32 is_stmt 0 view .LVU232
 933 019c D933      		cpi r29,lo8(57)
 934 019e 01F4      		brne .L101
 366:tmk_core/common/action.c ****                             } else {
 935               		.loc 1 366 33 is_stmt 1 view .LVU233
 936               	.LVL93:
 937               	.LBB24:
 938               	.LBI24:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 939               		.loc 2 166 1 view .LVU234
 940               	.LBB25:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 941               		.loc 2 168 2 view .LVU235
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 942               		.loc 2 172 2 view .LVU236
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 943               		.loc 2 173 2 view .LVU237
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 944               		.loc 2 174 2 view .LVU238
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 945               		.loc 2 184 3 view .LVU239
 946               		.loc 2 187 2 view .LVU240
 947 01a0 3FEF      		ldi r19,lo8(255999)
 948 01a2 87EE      		ldi r24,hi8(255999)
 949 01a4 93E0      		ldi r25,hlo8(255999)
 950 01a6 3150      	1:	subi r19,1
 951 01a8 8040      		sbci r24,0
 952 01aa 9040      		sbci r25,0
 953 01ac 01F4      		brne 1b
 954               	.LVL94:
 955               	.L142:
 956               		.loc 2 187 2 is_stmt 0 view .LVU241
 957               	.LBE25:
 958               	.LBE24:
 959               	.LBE26:
 960               	.LBB27:
 961               	.LBB28:
 962 01ae 00C0      		rjmp .
 963 01b0 0000      		nop
 964               	.L101:
 965               	.LBE28:
 966               	.LBE27:
 579:tmk_core/common/action.c ****                         } else {
 967               		.loc 1 579 29 is_stmt 1 view .LVU242
 968 01b2 8D2F      		mov r24,r29
 969 01b4 0E94 0000 		call unregister_code
 970               	.LVL95:
 971 01b8 00C0      		rjmp .L38
 972               	.L43:
 404:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 973               		.loc 1 404 13 view .LVU243
 405:tmk_core/common/action.c ****                 switch (action.key.code) {
 974               		.loc 1 405 17 is_stmt 0 view .LVU244
 975 01ba 8D2F      		mov r24,r29
 404:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 976               		.loc 1 404 16 view .LVU245
 977 01bc 1123      		tst r17
 978 01be 01F0      		breq .L71
 405:tmk_core/common/action.c ****                 switch (action.key.code) {
 979               		.loc 1 405 17 is_stmt 1 view .LVU246
 980 01c0 0E94 0000 		call mousekey_on
 981               	.LVL96:
 406:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 982               		.loc 1 406 17 view .LVU247
 419:tmk_core/common/action.c ****                         break;
 983               		.loc 1 419 25 view .LVU248
 984               	.L135:
 424:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 985               		.loc 1 424 17 view .LVU249
 437:tmk_core/common/action.c ****                         break;
 986               		.loc 1 437 25 view .LVU250
 987 01c4 0E94 0000 		call mousekey_send
 988               	.LVL97:
 438:tmk_core/common/action.c ****                 }
 989               		.loc 1 438 25 view .LVU251
 990 01c8 00C0      		rjmp .L38
 991               	.L71:
 423:tmk_core/common/action.c ****                 switch (action.key.code) {
 992               		.loc 1 423 17 view .LVU252
 993 01ca 0E94 0000 		call mousekey_off
 994               	.LVL98:
 995 01ce 00C0      		rjmp .L135
 996               	.L42:
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 997               		.loc 1 445 13 view .LVU253
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 998               		.loc 1 445 39 is_stmt 0 view .LVU254
 999 01d0 8C2F      		mov r24,r28
 1000 01d2 8370      		andi r24,lo8(3)
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1001               		.loc 1 445 16 view .LVU255
 1002 01d4 01F0      		breq .+2
 1003 01d6 00C0      		rjmp .L72
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1004               		.loc 1 447 17 is_stmt 1 view .LVU256
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1005               		.loc 1 447 20 is_stmt 0 view .LVU257
 1006 01d8 1111      		cpse r17,__zero_reg__
 1007 01da 00C0      		rjmp .L38
 1008               	.LBB30:
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1009               		.loc 1 448 21 is_stmt 1 view .LVU258
 1010               	.LVL99:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1011               		.loc 1 449 21 view .LVU259
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1012               		.loc 1 448 61 is_stmt 0 view .LVU260
 1013 01dc 4D2F      		mov r20,r29
 1014 01de 4295      		swap r20
 1015 01e0 4695      		lsr r20
 1016 01e2 4770      		andi r20,lo8(7)
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1017               		.loc 1 448 35 view .LVU261
 1018 01e4 440F      		lsl r20
 1019 01e6 440F      		lsl r20
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1020               		.loc 1 449 77 view .LVU262
 1021 01e8 0D2F      		mov r16,r29
 1022               	.LVL100:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1023               		.loc 1 449 77 view .LVU263
 1024 01ea 0F70      		andi r16,lo8(15)
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1025               		.loc 1 449 44 view .LVU264
 1026 01ec 10E0      		ldi r17,0
 1027               	.LVL101:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1028               		.loc 1 449 44 view .LVU265
 1029 01ee 30E0      		ldi r19,0
 1030 01f0 20E0      		ldi r18,0
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1031               		.loc 1 449 35 view .LVU266
 1032 01f2 042E      		mov r0,r20
 1033 01f4 00C0      		rjmp 2f
 1034               		1:
 1035 01f6 000F      		lsl r16
 1036 01f8 111F      		rol r17
 1037 01fa 221F      		rol r18
 1038 01fc 331F      		rol r19
 1039               		2:
 1040 01fe 0A94      		dec r0
 1041 0200 02F4      		brpl 1b
 1042               	.LVL102:
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1043               		.loc 1 450 21 is_stmt 1 view .LVU267
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1044               		.loc 1 450 104 is_stmt 0 view .LVU268
 1045 0202 60E0      		ldi r22,0
 1046 0204 70E0      		ldi r23,0
 1047 0206 CB01      		movw r24,r22
 1048 0208 D4FF      		sbrs r29,4
 1049 020a 00C0      		rjmp .L73
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1050               		.loc 1 450 94 discriminator 1 view .LVU269
 1051 020c 6FE0      		ldi r22,lo8(15)
 1052 020e 70E0      		ldi r23,0
 1053 0210 80E0      		ldi r24,0
 1054 0212 90E0      		ldi r25,0
 1055 0214 00C0      		rjmp 2f
 1056               		1:
 1057 0216 660F      		lsl r22
 1058 0218 771F      		rol r23
 1059 021a 881F      		rol r24
 1060 021c 991F      		rol r25
 1061               		2:
 1062 021e 4A95      		dec r20
 1063 0220 02F4      		brpl 1b
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1064               		.loc 1 450 104 discriminator 1 view .LVU270
 1065 0222 6095      		com r22
 1066 0224 7095      		com r23
 1067 0226 8095      		com r24
 1068 0228 9095      		com r25
 1069               	.L73:
 1070               	.LVL103:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1071               		.loc 1 451 21 is_stmt 1 discriminator 4 view .LVU271
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1072               		.loc 1 451 47 is_stmt 0 discriminator 4 view .LVU272
 1073 022a C695      		lsr r28
 1074 022c C695      		lsr r28
 1075               	.LVL104:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1076               		.loc 1 451 47 discriminator 4 view .LVU273
 1077 022e C370      		andi r28,lo8(3)
 1078 0230 602B      		or r22,r16
 1079               	.LVL105:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1080               		.loc 1 451 47 discriminator 4 view .LVU274
 1081 0232 712B      		or r23,r17
 1082 0234 822B      		or r24,r18
 1083 0236 932B      		or r25,r19
 1084 0238 C230      		cpi r28,lo8(2)
 1085 023a 01F0      		breq .L74
 1086 023c 00F4      		brsh .L75
 1087 023e C130      		cpi r28,lo8(1)
 1088 0240 01F0      		breq .L76
 453:tmk_core/common/action.c ****                             break;
 1089               		.loc 1 453 29 is_stmt 1 view .LVU275
 1090 0242 0E94 0000 		call default_layer_and
 1091               	.LVL106:
 454:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1092               		.loc 1 454 29 view .LVU276
 1093 0246 00C0      		rjmp .L38
 1094               	.L76:
 456:tmk_core/common/action.c ****                             break;
 1095               		.loc 1 456 29 view .LVU277
 1096 0248 0E94 0000 		call default_layer_or
 1097               	.LVL107:
 457:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1098               		.loc 1 457 29 view .LVU278
 1099 024c 00C0      		rjmp .L38
 1100               	.L74:
 459:tmk_core/common/action.c ****                             break;
 1101               		.loc 1 459 29 view .LVU279
 1102 024e 0E94 0000 		call default_layer_xor
 1103               	.LVL108:
 460:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1104               		.loc 1 460 29 view .LVU280
 1105 0252 00C0      		rjmp .L38
 1106               	.L75:
 462:tmk_core/common/action.c ****                             break;
 1107               		.loc 1 462 29 view .LVU281
 1108 0254 0E94 0000 		call default_layer_set
 1109               	.LVL109:
 463:tmk_core/common/action.c ****                     }
 1110               		.loc 1 463 29 view .LVU282
 1111 0258 00C0      		rjmp .L38
 1112               	.LVL110:
 1113               	.L72:
 463:tmk_core/common/action.c ****                     }
 1114               		.loc 1 463 29 is_stmt 0 view .LVU283
 1115               	.LBE30:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1116               		.loc 1 468 17 is_stmt 1 view .LVU284
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1117               		.loc 1 468 21 is_stmt 0 view .LVU285
 1118 025a 8695      		lsr r24
 1119 025c 1123      		tst r17
 1120 025e 01F0      		breq .L78
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1121               		.loc 1 468 21 discriminator 1 view .LVU286
 1122 0260 8C2F      		mov r24,r28
 1123 0262 8170      		andi r24,lo8(1)
 1124               	.L78:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1125               		.loc 1 468 20 discriminator 4 view .LVU287
 1126 0264 8823      		tst r24
 1127 0266 01F4      		brne .+2
 1128 0268 00C0      		rjmp .L38
 1129               	.LBB31:
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1130               		.loc 1 469 21 is_stmt 1 view .LVU288
 1131               	.LVL111:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1132               		.loc 1 470 21 view .LVU289
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1133               		.loc 1 469 61 is_stmt 0 view .LVU290
 1134 026a 4D2F      		mov r20,r29
 1135 026c 4295      		swap r20
 1136 026e 4695      		lsr r20
 1137 0270 4770      		andi r20,lo8(7)
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1138               		.loc 1 469 35 view .LVU291
 1139 0272 440F      		lsl r20
 1140 0274 440F      		lsl r20
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1141               		.loc 1 470 77 view .LVU292
 1142 0276 0D2F      		mov r16,r29
 1143               	.LVL112:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1144               		.loc 1 470 77 view .LVU293
 1145 0278 0F70      		andi r16,lo8(15)
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1146               		.loc 1 470 44 view .LVU294
 1147 027a 10E0      		ldi r17,0
 1148               	.LVL113:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1149               		.loc 1 470 44 view .LVU295
 1150 027c 30E0      		ldi r19,0
 1151 027e 20E0      		ldi r18,0
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1152               		.loc 1 470 35 view .LVU296
 1153 0280 042E      		mov r0,r20
 1154 0282 00C0      		rjmp 2f
 1155               		1:
 1156 0284 000F      		lsl r16
 1157 0286 111F      		rol r17
 1158 0288 221F      		rol r18
 1159 028a 331F      		rol r19
 1160               		2:
 1161 028c 0A94      		dec r0
 1162 028e 02F4      		brpl 1b
 1163               	.LVL114:
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1164               		.loc 1 471 21 is_stmt 1 view .LVU297
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1165               		.loc 1 471 104 is_stmt 0 view .LVU298
 1166 0290 60E0      		ldi r22,0
 1167 0292 70E0      		ldi r23,0
 1168 0294 CB01      		movw r24,r22
 1169 0296 D4FF      		sbrs r29,4
 1170 0298 00C0      		rjmp .L79
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1171               		.loc 1 471 94 discriminator 1 view .LVU299
 1172 029a 6FE0      		ldi r22,lo8(15)
 1173 029c 70E0      		ldi r23,0
 1174 029e 80E0      		ldi r24,0
 1175 02a0 90E0      		ldi r25,0
 1176 02a2 00C0      		rjmp 2f
 1177               		1:
 1178 02a4 660F      		lsl r22
 1179 02a6 771F      		rol r23
 1180 02a8 881F      		rol r24
 1181 02aa 991F      		rol r25
 1182               		2:
 1183 02ac 4A95      		dec r20
 1184 02ae 02F4      		brpl 1b
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1185               		.loc 1 471 104 discriminator 1 view .LVU300
 1186 02b0 6095      		com r22
 1187 02b2 7095      		com r23
 1188 02b4 8095      		com r24
 1189 02b6 9095      		com r25
 1190               	.L79:
 1191               	.LVL115:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1192               		.loc 1 472 21 is_stmt 1 discriminator 4 view .LVU301
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1193               		.loc 1 472 47 is_stmt 0 discriminator 4 view .LVU302
 1194 02b8 C695      		lsr r28
 1195 02ba C695      		lsr r28
 1196               	.LVL116:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1197               		.loc 1 472 47 discriminator 4 view .LVU303
 1198 02bc C370      		andi r28,lo8(3)
 1199 02be 602B      		or r22,r16
 1200               	.LVL117:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1201               		.loc 1 472 47 discriminator 4 view .LVU304
 1202 02c0 712B      		or r23,r17
 1203 02c2 822B      		or r24,r18
 1204 02c4 932B      		or r25,r19
 1205 02c6 C230      		cpi r28,lo8(2)
 1206 02c8 01F0      		breq .L80
 1207 02ca 00F4      		brsh .L81
 1208 02cc C130      		cpi r28,lo8(1)
 1209 02ce 01F0      		breq .L82
 474:tmk_core/common/action.c ****                             break;
 1210               		.loc 1 474 29 is_stmt 1 view .LVU305
 1211 02d0 0E94 0000 		call layer_and
 1212               	.LVL118:
 475:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1213               		.loc 1 475 29 view .LVU306
 1214 02d4 00C0      		rjmp .L38
 1215               	.L82:
 477:tmk_core/common/action.c ****                             break;
 1216               		.loc 1 477 29 view .LVU307
 1217 02d6 0E94 0000 		call layer_or
 1218               	.LVL119:
 478:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1219               		.loc 1 478 29 view .LVU308
 1220 02da 00C0      		rjmp .L38
 1221               	.L80:
 480:tmk_core/common/action.c ****                             break;
 1222               		.loc 1 480 29 view .LVU309
 1223 02dc 0E94 0000 		call layer_xor
 1224               	.LVL120:
 481:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1225               		.loc 1 481 29 view .LVU310
 1226 02e0 00C0      		rjmp .L38
 1227               	.L81:
 483:tmk_core/common/action.c ****                             break;
 1228               		.loc 1 483 29 view .LVU311
 1229 02e2 0E94 0000 		call layer_state_set
 1230               	.LVL121:
 484:tmk_core/common/action.c ****                     }
 1231               		.loc 1 484 29 view .LVU312
 1232 02e6 00C0      		rjmp .L38
 1233               	.LVL122:
 1234               	.L41:
 484:tmk_core/common/action.c ****                     }
 1235               		.loc 1 484 29 is_stmt 0 view .LVU313
 1236               	.LBE31:
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1237               		.loc 1 490 13 is_stmt 1 view .LVU314
 1238 02e8 CF70      		andi r28,lo8(15)
 1239               	.LVL123:
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1240               		.loc 1 490 16 is_stmt 0 view .LVU315
 1241 02ea 1123      		tst r17
 1242 02ec 01F0      		breq .L83
 491:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1243               		.loc 1 491 17 is_stmt 1 view .LVU316
 1244 02ee 8C2F      		mov r24,r28
 1245 02f0 0E94 0000 		call layer_on
 1246               	.LVL124:
 492:tmk_core/common/action.c ****             } else {
 1247               		.loc 1 492 17 view .LVU317
 1248 02f4 8D2F      		mov r24,r29
 1249 02f6 00C0      		rjmp .L139
 1250               	.L83:
 494:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1251               		.loc 1 494 17 view .LVU318
 1252 02f8 8D2F      		mov r24,r29
 1253 02fa 0E94 0000 		call unregister_mods
 1254               	.LVL125:
 495:tmk_core/common/action.c ****             }
 1255               		.loc 1 495 17 view .LVU319
 1256 02fe 8C2F      		mov r24,r28
 1257               	.LVL126:
 1258               	.L137:
 582:tmk_core/common/action.c ****                         }
 1259               		.loc 1 582 29 is_stmt 0 view .LVU320
 1260 0300 0E94 0000 		call layer_off
 1261               	.LVL127:
 1262 0304 00C0      		rjmp .L38
 1263               	.L39:
 501:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1264               		.loc 1 501 13 is_stmt 1 view .LVU321
 1265 0306 D23F      		cpi r29,lo8(-14)
 1266 0308 01F0      		breq .L84
 1267 030a 00F4      		brsh .L85
 1268 030c D03F      		cpi r29,lo8(-16)
 1269 030e 01F0      		breq .L86
 1270 0310 D13F      		cpi r29,lo8(-15)
 1271 0312 01F0      		breq .L87
 1272               	.L88:
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1273               		.loc 1 563 21 view .LVU322
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1274               		.loc 1 563 24 is_stmt 0 view .LVU323
 1275 0314 1123      		tst r17
 1276 0316 01F4      		brne .+2
 1277 0318 00C0      		rjmp .L97
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1278               		.loc 1 564 25 is_stmt 1 view .LVU324
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1279               		.loc 1 564 28 is_stmt 0 view .LVU325
 1280 031a 0111      		cpse r16,__zero_reg__
 1281 031c 00C0      		rjmp .L140
 568:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1282               		.loc 1 568 76 is_stmt 1 view .LVU326
 569:tmk_core/common/action.c ****                         }
 1283               		.loc 1 569 29 view .LVU327
 1284 031e 8C2F      		mov r24,r28
 1285 0320 8F71      		andi r24,lo8(31)
 1286 0322 00C0      		rjmp .L136
 1287               	.L85:
 1288 0324 D33F      		cpi r29,lo8(-13)
 1289 0326 01F0      		breq .L89
 1290 0328 D43F      		cpi r29,lo8(-12)
 1291 032a 01F4      		brne .L88
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1292               		.loc 1 549 21 view .LVU328
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1293               		.loc 1 549 24 is_stmt 0 view .LVU329
 1294 032c 1123      		tst r17
 1295 032e 01F0      		breq .L96
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1296               		.loc 1 550 25 is_stmt 1 view .LVU330
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1297               		.loc 1 550 50 is_stmt 0 view .LVU331
 1298 0330 CF71      		andi r28,lo8(31)
 1299               	.LVL128:
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1300               		.loc 1 550 25 view .LVU332
 1301 0332 8C2F      		mov r24,r28
 1302 0334 0E94 0000 		call layer_on
 1303               	.LVL129:
 551:tmk_core/common/action.c ****                     } else {
 1304               		.loc 1 551 25 is_stmt 1 view .LVU333
 1305 0338 63E0      		ldi r22,lo8(3)
 1306 033a 8C2F      		mov r24,r28
 1307 033c 0E94 0000 		call set_oneshot_layer
 1308               	.LVL130:
 1309 0340 00C0      		rjmp .L38
 1310               	.LVL131:
 1311               	.L86:
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1312               		.loc 1 504 21 view .LVU334
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1313               		.loc 1 504 24 is_stmt 0 view .LVU335
 1314 0342 1123      		tst r17
 1315 0344 01F0      		breq .L91
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1316               		.loc 1 505 25 is_stmt 1 view .LVU336
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1317               		.loc 1 505 28 is_stmt 0 view .LVU337
 1318 0346 0530      		cpi r16,lo8(5)
 1319 0348 00F0      		brlo .+2
 1320 034a 00C0      		rjmp .L38
 1321               	.L92:
 506:tmk_core/common/action.c ****                         }
 1322               		.loc 1 506 29 is_stmt 1 view .LVU338
 1323 034c 8C2F      		mov r24,r28
 1324 034e 8F71      		andi r24,lo8(31)
 1325 0350 0E94 0000 		call layer_invert
 1326               	.LVL132:
 1327 0354 00C0      		rjmp .L38
 1328               	.L91:
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1329               		.loc 1 509 25 view .LVU339
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1330               		.loc 1 509 28 is_stmt 0 view .LVU340
 1331 0356 0630      		cpi r16,lo8(6)
 1332 0358 00F0      		brlo .+2
 1333 035a 00C0      		rjmp .L38
 1334 035c 00C0      		rjmp .L92
 1335               	.L87:
 515:tmk_core/common/action.c ****                     break;
 1336               		.loc 1 515 21 is_stmt 1 view .LVU341
 1337 035e 8C2F      		mov r24,r28
 1338 0360 8F71      		andi r24,lo8(31)
 515:tmk_core/common/action.c ****                     break;
 1339               		.loc 1 515 68 is_stmt 0 view .LVU342
 1340 0362 1123      		tst r17
 1341 0364 01F0      		breq .L137
 1342               	.L136:
 569:tmk_core/common/action.c ****                         }
 1343               		.loc 1 569 29 view .LVU343
 1344 0366 0E94 0000 		call layer_on
 1345               	.LVL133:
 1346 036a 00C0      		rjmp .L38
 1347               	.L84:
 518:tmk_core/common/action.c ****                     break;
 1348               		.loc 1 518 21 is_stmt 1 view .LVU344
 1349 036c 8C2F      		mov r24,r28
 1350 036e 8F71      		andi r24,lo8(31)
 518:tmk_core/common/action.c ****                     break;
 1351               		.loc 1 518 69 is_stmt 0 view .LVU345
 1352 0370 1123      		tst r17
 1353 0372 01F0      		breq .L136
 1354 0374 00C0      		rjmp .L137
 1355               	.L89:
 521:tmk_core/common/action.c ****                     break;
 1356               		.loc 1 521 21 is_stmt 1 view .LVU346
 521:tmk_core/common/action.c ****                     break;
 1357               		.loc 1 521 70 is_stmt 0 view .LVU347
 1358 0376 1123      		tst r17
 1359 0378 01F0      		breq .L95
 521:tmk_core/common/action.c ****                     break;
 1360               		.loc 1 521 37 discriminator 1 view .LVU348
 1361 037a 8C2F      		mov r24,r28
 1362 037c 8F71      		andi r24,lo8(31)
 1363 037e 0E94 0000 		call layer_move
 1364               	.LVL134:
 1365 0382 00C0      		rjmp .L38
 1366               	.L95:
 521:tmk_core/common/action.c ****                     break;
 1367               		.loc 1 521 72 discriminator 2 view .LVU349
 1368 0384 0E94 0000 		call layer_clear
 1369               	.LVL135:
 1370 0388 00C0      		rjmp .L38
 1371               	.L96:
 553:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1372               		.loc 1 553 25 is_stmt 1 view .LVU350
 1373 038a 81E0      		ldi r24,lo8(1)
 1374 038c 0E94 0000 		call clear_oneshot_layer_state
 1375               	.LVL136:
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1376               		.loc 1 554 25 view .LVU351
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1377               		.loc 1 554 28 is_stmt 0 view .LVU352
 1378 0390 0230      		cpi r16,lo8(2)
 1379 0392 00F4      		brsh .+2
 1380 0394 00C0      		rjmp .L38
 555:tmk_core/common/action.c ****                         }
 1381               		.loc 1 555 29 is_stmt 1 view .LVU353
 1382 0396 82E0      		ldi r24,lo8(2)
 1383 0398 0E94 0000 		call clear_oneshot_layer_state
 1384               	.LVL137:
 1385 039c 00C0      		rjmp .L38
 1386               	.L97:
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1387               		.loc 1 572 25 view .LVU354
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1388               		.loc 1 572 28 is_stmt 0 view .LVU355
 1389 039e 0023      		tst r16
 1390 03a0 01F0      		breq .L99
 573:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1391               		.loc 1 573 77 is_stmt 1 view .LVU356
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1392               		.loc 1 574 29 view .LVU357
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1393               		.loc 1 574 32 is_stmt 0 view .LVU358
 1394 03a2 D933      		cpi r29,lo8(57)
 1395 03a4 01F0      		breq .+2
 1396 03a6 00C0      		rjmp .L101
 575:tmk_core/common/action.c ****                             } else {
 1397               		.loc 1 575 33 is_stmt 1 view .LVU359
 1398               	.LVL138:
 1399               	.LBB32:
 1400               	.LBI27:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 1401               		.loc 2 166 1 view .LVU360
 1402               	.LBB29:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1403               		.loc 2 168 2 view .LVU361
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1404               		.loc 2 172 2 view .LVU362
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1405               		.loc 2 173 2 view .LVU363
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 1406               		.loc 2 174 2 view .LVU364
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 1407               		.loc 2 184 3 view .LVU365
 1408               		.loc 2 187 2 view .LVU366
 1409 03a8 EFEF      		ldi r30,lo8(255999)
 1410 03aa F7EE      		ldi r31,hi8(255999)
 1411 03ac 23E0      		ldi r18,hlo8(255999)
 1412 03ae E150      	1:	subi r30,1
 1413 03b0 F040      		sbci r31,0
 1414 03b2 2040      		sbci r18,0
 1415 03b4 01F4      		brne 1b
 1416 03b6 00C0      		rjmp .L142
 1417               	.LVL139:
 1418               	.L99:
 1419               		.loc 2 187 2 is_stmt 0 view .LVU367
 1420               	.LBE29:
 1421               	.LBE32:
 581:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1422               		.loc 1 581 79 is_stmt 1 view .LVU368
 582:tmk_core/common/action.c ****                         }
 1423               		.loc 1 582 29 view .LVU369
 1424 03b8 8C2F      		mov r24,r28
 1425 03ba 8F71      		andi r24,lo8(31)
 1426 03bc 00C0      		rjmp .L137
 1427               	.LVL140:
 1428               	.L34:
 1429               	/* epilogue start */
 737:tmk_core/common/action.c **** 
 1430               		.loc 1 737 1 is_stmt 0 view .LVU370
 1431 03be DF91      		pop r29
 1432               	.LVL141:
 737:tmk_core/common/action.c **** 
 1433               		.loc 1 737 1 view .LVU371
 1434 03c0 CF91      		pop r28
 737:tmk_core/common/action.c **** 
 1435               		.loc 1 737 1 view .LVU372
 1436 03c2 1F91      		pop r17
 1437 03c4 0F91      		pop r16
 1438 03c6 FF90      		pop r15
 1439 03c8 EF90      		pop r14
 1440               	.LVL142:
 737:tmk_core/common/action.c **** 
 1441               		.loc 1 737 1 view .LVU373
 1442 03ca DF90      		pop r13
 1443               	.LVL143:
 737:tmk_core/common/action.c **** 
 1444               		.loc 1 737 1 view .LVU374
 1445 03cc CF90      		pop r12
 1446 03ce BF90      		pop r11
 1447 03d0 0895      		ret
 1448               		.cfi_endproc
 1449               	.LFE22:
 1451               		.section	.text.process_record_handler,"ax",@progbits
 1452               	.global	process_record_handler
 1454               	process_record_handler:
 1455               	.LVL144:
 1456               	.LFB21:
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1457               		.loc 1 208 50 is_stmt 1 view -0
 1458               		.cfi_startproc
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1459               		.loc 1 208 50 is_stmt 0 view .LVU376
 1460 0000 0F93      		push r16
 1461               	.LCFI15:
 1462               		.cfi_def_cfa_offset 3
 1463               		.cfi_offset 16, -2
 1464 0002 1F93      		push r17
 1465               	.LCFI16:
 1466               		.cfi_def_cfa_offset 4
 1467               		.cfi_offset 17, -3
 1468 0004 CF93      		push r28
 1469               	.LCFI17:
 1470               		.cfi_def_cfa_offset 5
 1471               		.cfi_offset 28, -4
 1472 0006 DF93      		push r29
 1473               	.LCFI18:
 1474               		.cfi_def_cfa_offset 6
 1475               		.cfi_offset 29, -5
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 4 */
 1479               	.L__stack_usage = 4
 1480 0008 EC01      		movw r28,r24
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1481               		.loc 1 209 5 is_stmt 1 view .LVU377
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1482               		.loc 1 209 23 is_stmt 0 view .LVU378
 1483 000a 6881      		ld r22,Y
 1484 000c 7981      		ldd r23,Y+1
 1485 000e 8A81      		ldd r24,Y+2
 1486               	.LVL145:
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1487               		.loc 1 209 23 view .LVU379
 1488 0010 0E94 0000 		call store_or_get_action
 1489               	.LVL146:
 1490 0014 8C01      		movw r16,r24
 1491               	.LVL147:
 210:tmk_core/common/action.c ****     debug_action(action);
 1492               		.loc 1 210 23 is_stmt 1 view .LVU380
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1493               		.loc 1 211 5 view .LVU381
 213:tmk_core/common/action.c ****     layer_debug();
 1494               		.loc 1 213 29 view .LVU382
 214:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1495               		.loc 1 214 5 view .LVU383
 1496 0016 0E94 0000 		call layer_debug
 1497               	.LVL148:
 215:tmk_core/common/action.c ****     default_layer_debug();
 1498               		.loc 1 215 37 view .LVU384
 216:tmk_core/common/action.c **** #endif
 1499               		.loc 1 216 5 view .LVU385
 1500 001a 0E94 0000 		call default_layer_debug
 1501               	.LVL149:
 218:tmk_core/common/action.c **** 
 1502               		.loc 1 218 15 view .LVU386
 220:tmk_core/common/action.c **** }
 1503               		.loc 1 220 5 view .LVU387
 220:tmk_core/common/action.c **** }
 1504               		.loc 1 220 5 is_stmt 0 view .LVU388
 1505 001e B801      		movw r22,r16
 1506 0020 CE01      		movw r24,r28
 1507               	/* epilogue start */
 221:tmk_core/common/action.c **** 
 1508               		.loc 1 221 1 view .LVU389
 1509 0022 DF91      		pop r29
 1510 0024 CF91      		pop r28
 1511               	.LVL150:
 221:tmk_core/common/action.c **** 
 1512               		.loc 1 221 1 view .LVU390
 1513 0026 1F91      		pop r17
 1514 0028 0F91      		pop r16
 1515               	.LVL151:
 220:tmk_core/common/action.c **** }
 1516               		.loc 1 220 5 view .LVU391
 1517 002a 0C94 0000 		jmp process_action
 1518               	.LVL152:
 220:tmk_core/common/action.c **** }
 1519               		.loc 1 220 5 view .LVU392
 1520               		.cfi_endproc
 1521               	.LFE21:
 1523               		.section	.text.process_record,"ax",@progbits
 1524               	.global	process_record
 1526               	process_record:
 1527               	.LVL153:
 1528               	.LFB20:
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1529               		.loc 1 190 42 is_stmt 1 view -0
 1530               		.cfi_startproc
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1531               		.loc 1 190 42 is_stmt 0 view .LVU394
 1532 0000 CF93      		push r28
 1533               	.LCFI19:
 1534               		.cfi_def_cfa_offset 3
 1535               		.cfi_offset 28, -2
 1536 0002 DF93      		push r29
 1537               	.LCFI20:
 1538               		.cfi_def_cfa_offset 4
 1539               		.cfi_offset 29, -3
 1540               	/* prologue: function */
 1541               	/* frame size = 0 */
 1542               	/* stack size = 2 */
 1543               	.L__stack_usage = 2
 1544 0004 EC01      		movw r28,r24
 191:tmk_core/common/action.c ****         return;
 1545               		.loc 1 191 5 is_stmt 1 view .LVU395
 1546               	.LBB35:
 1547               	.LBI35:
 1548               		.file 3 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1549               		.loc 3 48 20 view .LVU396
 1550               	.LBB36:
 1551               		.loc 3 48 51 view .LVU397
 1552               		.loc 3 48 74 is_stmt 0 view .LVU398
 1553 0006 8B81      		ldd r24,Y+3
 1554 0008 9C81      		ldd r25,Y+4
 1555               	.LVL154:
 1556               		.loc 3 48 74 view .LVU399
 1557 000a 892B      		or r24,r25
 1558 000c 01F0      		breq .L144
 1559 000e 8881      		ld r24,Y
 1560 0010 9981      		ldd r25,Y+1
 1561 0012 8923      		and r24,r25
 1562 0014 8F3F      		cpi r24,lo8(-1)
 1563 0016 01F4      		brne .L160
 1564               	.L144:
 1565               	/* epilogue start */
 1566               	.LBE36:
 1567               	.LBE35:
 206:tmk_core/common/action.c **** 
 1568               		.loc 1 206 1 view .LVU400
 1569 0018 DF91      		pop r29
 1570 001a CF91      		pop r28
 1571               	.LVL155:
 206:tmk_core/common/action.c **** 
 1572               		.loc 1 206 1 view .LVU401
 1573 001c 0895      		ret
 1574               	.LVL156:
 1575               	.L149:
 204:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1576               		.loc 1 204 5 is_stmt 1 view .LVU402
 1577 001e CE01      		movw r24,r28
 1578 0020 0E94 0000 		call process_record_handler
 1579               	.LVL157:
 205:tmk_core/common/action.c **** }
 1580               		.loc 1 205 5 view .LVU403
 1581 0024 CE01      		movw r24,r28
 1582               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 1583               		.loc 1 206 1 is_stmt 0 view .LVU404
 1584 0026 DF91      		pop r29
 1585 0028 CF91      		pop r28
 1586               	.LVL158:
 205:tmk_core/common/action.c **** }
 1587               		.loc 1 205 5 view .LVU405
 1588 002a 0C94 0000 		jmp post_process_record_quantum
 1589               	.LVL159:
 1590               	.L160:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1591               		.loc 1 195 5 is_stmt 1 view .LVU406
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1592               		.loc 1 195 10 is_stmt 0 view .LVU407
 1593 002e CE01      		movw r24,r28
 1594 0030 0E94 0000 		call process_record_quantum
 1595               	.LVL160:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1596               		.loc 1 195 8 view .LVU408
 1597 0034 8111      		cpse r24,__zero_reg__
 1598 0036 00C0      		rjmp .L149
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1599               		.loc 1 197 9 is_stmt 1 view .LVU409
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1600               		.loc 1 197 13 is_stmt 0 view .LVU410
 1601 0038 0E94 0000 		call is_oneshot_layer_active
 1602               	.LVL161:
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1603               		.loc 1 197 12 view .LVU411
 1604 003c 8823      		tst r24
 1605 003e 01F0      		breq .L144
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1606               		.loc 1 197 39 discriminator 1 view .LVU412
 1607 0040 8A81      		ldd r24,Y+2
 1608 0042 8823      		tst r24
 1609 0044 01F0      		breq .L144
 198:tmk_core/common/action.c ****         }
 1610               		.loc 1 198 13 is_stmt 1 view .LVU413
 1611 0046 82E0      		ldi r24,lo8(2)
 1612               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 1613               		.loc 1 206 1 is_stmt 0 view .LVU414
 1614 0048 DF91      		pop r29
 1615 004a CF91      		pop r28
 1616               	.LVL162:
 198:tmk_core/common/action.c ****         }
 1617               		.loc 1 198 13 view .LVU415
 1618 004c 0C94 0000 		jmp clear_oneshot_layer_state
 1619               	.LVL163:
 1620               		.cfi_endproc
 1621               	.LFE20:
 1623               		.section	.text.process_record_nocache,"ax",@progbits
 1624               	.global	process_record_nocache
 1626               	process_record_nocache:
 1627               	.LVL164:
 1628               	.LFB16:
 148:tmk_core/common/action.c ****     disable_action_cache = true;
 1629               		.loc 1 148 50 is_stmt 1 view -0
 1630               		.cfi_startproc
 1631               	/* prologue: function */
 1632               	/* frame size = 0 */
 1633               	/* stack size = 0 */
 1634               	.L__stack_usage = 0
 149:tmk_core/common/action.c ****     process_record(record);
 1635               		.loc 1 149 5 view .LVU417
 149:tmk_core/common/action.c ****     process_record(record);
 1636               		.loc 1 149 26 is_stmt 0 view .LVU418
 1637 0000 21E0      		ldi r18,lo8(1)
 1638 0002 2093 0000 		sts disable_action_cache,r18
 150:tmk_core/common/action.c ****     disable_action_cache = false;
 1639               		.loc 1 150 5 is_stmt 1 view .LVU419
 1640 0006 0E94 0000 		call process_record
 1641               	.LVL165:
 151:tmk_core/common/action.c **** }
 1642               		.loc 1 151 5 view .LVU420
 151:tmk_core/common/action.c **** }
 1643               		.loc 1 151 26 is_stmt 0 view .LVU421
 1644 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1645               	/* epilogue start */
 152:tmk_core/common/action.c **** #else
 1646               		.loc 1 152 1 view .LVU422
 1647 000e 0895      		ret
 1648               		.cfi_endproc
 1649               	.LFE16:
 1651               		.section	.text.register_weak_mods,"ax",@progbits
 1652               	.global	register_weak_mods
 1654               	register_weak_mods:
 1655               	.LVL166:
 1656               	.LFB28:
 934:tmk_core/common/action.c **** 
 935:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:tmk_core/common/action.c ****  *
 937:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 938:tmk_core/common/action.c ****  */
 939:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1657               		.loc 1 939 39 is_stmt 1 view -0
 1658               		.cfi_startproc
 1659               	/* prologue: function */
 1660               	/* frame size = 0 */
 1661               	/* stack size = 0 */
 1662               	.L__stack_usage = 0
 940:tmk_core/common/action.c ****     if (mods) {
 1663               		.loc 1 940 5 view .LVU424
 1664               		.loc 1 940 8 is_stmt 0 view .LVU425
 1665 0000 8823      		tst r24
 1666 0002 01F0      		breq .L163
 941:tmk_core/common/action.c ****         add_weak_mods(mods);
 1667               		.loc 1 941 9 is_stmt 1 view .LVU426
 1668 0004 0E94 0000 		call add_weak_mods
 1669               	.LVL167:
 942:tmk_core/common/action.c ****         send_keyboard_report();
 1670               		.loc 1 942 9 view .LVU427
 1671 0008 0C94 0000 		jmp send_keyboard_report
 1672               	.LVL168:
 1673               	.L163:
 1674               	/* epilogue start */
 943:tmk_core/common/action.c ****     }
 944:tmk_core/common/action.c **** }
 1675               		.loc 1 944 1 is_stmt 0 view .LVU428
 1676 000c 0895      		ret
 1677               		.cfi_endproc
 1678               	.LFE28:
 1680               		.section	.text.unregister_weak_mods,"ax",@progbits
 1681               	.global	unregister_weak_mods
 1683               	unregister_weak_mods:
 1684               	.LVL169:
 1685               	.LFB29:
 945:tmk_core/common/action.c **** 
 946:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:tmk_core/common/action.c ****  *
 948:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:tmk_core/common/action.c ****  */
 950:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1686               		.loc 1 950 41 is_stmt 1 view -0
 1687               		.cfi_startproc
 1688               	/* prologue: function */
 1689               	/* frame size = 0 */
 1690               	/* stack size = 0 */
 1691               	.L__stack_usage = 0
 951:tmk_core/common/action.c ****     if (mods) {
 1692               		.loc 1 951 5 view .LVU430
 1693               		.loc 1 951 8 is_stmt 0 view .LVU431
 1694 0000 8823      		tst r24
 1695 0002 01F0      		breq .L165
 952:tmk_core/common/action.c ****         del_weak_mods(mods);
 1696               		.loc 1 952 9 is_stmt 1 view .LVU432
 1697 0004 0E94 0000 		call del_weak_mods
 1698               	.LVL170:
 953:tmk_core/common/action.c ****         send_keyboard_report();
 1699               		.loc 1 953 9 view .LVU433
 1700 0008 0C94 0000 		jmp send_keyboard_report
 1701               	.LVL171:
 1702               	.L165:
 1703               	/* epilogue start */
 954:tmk_core/common/action.c ****     }
 955:tmk_core/common/action.c **** }
 1704               		.loc 1 955 1 is_stmt 0 view .LVU434
 1705 000c 0895      		ret
 1706               		.cfi_endproc
 1707               	.LFE29:
 1709               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1710               	.global	clear_keyboard_but_mods_and_keys
 1712               	clear_keyboard_but_mods_and_keys:
 1713               	.LFB32:
 956:tmk_core/common/action.c **** 
 957:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:tmk_core/common/action.c ****  *
 959:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 960:tmk_core/common/action.c ****  */
 961:tmk_core/common/action.c **** void clear_keyboard(void) {
 962:tmk_core/common/action.c ****     clear_mods();
 963:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 964:tmk_core/common/action.c **** }
 965:tmk_core/common/action.c **** 
 966:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:tmk_core/common/action.c ****  *
 968:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 969:tmk_core/common/action.c ****  */
 970:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 971:tmk_core/common/action.c ****     clear_keys();
 972:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 973:tmk_core/common/action.c **** }
 974:tmk_core/common/action.c **** 
 975:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:tmk_core/common/action.c ****  *
 977:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 978:tmk_core/common/action.c ****  */
 979:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1714               		.loc 1 979 41 is_stmt 1 view -0
 1715               		.cfi_startproc
 1716               	/* prologue: function */
 1717               	/* frame size = 0 */
 1718               	/* stack size = 0 */
 1719               	.L__stack_usage = 0
 980:tmk_core/common/action.c ****     clear_weak_mods();
 1720               		.loc 1 980 5 view .LVU436
 1721 0000 0E94 0000 		call clear_weak_mods
 1722               	.LVL172:
 981:tmk_core/common/action.c ****     clear_macro_mods();
 1723               		.loc 1 981 5 view .LVU437
 1724 0004 0E94 0000 		call clear_macro_mods
 1725               	.LVL173:
 982:tmk_core/common/action.c ****     send_keyboard_report();
 1726               		.loc 1 982 5 view .LVU438
 1727 0008 0E94 0000 		call send_keyboard_report
 1728               	.LVL174:
 983:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 984:tmk_core/common/action.c ****     mousekey_clear();
 1729               		.loc 1 984 5 view .LVU439
 1730 000c 0E94 0000 		call mousekey_clear
 1731               	.LVL175:
 985:tmk_core/common/action.c ****     mousekey_send();
 1732               		.loc 1 985 5 view .LVU440
 1733 0010 0C94 0000 		jmp mousekey_send
 1734               	.LVL176:
 1735               		.cfi_endproc
 1736               	.LFE32:
 1738               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1739               	.global	clear_keyboard_but_mods
 1741               	clear_keyboard_but_mods:
 1742               	.LFB31:
 970:tmk_core/common/action.c ****     clear_keys();
 1743               		.loc 1 970 36 view -0
 1744               		.cfi_startproc
 1745               	/* prologue: function */
 1746               	/* frame size = 0 */
 1747               	/* stack size = 0 */
 1748               	.L__stack_usage = 0
 971:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1749               		.loc 1 971 5 view .LVU442
 1750 0000 0E94 0000 		call clear_keys
 1751               	.LVL177:
 972:tmk_core/common/action.c **** }
 1752               		.loc 1 972 5 view .LVU443
 1753 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1754               	.LVL178:
 1755               		.cfi_endproc
 1756               	.LFE31:
 1758               		.section	.text.clear_keyboard,"ax",@progbits
 1759               	.global	clear_keyboard
 1761               	clear_keyboard:
 1762               	.LFB30:
 961:tmk_core/common/action.c ****     clear_mods();
 1763               		.loc 1 961 27 view -0
 1764               		.cfi_startproc
 1765               	/* prologue: function */
 1766               	/* frame size = 0 */
 1767               	/* stack size = 0 */
 1768               	.L__stack_usage = 0
 962:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1769               		.loc 1 962 5 view .LVU445
 1770 0000 0E94 0000 		call clear_mods
 1771               	.LVL179:
 963:tmk_core/common/action.c **** }
 1772               		.loc 1 963 5 view .LVU446
 1773 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1774               	.LVL180:
 1775               		.cfi_endproc
 1776               	.LFE30:
 1778               		.section	.text.is_tap_action,"ax",@progbits
 1779               	.global	is_tap_action
 1781               	is_tap_action:
 1782               	.LVL181:
 1783               	.LFB34:
 986:tmk_core/common/action.c **** #endif
 987:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 988:tmk_core/common/action.c ****     host_system_send(0);
 989:tmk_core/common/action.c ****     host_consumer_send(0);
 990:tmk_core/common/action.c **** #endif
 991:tmk_core/common/action.c **** }
 992:tmk_core/common/action.c **** 
 993:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:tmk_core/common/action.c ****  *
 995:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 996:tmk_core/common/action.c ****  */
 997:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 998:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 999:tmk_core/common/action.c ****     return is_tap_action(action);
1000:tmk_core/common/action.c **** }
1001:tmk_core/common/action.c **** 
1002:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:tmk_core/common/action.c ****  *
1004:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1005:tmk_core/common/action.c ****  */
1006:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1784               		.loc 1 1006 37 view -0
 1785               		.cfi_startproc
 1786               	/* prologue: function */
 1787               	/* frame size = 0 */
 1788               	/* stack size = 0 */
 1789               	.L__stack_usage = 0
1007:tmk_core/common/action.c ****     switch (action.kind.id) {
 1790               		.loc 1 1007 5 view .LVU448
 1791               		.loc 1 1007 24 is_stmt 0 view .LVU449
 1792 0000 E92F      		mov r30,r25
 1793 0002 E295      		swap r30
 1794 0004 EF70      		andi r30,lo8(15)
 1795               		.loc 1 1007 5 view .LVU450
 1796 0006 E250      		subi r30,lo8(-(-2))
 1797 0008 EE30      		cpi r30,lo8(14)
 1798 000a 00F4      		brsh .L179
 1799 000c F0E0      		ldi r31,0
 1800 000e E050      		subi r30,lo8(-(gs(.L173)))
 1801 0010 F040      		sbci r31,hi8(-(gs(.L173)))
 1802 0012 0C94 0000 		jmp __tablejump2__
 1803               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 1804               		.p2align	1
 1805               	.L173:
 1806 0000 0000      		.word gs(.L174)
 1807 0002 0000      		.word gs(.L174)
 1808 0004 0000      		.word gs(.L179)
 1809 0006 0000      		.word gs(.L179)
 1810 0008 0000      		.word gs(.L175)
 1811 000a 0000      		.word gs(.L179)
 1812 000c 0000      		.word gs(.L179)
 1813 000e 0000      		.word gs(.L179)
 1814 0010 0000      		.word gs(.L174)
 1815 0012 0000      		.word gs(.L174)
 1816 0014 0000      		.word gs(.L172)
 1817 0016 0000      		.word gs(.L179)
 1818 0018 0000      		.word gs(.L179)
 1819 001a 0000      		.word gs(.L172)
 1820               		.section	.text.is_tap_action
 1821               	.L174:
1008:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1009:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1010:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1011:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1012:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1822               		.loc 1 1012 13 is_stmt 1 view .LVU451
 1823 0016 803F      		cpi r24,lo8(-16)
 1824 0018 01F0      		breq .L182
 1825 001a 00F4      		brsh .L176
 1826 001c 883E      		cpi r24,lo8(-24)
 1827 001e 00F4      		brsh .L179
 1828               	.L182:
1013:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1014:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1015:tmk_core/common/action.c ****                 case OP_ONESHOT:
1016:tmk_core/common/action.c ****                     return true;
 1829               		.loc 1 1016 28 is_stmt 0 view .LVU452
 1830 0020 81E0      		ldi r24,lo8(1)
 1831               	.LVL182:
 1832               	/* epilogue start */
1017:tmk_core/common/action.c ****             }
1018:tmk_core/common/action.c ****             return false;
1019:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1020:tmk_core/common/action.c ****             switch (action.swap.code) {
1021:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1022:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1023:tmk_core/common/action.c ****                     return true;
1024:tmk_core/common/action.c ****             }
1025:tmk_core/common/action.c ****             return false;
1026:tmk_core/common/action.c ****         case ACT_MACRO:
1027:tmk_core/common/action.c ****         case ACT_FUNCTION:
1028:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1029:tmk_core/common/action.c ****                 return true;
1030:tmk_core/common/action.c ****             }
1031:tmk_core/common/action.c ****             return false;
1032:tmk_core/common/action.c ****     }
1033:tmk_core/common/action.c ****     return false;
1034:tmk_core/common/action.c **** }
 1833               		.loc 1 1034 1 view .LVU453
 1834 0022 0895      		ret
 1835               	.LVL183:
 1836               	.L176:
 1837               		.loc 1 1034 1 view .LVU454
 1838 0024 843F      		cpi r24,lo8(-12)
 1839 0026 01F0      		breq .L182
 1840               	.L179:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1841               		.loc 1 1018 20 view .LVU455
 1842 0028 80E0      		ldi r24,0
 1843               	.LVL184:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1844               		.loc 1 1018 20 view .LVU456
 1845 002a 0895      		ret
 1846               	.LVL185:
 1847               	.L175:
1020:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1848               		.loc 1 1020 13 is_stmt 1 view .LVU457
 1849 002c 883E      		cpi r24,lo8(-24)
 1850 002e 00F0      		brlo .L182
 1851 0030 813F      		cpi r24,lo8(-15)
 1852 0032 01F4      		brne .L179
 1853 0034 00C0      		rjmp .L182
 1854               	.L172:
1028:tmk_core/common/action.c ****                 return true;
 1855               		.loc 1 1028 13 view .LVU458
1028:tmk_core/common/action.c ****                 return true;
 1856               		.loc 1 1028 16 is_stmt 0 view .LVU459
 1857 0036 93FB      		bst r25,3
 1858 0038 8827      		clr r24
 1859 003a 80F9      		bld r24,0
 1860               	.LVL186:
1028:tmk_core/common/action.c ****                 return true;
 1861               		.loc 1 1028 16 view .LVU460
 1862 003c 0895      		ret
 1863               		.cfi_endproc
 1864               	.LFE34:
 1866               		.section	.text.is_tap_key,"ax",@progbits
 1867               	.global	is_tap_key
 1869               	is_tap_key:
 1870               	.LVL187:
 1871               	.LFB33:
 997:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1872               		.loc 1 997 31 is_stmt 1 view -0
 1873               		.cfi_startproc
 1874               	/* prologue: function */
 1875               	/* frame size = 0 */
 1876               	/* stack size = 0 */
 1877               	.L__stack_usage = 0
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 1878               		.loc 1 998 5 view .LVU462
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 1879               		.loc 1 998 23 is_stmt 0 view .LVU463
 1880 0000 0E94 0000 		call layer_switch_get_action
 1881               	.LVL188:
 999:tmk_core/common/action.c **** }
 1882               		.loc 1 999 5 is_stmt 1 view .LVU464
 999:tmk_core/common/action.c **** }
 1883               		.loc 1 999 12 is_stmt 0 view .LVU465
 1884 0004 0C94 0000 		jmp is_tap_action
 1885               	.LVL189:
 1886               		.cfi_endproc
 1887               	.LFE33:
 1889               		.section	.text.debug_event,"ax",@progbits
 1890               	.global	debug_event
 1892               	debug_event:
 1893               	.LFB35:
1035:tmk_core/common/action.c **** 
1036:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1037:tmk_core/common/action.c ****  *
1038:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1039:tmk_core/common/action.c ****  */
1040:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 1894               		.loc 1 1040 36 is_stmt 1 view -0
 1895               		.cfi_startproc
 1896 0000 CF93      		push r28
 1897               	.LCFI21:
 1898               		.cfi_def_cfa_offset 3
 1899               		.cfi_offset 28, -2
 1900 0002 DF93      		push r29
 1901               	.LCFI22:
 1902               		.cfi_def_cfa_offset 4
 1903               		.cfi_offset 29, -3
 1904 0004 00D0      		rcall .
 1905 0006 00D0      		rcall .
 1906 0008 0F92      		push __tmp_reg__
 1907               	.LCFI23:
 1908               		.cfi_def_cfa_offset 9
 1909 000a CDB7      		in r28,__SP_L__
 1910 000c DEB7      		in r29,__SP_H__
 1911               	.LCFI24:
 1912               		.cfi_def_cfa_register 28
 1913               	/* prologue: function */
 1914               	/* frame size = 5 */
 1915               	/* stack size = 7 */
 1916               	.L__stack_usage = 7
 1917               		.loc 1 1040 138 view .LVU467
 1918               	/* epilogue start */
 1919               		.loc 1 1040 1 is_stmt 0 view .LVU468
 1920 000e 0F90      		pop __tmp_reg__
 1921 0010 0F90      		pop __tmp_reg__
 1922 0012 0F90      		pop __tmp_reg__
 1923 0014 0F90      		pop __tmp_reg__
 1924 0016 0F90      		pop __tmp_reg__
 1925 0018 DF91      		pop r29
 1926 001a CF91      		pop r28
 1927 001c 0895      		ret
 1928               		.cfi_endproc
 1929               	.LFE35:
 1931               		.section	.text.debug_record,"ax",@progbits
 1932               	.global	debug_record
 1934               	debug_record:
 1935               	.LFB36:
1041:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1042:tmk_core/common/action.c ****  *
1043:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1044:tmk_core/common/action.c ****  */
1045:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 1936               		.loc 1 1045 39 is_stmt 1 view -0
 1937               		.cfi_startproc
 1938 0000 CF93      		push r28
 1939               	.LCFI25:
 1940               		.cfi_def_cfa_offset 3
 1941               		.cfi_offset 28, -2
 1942 0002 DF93      		push r29
 1943               	.LCFI26:
 1944               		.cfi_def_cfa_offset 4
 1945               		.cfi_offset 29, -3
 1946 0004 00D0      		rcall .
 1947 0006 00D0      		rcall .
 1948 0008 00D0      		rcall .
 1949               	.LCFI27:
 1950               		.cfi_def_cfa_offset 10
 1951 000a CDB7      		in r28,__SP_L__
 1952 000c DEB7      		in r29,__SP_H__
 1953               	.LCFI28:
 1954               		.cfi_def_cfa_register 28
 1955               	/* prologue: function */
 1956               	/* frame size = 6 */
 1957               	/* stack size = 8 */
 1958               	.L__stack_usage = 8
1046:tmk_core/common/action.c ****     debug_event(record.event);
 1959               		.loc 1 1046 5 view .LVU470
1047:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1048:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 1960               		.loc 1 1048 77 view .LVU471
 1961               	/* epilogue start */
1049:tmk_core/common/action.c **** #endif
1050:tmk_core/common/action.c **** }
 1962               		.loc 1 1050 1 is_stmt 0 view .LVU472
 1963 000e 2696      		adiw r28,6
 1964 0010 0FB6      		in __tmp_reg__,__SREG__
 1965 0012 F894      		cli
 1966 0014 DEBF      		out __SP_H__,r29
 1967 0016 0FBE      		out __SREG__,__tmp_reg__
 1968 0018 CDBF      		out __SP_L__,r28
 1969 001a DF91      		pop r29
 1970 001c CF91      		pop r28
 1971 001e 0895      		ret
 1972               		.cfi_endproc
 1973               	.LFE36:
 1975               		.section	.text.debug_action,"ax",@progbits
 1976               	.global	debug_action
 1978               	debug_action:
 1979               	.LVL190:
 1980               	.LFB37:
1051:tmk_core/common/action.c **** 
1052:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1053:tmk_core/common/action.c ****  *
1054:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1055:tmk_core/common/action.c ****  */
1056:tmk_core/common/action.c **** void debug_action(action_t action) {
 1981               		.loc 1 1056 36 is_stmt 1 view -0
 1982               		.cfi_startproc
 1983               	/* prologue: function */
 1984               	/* frame size = 0 */
 1985               	/* stack size = 0 */
 1986               	.L__stack_usage = 0
1057:tmk_core/common/action.c ****     switch (action.kind.id) {
 1987               		.loc 1 1057 5 view .LVU474
1058:tmk_core/common/action.c ****         case ACT_LMODS:
1059:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1060:tmk_core/common/action.c ****             break;
1061:tmk_core/common/action.c ****         case ACT_RMODS:
1062:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1063:tmk_core/common/action.c ****             break;
1064:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1065:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1066:tmk_core/common/action.c ****             break;
1067:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1068:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1069:tmk_core/common/action.c ****             break;
1070:tmk_core/common/action.c ****         case ACT_USAGE:
1071:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1072:tmk_core/common/action.c ****             break;
1073:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1074:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1075:tmk_core/common/action.c ****             break;
1076:tmk_core/common/action.c ****         case ACT_LAYER:
1077:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1078:tmk_core/common/action.c ****             break;
1079:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1080:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1081:tmk_core/common/action.c ****             break;
1082:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1083:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1084:tmk_core/common/action.c ****             break;
1085:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1086:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1087:tmk_core/common/action.c ****             break;
1088:tmk_core/common/action.c ****         case ACT_MACRO:
1089:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1090:tmk_core/common/action.c ****             break;
1091:tmk_core/common/action.c ****         case ACT_FUNCTION:
1092:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1093:tmk_core/common/action.c ****             break;
1094:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1095:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1096:tmk_core/common/action.c ****             break;
1097:tmk_core/common/action.c ****         default:
1098:tmk_core/common/action.c ****             dprint("UNKNOWN");
1099:tmk_core/common/action.c ****             break;
1100:tmk_core/common/action.c ****     }
1101:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 1988               		.loc 1 1101 75 view .LVU475
 1989               	/* epilogue start */
1102:tmk_core/common/action.c **** }
 1990               		.loc 1 1102 1 is_stmt 0 view .LVU476
 1991 0000 0895      		ret
 1992               		.cfi_endproc
 1993               	.LFE37:
 1995               	.global	disable_action_cache
 1996               		.section	.bss.disable_action_cache,"aw",@nobits
 1999               	disable_action_cache:
 2000 0000 00        		.zero	1
 2001               		.comm	tp_buttons,2,1
 2002               		.text
 2003               	.Letext0:
 2004               		.file 4 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/stdint.h"
 2005               		.file 5 "tmk_core/common/keycode.h"
 2006               		.file 6 "tmk_core/common/report.h"
 2007               		.file 7 "tmk_core/common/host.h"
 2008               		.file 8 "tmk_core/common/mousekey.h"
 2009               		.file 9 "tmk_core/common/command.h"
 2010               		.file 10 "tmk_core/common/action_code.h"
 2011               		.file 11 "tmk_core/common/action.h"
 2012               		.file 12 "tmk_core/common/action_layer.h"
 2013               		.file 13 "tmk_core/common/action_util.h"
 2014               		.file 14 "tmk_core/common/avr/xprintf.h"
 2015               		.file 15 "tmk_core/common/debug.h"
 2016               		.file 16 "tmk_core/common/led.h"
 2017               		.file 17 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:4      *ABS*:000000000000003f __SREG__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:13     .text.action_exec:0000000000000000 action_exec
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:94     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:116    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:135    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:160    .text.register_code:0000000000000000 register_code
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:272    .text.unregister_code:0000000000000000 unregister_code
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:372    .text.tap_code:0000000000000000 tap_code
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:437    .text.register_mods:0000000000000000 register_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:466    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:495    .text.process_action:0000000000000000 process_action
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1526   .text.process_record:0000000000000000 process_record
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1454   .text.process_record_handler:0000000000000000 process_record_handler
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1626   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1999   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1654   .text.register_weak_mods:0000000000000000 register_weak_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1683   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1712   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1741   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1761   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1781   .text.is_tap_action:0000000000000000 is_tap_action
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1869   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1892   .text.debug_event:0000000000000000 debug_event
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1934   .text.debug_record:0000000000000000 debug_record
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccKu2NBS.s:1978   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
keyboard_report
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
mousekey_on
mousekey_send
del_mods
host_system_send
host_consumer_send
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
host_keyboard_leds
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_clear_bss
