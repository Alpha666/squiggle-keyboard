   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB15:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  55:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  58:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  59:tmk_core/common/action.c **** #endif
  60:tmk_core/common/action.c **** /** \brief Called to execute an action.
  61:tmk_core/common/action.c ****  *
  62:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  63:tmk_core/common/action.c ****  */
  64:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 64 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  65:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 65 5 view .LVU1
  66:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:tmk_core/common/action.c ****         dprint("EVENT: ");
  68:tmk_core/common/action.c ****         debug_event(event);
  69:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 69 19 view .LVU2
  70:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  71:tmk_core/common/action.c ****         retro_tapping_counter++;
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c **** 
  75:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  76:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  77:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  78:tmk_core/common/action.c ****     }
  79:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  80:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c ****     fauxclicky_check();
  83:tmk_core/common/action.c **** #endif
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  86:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  87:tmk_core/common/action.c ****         process_hand_swap(&event);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 91 5 view .LVU3
  51               		.loc 1 91 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  94:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  95:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  96:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  99:tmk_core/common/action.c ****         clear_oneshot_mods();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 102:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 103:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 104:tmk_core/common/action.c ****     }
 105:tmk_core/common/action.c **** #        endif
 106:tmk_core/common/action.c **** #    endif
 107:tmk_core/common/action.c **** #endif
 108:tmk_core/common/action.c **** 
 109:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 110:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 110 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 110 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 110 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 111:tmk_core/common/action.c **** #else
 112:tmk_core/common/action.c ****     process_record(&record);
 113:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 114:tmk_core/common/action.c ****         dprint("processed: ");
 115:tmk_core/common/action.c ****         debug_record(record);
 116:tmk_core/common/action.c ****         dprintln();
 117:tmk_core/common/action.c ****     }
 118:tmk_core/common/action.c **** #endif
 119:tmk_core/common/action.c **** }
  76               		.loc 1 119 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
 110:tmk_core/common/action.c **** #else
  85               		.loc 1 110 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE15:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB17:
 120:tmk_core/common/action.c **** 
 121:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 122:tmk_core/common/action.c **** bool swap_hands = false;
 123:tmk_core/common/action.c **** bool swap_held  = false;
 124:tmk_core/common/action.c **** 
 125:tmk_core/common/action.c **** /** \brief Process Hand Swap
 126:tmk_core/common/action.c ****  *
 127:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 128:tmk_core/common/action.c ****  */
 129:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 130:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 131:tmk_core/common/action.c **** 
 132:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 133:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 134:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 135:tmk_core/common/action.c **** 
 136:tmk_core/common/action.c ****     if (do_swap) {
 137:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 138:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 139:tmk_core/common/action.c ****     } else {
 140:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:tmk_core/common/action.c ****     }
 142:tmk_core/common/action.c **** }
 143:tmk_core/common/action.c **** #endif
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:tmk_core/common/action.c **** bool disable_action_cache = false;
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:tmk_core/common/action.c ****     disable_action_cache = true;
 150:tmk_core/common/action.c ****     process_record(record);
 151:tmk_core/common/action.c ****     disable_action_cache = false;
 152:tmk_core/common/action.c **** }
 153:tmk_core/common/action.c **** #else
 154:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:tmk_core/common/action.c **** #endif
 156:tmk_core/common/action.c **** 
 157:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 157 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 157 74 view .LVU11
 104               		.loc 1 157 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 157 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE17:
 113               		.section	.text.post_process_record_quantum,"ax",@progbits
 114               		.weak	post_process_record_quantum
 116               	post_process_record_quantum:
 117               	.LVL6:
 118               	.LFB18:
 158:tmk_core/common/action.c **** 
 159:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 119               		.loc 1 159 77 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 125               		.loc 1 159 78 view .LVU15
 126               	/* epilogue start */
 127               		.loc 1 159 1 is_stmt 0 view .LVU16
 128 0000 0895      		ret
 129               		.cfi_endproc
 130               	.LFE18:
 132               		.section	.text.process_record_tap_hint,"ax",@progbits
 133               	.global	process_record_tap_hint
 135               	process_record_tap_hint:
 136               	.LVL7:
 137               	.LFB19:
 160:tmk_core/common/action.c **** 
 161:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 162:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:tmk_core/common/action.c ****  *
 164:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 165:tmk_core/common/action.c ****  */
 166:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 138               		.loc 1 166 51 is_stmt 1 view -0
 139               		.cfi_startproc
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 167:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 144               		.loc 1 167 5 view .LVU18
 145               		.loc 1 167 23 is_stmt 0 view .LVU19
 146 0000 FC01      		movw r30,r24
 147 0002 8081      		ld r24,Z
 148 0004 9181      		ldd r25,Z+1
 149               	.LVL8:
 150               		.loc 1 167 23 view .LVU20
 151 0006 0C94 0000 		jmp layer_switch_get_action
 152               	.LVL9:
 153               		.loc 1 167 23 view .LVU21
 154               		.cfi_endproc
 155               	.LFE19:
 157               		.section	.text.register_code,"ax",@progbits
 158               	.global	register_code
 160               	register_code:
 161               	.LVL10:
 162               	.LFB23:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c ****     switch (action.kind.id) {
 170:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 172:tmk_core/common/action.c ****             switch (action.swap.code) {
 173:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 174:tmk_core/common/action.c ****                     break;
 175:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:tmk_core/common/action.c ****                 default:
 177:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 178:tmk_core/common/action.c ****                     swap_held  = true;
 179:tmk_core/common/action.c ****             }
 180:tmk_core/common/action.c ****             break;
 181:tmk_core/common/action.c **** #    endif
 182:tmk_core/common/action.c ****     }
 183:tmk_core/common/action.c **** }
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:tmk_core/common/action.c ****  *
 188:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 189:tmk_core/common/action.c ****  */
 190:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 191:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 192:tmk_core/common/action.c ****         return;
 193:tmk_core/common/action.c ****     }
 194:tmk_core/common/action.c **** 
 195:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 196:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 197:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:tmk_core/common/action.c ****         }
 200:tmk_core/common/action.c **** #endif
 201:tmk_core/common/action.c ****         return;
 202:tmk_core/common/action.c ****     }
 203:tmk_core/common/action.c **** 
 204:tmk_core/common/action.c ****     process_record_handler(record);
 205:tmk_core/common/action.c ****     post_process_record_quantum(record);
 206:tmk_core/common/action.c **** }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 209:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 210:tmk_core/common/action.c ****     dprint("ACTION: ");
 211:tmk_core/common/action.c ****     debug_action(action);
 212:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 213:tmk_core/common/action.c ****     dprint(" layer_state: ");
 214:tmk_core/common/action.c ****     layer_debug();
 215:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 216:tmk_core/common/action.c ****     default_layer_debug();
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c ****     dprintln();
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     process_action(record, action);
 221:tmk_core/common/action.c **** }
 222:tmk_core/common/action.c **** 
 223:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 224:tmk_core/common/action.c ****  *
 225:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 226:tmk_core/common/action.c ****  */
 227:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 228:tmk_core/common/action.c ****     keyevent_t event = record->event;
 229:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 230:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 231:tmk_core/common/action.c **** #endif
 232:tmk_core/common/action.c **** 
 233:tmk_core/common/action.c ****     if (event.pressed) {
 234:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 235:tmk_core/common/action.c ****         clear_weak_mods();
 236:tmk_core/common/action.c ****     }
 237:tmk_core/common/action.c **** 
 238:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 239:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 240:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 241:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 242:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 243:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 244:tmk_core/common/action.c **** #    endif
 245:tmk_core/common/action.c ****     ) {
 246:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 247:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 248:tmk_core/common/action.c ****     }
 249:tmk_core/common/action.c **** #endif
 250:tmk_core/common/action.c **** 
 251:tmk_core/common/action.c ****     switch (action.kind.id) {
 252:tmk_core/common/action.c ****         /* Key and Mods */
 253:tmk_core/common/action.c ****         case ACT_LMODS:
 254:tmk_core/common/action.c ****         case ACT_RMODS: {
 255:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 256:tmk_core/common/action.c ****             if (event.pressed) {
 257:tmk_core/common/action.c ****                 if (mods) {
 258:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 259:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 260:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 261:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 262:tmk_core/common/action.c ****                         add_mods(mods);
 263:tmk_core/common/action.c ****                     } else {
 264:tmk_core/common/action.c ****                         add_weak_mods(mods);
 265:tmk_core/common/action.c ****                     }
 266:tmk_core/common/action.c ****                     send_keyboard_report();
 267:tmk_core/common/action.c ****                 }
 268:tmk_core/common/action.c ****                 register_code(action.key.code);
 269:tmk_core/common/action.c ****             } else {
 270:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 271:tmk_core/common/action.c ****                 if (mods) {
 272:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 273:tmk_core/common/action.c ****                         del_mods(mods);
 274:tmk_core/common/action.c ****                     } else {
 275:tmk_core/common/action.c ****                         del_weak_mods(mods);
 276:tmk_core/common/action.c ****                     }
 277:tmk_core/common/action.c ****                     send_keyboard_report();
 278:tmk_core/common/action.c ****                 }
 279:tmk_core/common/action.c ****             }
 280:tmk_core/common/action.c ****         } break;
 281:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 282:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 283:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 284:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 285:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 286:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 287:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 288:tmk_core/common/action.c ****                     // Oneshot modifier
 289:tmk_core/common/action.c ****                     if (event.pressed) {
 290:tmk_core/common/action.c ****                         if (tap_count == 0) {
 291:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 292:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 293:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 294:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 295:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 296:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 297:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 299:tmk_core/common/action.c ****                             clear_oneshot_mods();
 300:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 301:tmk_core/common/action.c ****                             register_mods(mods);
 302:tmk_core/common/action.c **** #        endif
 303:tmk_core/common/action.c ****                         } else {
 304:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 305:tmk_core/common/action.c ****                         }
 306:tmk_core/common/action.c ****                     } else {
 307:tmk_core/common/action.c ****                         if (tap_count == 0) {
 308:tmk_core/common/action.c ****                             clear_oneshot_mods();
 309:tmk_core/common/action.c ****                             unregister_mods(mods);
 310:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 311:tmk_core/common/action.c ****                             // Retain Oneshot mods
 312:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 313:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 314:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 315:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 316:tmk_core/common/action.c ****                                 unregister_mods(mods);
 317:tmk_core/common/action.c ****                             }
 318:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 319:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 320:tmk_core/common/action.c **** #        endif
 321:tmk_core/common/action.c ****                         } else {
 322:tmk_core/common/action.c ****                             clear_oneshot_mods();
 323:tmk_core/common/action.c ****                             unregister_mods(mods);
 324:tmk_core/common/action.c ****                         }
 325:tmk_core/common/action.c ****                     }
 326:tmk_core/common/action.c ****                     break;
 327:tmk_core/common/action.c **** #    endif
 328:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 329:tmk_core/common/action.c ****                     if (event.pressed) {
 330:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 331:tmk_core/common/action.c ****                             register_mods(mods);
 332:tmk_core/common/action.c ****                         }
 333:tmk_core/common/action.c ****                     } else {
 334:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 335:tmk_core/common/action.c ****                             unregister_mods(mods);
 336:tmk_core/common/action.c ****                         }
 337:tmk_core/common/action.c ****                     }
 338:tmk_core/common/action.c ****                     break;
 339:tmk_core/common/action.c ****                 default:
 340:tmk_core/common/action.c ****                     if (event.pressed) {
 341:tmk_core/common/action.c ****                         if (tap_count > 0) {
 342:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 343:tmk_core/common/action.c ****                             if (
 344:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 345:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 346:tmk_core/common/action.c **** #        endif
 347:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 348:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 349:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 350:tmk_core/common/action.c ****                                 record->tap.count = 0;
 351:tmk_core/common/action.c ****                                 register_mods(mods);
 352:tmk_core/common/action.c ****                             } else
 353:tmk_core/common/action.c **** #    endif
 354:tmk_core/common/action.c ****                             {
 355:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 356:tmk_core/common/action.c ****                                 register_code(action.key.code);
 357:tmk_core/common/action.c ****                             }
 358:tmk_core/common/action.c ****                         } else {
 359:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 360:tmk_core/common/action.c ****                             register_mods(mods);
 361:tmk_core/common/action.c ****                         }
 362:tmk_core/common/action.c ****                     } else {
 363:tmk_core/common/action.c ****                         if (tap_count > 0) {
 364:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 365:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 366:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 367:tmk_core/common/action.c ****                             } else {
 368:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 369:tmk_core/common/action.c ****                             }
 370:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 371:tmk_core/common/action.c ****                         } else {
 372:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 373:tmk_core/common/action.c ****                             unregister_mods(mods);
 374:tmk_core/common/action.c ****                         }
 375:tmk_core/common/action.c ****                     }
 376:tmk_core/common/action.c ****                     break;
 377:tmk_core/common/action.c ****             }
 378:tmk_core/common/action.c ****         } break;
 379:tmk_core/common/action.c **** #endif
 380:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 381:tmk_core/common/action.c ****         /* other HID usage */
 382:tmk_core/common/action.c ****         case ACT_USAGE:
 383:tmk_core/common/action.c ****             switch (action.usage.page) {
 384:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 385:tmk_core/common/action.c ****                     if (event.pressed) {
 386:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 387:tmk_core/common/action.c ****                     } else {
 388:tmk_core/common/action.c ****                         host_system_send(0);
 389:tmk_core/common/action.c ****                     }
 390:tmk_core/common/action.c ****                     break;
 391:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 392:tmk_core/common/action.c ****                     if (event.pressed) {
 393:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 394:tmk_core/common/action.c ****                     } else {
 395:tmk_core/common/action.c ****                         host_consumer_send(0);
 396:tmk_core/common/action.c ****                     }
 397:tmk_core/common/action.c ****                     break;
 398:tmk_core/common/action.c ****             }
 399:tmk_core/common/action.c ****             break;
 400:tmk_core/common/action.c **** #endif
 401:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 402:tmk_core/common/action.c ****         /* Mouse key */
 403:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 404:tmk_core/common/action.c ****             if (event.pressed) {
 405:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 406:tmk_core/common/action.c ****                 switch (action.key.code) {
 407:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 408:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 409:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 410:tmk_core/common/action.c ****                         break;
 411:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 412:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 413:tmk_core/common/action.c ****                         break;
 414:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 415:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 416:tmk_core/common/action.c ****                         break;
 417:tmk_core/common/action.c **** #    endif
 418:tmk_core/common/action.c ****                     default:
 419:tmk_core/common/action.c ****                         mousekey_send();
 420:tmk_core/common/action.c ****                         break;
 421:tmk_core/common/action.c ****                 }
 422:tmk_core/common/action.c ****             } else {
 423:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 424:tmk_core/common/action.c ****                 switch (action.key.code) {
 425:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 426:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 427:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 428:tmk_core/common/action.c ****                         break;
 429:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 430:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 431:tmk_core/common/action.c ****                         break;
 432:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 433:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 434:tmk_core/common/action.c ****                         break;
 435:tmk_core/common/action.c **** #    endif
 436:tmk_core/common/action.c ****                     default:
 437:tmk_core/common/action.c ****                         mousekey_send();
 438:tmk_core/common/action.c ****                         break;
 439:tmk_core/common/action.c ****                 }
 440:tmk_core/common/action.c ****             }
 441:tmk_core/common/action.c ****             break;
 442:tmk_core/common/action.c **** #endif
 443:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 444:tmk_core/common/action.c ****         case ACT_LAYER:
 445:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 446:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 447:tmk_core/common/action.c ****                 if (!event.pressed) {
 448:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 449:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 450:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 451:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 452:tmk_core/common/action.c ****                         case OP_BIT_AND:
 453:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 454:tmk_core/common/action.c ****                             break;
 455:tmk_core/common/action.c ****                         case OP_BIT_OR:
 456:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 457:tmk_core/common/action.c ****                             break;
 458:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 459:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 460:tmk_core/common/action.c ****                             break;
 461:tmk_core/common/action.c ****                         case OP_BIT_SET:
 462:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 463:tmk_core/common/action.c ****                             break;
 464:tmk_core/common/action.c ****                     }
 465:tmk_core/common/action.c ****                 }
 466:tmk_core/common/action.c ****             } else {
 467:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 468:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 469:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 470:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 471:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 472:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 473:tmk_core/common/action.c ****                         case OP_BIT_AND:
 474:tmk_core/common/action.c ****                             layer_and(bits | mask);
 475:tmk_core/common/action.c ****                             break;
 476:tmk_core/common/action.c ****                         case OP_BIT_OR:
 477:tmk_core/common/action.c ****                             layer_or(bits | mask);
 478:tmk_core/common/action.c ****                             break;
 479:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 480:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 481:tmk_core/common/action.c ****                             break;
 482:tmk_core/common/action.c ****                         case OP_BIT_SET:
 483:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 484:tmk_core/common/action.c ****                             break;
 485:tmk_core/common/action.c ****                     }
 486:tmk_core/common/action.c ****                 }
 487:tmk_core/common/action.c ****             }
 488:tmk_core/common/action.c ****             break;
 489:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 490:tmk_core/common/action.c ****             if (event.pressed) {
 491:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 492:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 493:tmk_core/common/action.c ****             } else {
 494:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 495:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 496:tmk_core/common/action.c ****             }
 497:tmk_core/common/action.c ****             break;
 498:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 499:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 500:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 501:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 502:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 503:tmk_core/common/action.c ****                     /* tap toggle */
 504:tmk_core/common/action.c ****                     if (event.pressed) {
 505:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 506:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 507:tmk_core/common/action.c ****                         }
 508:tmk_core/common/action.c ****                     } else {
 509:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 510:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 511:tmk_core/common/action.c ****                         }
 512:tmk_core/common/action.c ****                     }
 513:tmk_core/common/action.c ****                     break;
 514:tmk_core/common/action.c ****                 case OP_ON_OFF:
 515:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 516:tmk_core/common/action.c ****                     break;
 517:tmk_core/common/action.c ****                 case OP_OFF_ON:
 518:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 519:tmk_core/common/action.c ****                     break;
 520:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 521:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 522:tmk_core/common/action.c ****                     break;
 523:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 524:tmk_core/common/action.c ****                 case OP_ONESHOT:
 525:tmk_core/common/action.c ****                     // Oneshot modifier
 526:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 527:tmk_core/common/action.c ****                     do_release_oneshot = false;
 528:tmk_core/common/action.c ****                     if (event.pressed) {
 529:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 530:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 531:tmk_core/common/action.c ****                             reset_oneshot_layer();
 532:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 533:tmk_core/common/action.c ****                             break;
 534:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 535:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 536:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 537:tmk_core/common/action.c ****                         }
 538:tmk_core/common/action.c ****                     } else {
 539:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 540:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 541:tmk_core/common/action.c ****                             reset_oneshot_layer();
 542:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 543:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 544:tmk_core/common/action.c ****                         } else {
 545:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     }
 548:tmk_core/common/action.c **** #            else
 549:tmk_core/common/action.c ****                     if (event.pressed) {
 550:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 551:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 552:tmk_core/common/action.c ****                     } else {
 553:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 554:tmk_core/common/action.c ****                         if (tap_count > 1) {
 555:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 556:tmk_core/common/action.c ****                         }
 557:tmk_core/common/action.c ****                     }
 558:tmk_core/common/action.c **** #            endif
 559:tmk_core/common/action.c ****                     break;
 560:tmk_core/common/action.c **** #        endif
 561:tmk_core/common/action.c ****                 default:
 562:tmk_core/common/action.c ****                     /* tap key */
 563:tmk_core/common/action.c ****                     if (event.pressed) {
 564:tmk_core/common/action.c ****                         if (tap_count > 0) {
 565:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 566:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 567:tmk_core/common/action.c ****                         } else {
 568:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 569:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 570:tmk_core/common/action.c ****                         }
 571:tmk_core/common/action.c ****                     } else {
 572:tmk_core/common/action.c ****                         if (tap_count > 0) {
 573:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 574:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 575:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 576:tmk_core/common/action.c ****                             } else {
 577:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 578:tmk_core/common/action.c ****                             }
 579:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 580:tmk_core/common/action.c ****                         } else {
 581:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 582:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 583:tmk_core/common/action.c ****                         }
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c ****                     break;
 586:tmk_core/common/action.c ****             }
 587:tmk_core/common/action.c ****             break;
 588:tmk_core/common/action.c **** #    endif
 589:tmk_core/common/action.c **** #endif
 590:tmk_core/common/action.c ****             /* Extentions */
 591:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 592:tmk_core/common/action.c ****         case ACT_MACRO:
 593:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 594:tmk_core/common/action.c ****             break;
 595:tmk_core/common/action.c **** #endif
 596:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 597:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 598:tmk_core/common/action.c ****             switch (action.swap.code) {
 599:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 602:tmk_core/common/action.c ****                     }
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 605:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 608:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 609:tmk_core/common/action.c ****                     break;
 610:tmk_core/common/action.c ****                 case OP_SH_ON:
 611:tmk_core/common/action.c ****                     if (!event.pressed) {
 612:tmk_core/common/action.c ****                         swap_hands = true;
 613:tmk_core/common/action.c ****                     }
 614:tmk_core/common/action.c ****                     break;
 615:tmk_core/common/action.c ****                 case OP_SH_OFF:
 616:tmk_core/common/action.c ****                     if (!event.pressed) {
 617:tmk_core/common/action.c ****                         swap_hands = false;
 618:tmk_core/common/action.c ****                     }
 619:tmk_core/common/action.c ****                     break;
 620:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 621:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 622:tmk_core/common/action.c ****                     if (event.pressed) {
 623:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 624:tmk_core/common/action.c ****                     } else {
 625:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 626:tmk_core/common/action.c ****                     }
 627:tmk_core/common/action.c ****                     break;
 628:tmk_core/common/action.c **** #    endif
 629:tmk_core/common/action.c **** 
 630:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 631:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 632:tmk_core/common/action.c ****                     /* tap toggle */
 633:tmk_core/common/action.c **** 
 634:tmk_core/common/action.c ****                     if (event.pressed) {
 635:tmk_core/common/action.c ****                         if (swap_held) {
 636:tmk_core/common/action.c ****                             swap_held = false;
 637:tmk_core/common/action.c ****                         } else {
 638:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 639:tmk_core/common/action.c ****                         }
 640:tmk_core/common/action.c ****                     } else {
 641:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 642:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 643:tmk_core/common/action.c ****                         }
 644:tmk_core/common/action.c ****                     }
 645:tmk_core/common/action.c ****                     break;
 646:tmk_core/common/action.c ****                 default:
 647:tmk_core/common/action.c ****                     /* tap key */
 648:tmk_core/common/action.c ****                     if (tap_count > 0) {
 649:tmk_core/common/action.c ****                         if (swap_held) {
 650:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 651:tmk_core/common/action.c ****                             swap_held  = false;
 652:tmk_core/common/action.c ****                         }
 653:tmk_core/common/action.c ****                         if (event.pressed) {
 654:tmk_core/common/action.c ****                             register_code(action.swap.code);
 655:tmk_core/common/action.c ****                         } else {
 656:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 657:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 658:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 659:tmk_core/common/action.c ****                         }
 660:tmk_core/common/action.c ****                     } else {
 661:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 662:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 663:tmk_core/common/action.c ****                             swap_held  = false;
 664:tmk_core/common/action.c ****                         }
 665:tmk_core/common/action.c ****                     }
 666:tmk_core/common/action.c **** #    endif
 667:tmk_core/common/action.c ****             }
 668:tmk_core/common/action.c **** #endif
 669:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 670:tmk_core/common/action.c ****         case ACT_FUNCTION:
 671:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 672:tmk_core/common/action.c ****             break;
 673:tmk_core/common/action.c **** #endif
 674:tmk_core/common/action.c ****         default:
 675:tmk_core/common/action.c ****             break;
 676:tmk_core/common/action.c ****     }
 677:tmk_core/common/action.c **** 
 678:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 679:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 680:tmk_core/common/action.c ****     switch (action.kind.id) {
 681:tmk_core/common/action.c ****         case ACT_LAYER:
 682:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 683:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 684:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 685:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 686:tmk_core/common/action.c **** #    endif
 687:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 688:tmk_core/common/action.c ****             break;
 689:tmk_core/common/action.c ****         default:
 690:tmk_core/common/action.c ****             break;
 691:tmk_core/common/action.c ****     }
 692:tmk_core/common/action.c **** #endif
 693:tmk_core/common/action.c **** 
 694:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 695:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 696:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 697:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 698:tmk_core/common/action.c ****     } else {
 699:tmk_core/common/action.c ****         if (event.pressed) {
 700:tmk_core/common/action.c ****             if (tap_count > 0) {
 701:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 702:tmk_core/common/action.c ****             } else {
 703:tmk_core/common/action.c ****             }
 704:tmk_core/common/action.c ****         } else {
 705:tmk_core/common/action.c ****             if (tap_count > 0) {
 706:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 707:tmk_core/common/action.c ****             } else {
 708:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 709:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 710:tmk_core/common/action.c ****                 }
 711:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 712:tmk_core/common/action.c ****             }
 713:tmk_core/common/action.c ****         }
 714:tmk_core/common/action.c ****     }
 715:tmk_core/common/action.c **** #    endif
 716:tmk_core/common/action.c **** #endif
 717:tmk_core/common/action.c **** 
 718:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 719:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 720:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 721:tmk_core/common/action.c ****         use_oneshot_swaphands();
 722:tmk_core/common/action.c ****     }
 723:tmk_core/common/action.c **** #    endif
 724:tmk_core/common/action.c **** #endif
 725:tmk_core/common/action.c **** 
 726:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 727:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 728:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 729:tmk_core/common/action.c ****      */
 730:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 731:tmk_core/common/action.c ****         record->event.pressed = false;
 732:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 733:tmk_core/common/action.c ****         process_record(record);
 734:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 735:tmk_core/common/action.c ****     }
 736:tmk_core/common/action.c **** #endif
 737:tmk_core/common/action.c **** }
 738:tmk_core/common/action.c **** 
 739:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 740:tmk_core/common/action.c ****  *
 741:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 742:tmk_core/common/action.c ****  */
 743:tmk_core/common/action.c **** void register_code(uint8_t code) {
 163               		.loc 1 743 34 is_stmt 1 view -0
 164               		.cfi_startproc
 165               		.loc 1 743 34 is_stmt 0 view .LVU23
 166 0000 CF93      		push r28
 167               	.LCFI4:
 168               		.cfi_def_cfa_offset 3
 169               		.cfi_offset 28, -2
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               	/* stack size = 1 */
 173               	.L__stack_usage = 1
 174 0002 C82F      		mov r28,r24
 744:tmk_core/common/action.c ****     if (code == KC_NO) {
 175               		.loc 1 744 5 is_stmt 1 view .LVU24
 176               		.loc 1 744 8 is_stmt 0 view .LVU25
 177 0004 8823      		tst r24
 178 0006 01F4      		brne .+2
 179 0008 00C0      		rjmp .L5
 745:tmk_core/common/action.c ****         return;
 746:tmk_core/common/action.c ****     }
 747:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 748:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 749:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 750:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 751:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 752:tmk_core/common/action.c **** #    endif
 753:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 754:tmk_core/common/action.c ****         send_keyboard_report();
 755:tmk_core/common/action.c ****         wait_ms(100);
 756:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 757:tmk_core/common/action.c ****         send_keyboard_report();
 758:tmk_core/common/action.c ****     }
 759:tmk_core/common/action.c **** 
 760:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 761:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 762:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 763:tmk_core/common/action.c **** #    endif
 764:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 765:tmk_core/common/action.c ****         send_keyboard_report();
 766:tmk_core/common/action.c ****         wait_ms(100);
 767:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 768:tmk_core/common/action.c ****         send_keyboard_report();
 769:tmk_core/common/action.c ****     }
 770:tmk_core/common/action.c **** 
 771:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 772:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 773:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 774:tmk_core/common/action.c **** #    endif
 775:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 776:tmk_core/common/action.c ****         send_keyboard_report();
 777:tmk_core/common/action.c ****         wait_ms(100);
 778:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 779:tmk_core/common/action.c ****         send_keyboard_report();
 780:tmk_core/common/action.c ****     }
 781:tmk_core/common/action.c **** #endif
 782:tmk_core/common/action.c **** 
 783:tmk_core/common/action.c ****     else if
 180               		.loc 1 783 10 is_stmt 1 view .LVU26
 784:tmk_core/common/action.c ****         IS_KEY(code) {
 181               		.loc 1 784 9 is_stmt 0 view .LVU27
 182 000a 8CEF      		ldi r24,lo8(-4)
 183               	.LVL11:
 184               		.loc 1 784 9 view .LVU28
 185 000c 8C0F      		add r24,r28
 186 000e 813A      		cpi r24,lo8(-95)
 187 0010 00F4      		brsh .L7
 785:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 786:tmk_core/common/action.c ****             if (command_proc(code)) return;
 188               		.loc 1 786 13 is_stmt 1 view .LVU29
 787:tmk_core/common/action.c **** 
 788:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 789:tmk_core/common/action.c **** /* TODO: remove
 790:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 791:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 792:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 793:tmk_core/common/action.c **** 
 794:tmk_core/common/action.c ****             add_key(code);
 795:tmk_core/common/action.c ****             send_keyboard_report();
 796:tmk_core/common/action.c **** 
 797:tmk_core/common/action.c ****             set_mods(tmp_mods);
 798:tmk_core/common/action.c ****             send_keyboard_report();
 799:tmk_core/common/action.c ****             oneshot_cancel();
 800:tmk_core/common/action.c ****         } else
 801:tmk_core/common/action.c **** */
 802:tmk_core/common/action.c **** #endif
 803:tmk_core/common/action.c ****             {
 804:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 805:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 806:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 807:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 189               		.loc 1 807 17 view .LVU30
 190               		.loc 1 807 21 is_stmt 0 view .LVU31
 191 0012 6C2F      		mov r22,r28
 192 0014 8091 0000 		lds r24,keyboard_report
 193 0018 9091 0000 		lds r25,keyboard_report+1
 194 001c 0E94 0000 		call is_key_pressed
 195               	.LVL12:
 196               		.loc 1 807 20 view .LVU32
 197 0020 8823      		tst r24
 198 0022 01F0      		breq .L8
 808:tmk_core/common/action.c ****                     del_key(code);
 199               		.loc 1 808 21 is_stmt 1 view .LVU33
 200 0024 8C2F      		mov r24,r28
 201 0026 0E94 0000 		call del_key
 202               	.LVL13:
 809:tmk_core/common/action.c ****                     send_keyboard_report();
 203               		.loc 1 809 21 view .LVU34
 204 002a 0E94 0000 		call send_keyboard_report
 205               	.LVL14:
 206               	.L8:
 810:tmk_core/common/action.c ****                 }
 811:tmk_core/common/action.c ****                 add_key(code);
 207               		.loc 1 811 17 view .LVU35
 208 002e 8C2F      		mov r24,r28
 209 0030 0E94 0000 		call add_key
 210               	.LVL15:
 812:tmk_core/common/action.c ****                 send_keyboard_report();
 211               		.loc 1 812 17 view .LVU36
 212               	.L18:
 813:tmk_core/common/action.c ****             }
 814:tmk_core/common/action.c ****         }
 815:tmk_core/common/action.c ****     else if
 816:tmk_core/common/action.c ****         IS_MOD(code) {
 817:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 818:tmk_core/common/action.c ****             send_keyboard_report();
 213               		.loc 1 818 13 view .LVU37
 214               	/* epilogue start */
 819:tmk_core/common/action.c ****         }
 820:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 821:tmk_core/common/action.c ****     else if
 822:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 823:tmk_core/common/action.c ****     else if
 824:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 825:tmk_core/common/action.c **** #endif
 826:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 827:tmk_core/common/action.c ****     else if
 828:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 829:tmk_core/common/action.c ****             mousekey_on(code);
 830:tmk_core/common/action.c ****             mousekey_send();
 831:tmk_core/common/action.c ****         }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** }
 215               		.loc 1 833 1 is_stmt 0 view .LVU38
 216 0034 CF91      		pop r28
 818:tmk_core/common/action.c ****         }
 217               		.loc 1 818 13 view .LVU39
 218 0036 0C94 0000 		jmp send_keyboard_report
 219               	.LVL16:
 220               	.L7:
 815:tmk_core/common/action.c ****         IS_MOD(code) {
 221               		.loc 1 815 10 is_stmt 1 view .LVU40
 816:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 222               		.loc 1 816 9 is_stmt 0 view .LVU41
 223 003a 80E2      		ldi r24,lo8(32)
 224 003c 8C0F      		add r24,r28
 225 003e 8830      		cpi r24,lo8(8)
 226 0040 00F4      		brsh .L9
 817:tmk_core/common/action.c ****             send_keyboard_report();
 227               		.loc 1 817 13 is_stmt 1 view .LVU42
 817:tmk_core/common/action.c ****             send_keyboard_report();
 228               		.loc 1 817 22 is_stmt 0 view .LVU43
 229 0042 C770      		andi r28,lo8(7)
 230               	.LVL17:
 817:tmk_core/common/action.c ****             send_keyboard_report();
 231               		.loc 1 817 13 view .LVU44
 232 0044 81E0      		ldi r24,lo8(1)
 233 0046 00C0      		rjmp 2f
 234               		1:
 235 0048 880F      		lsl r24
 236               		2:
 237 004a CA95      		dec r28
 238 004c 02F4      		brpl 1b
 239 004e 0E94 0000 		call add_mods
 240               	.LVL18:
 241 0052 00C0      		rjmp .L18
 242               	.LVL19:
 243               	.L9:
 821:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 244               		.loc 1 821 10 is_stmt 1 view .LVU45
 822:tmk_core/common/action.c ****     else if
 245               		.loc 1 822 9 is_stmt 0 view .LVU46
 246 0054 EBE5      		ldi r30,lo8(91)
 247 0056 EC0F      		add r30,r28
 248 0058 E330      		cpi r30,lo8(3)
 249 005a 00F4      		brsh .L10
 822:tmk_core/common/action.c ****     else if
 250               		.loc 1 822 27 is_stmt 1 view .LVU47
 251               	.LVL20:
 252               	.LBB22:
 253               	.LBI22:
 254               		.file 2 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK
  34:tmk_core/common/report.h **** };
  35:tmk_core/common/report.h **** 
  36:tmk_core/common/report.h **** /* Mouse buttons */
  37:tmk_core/common/report.h **** enum mouse_buttons {
  38:tmk_core/common/report.h ****     MOUSE_BTN1 = (1 << 0),
  39:tmk_core/common/report.h ****     MOUSE_BTN2 = (1 << 1),
  40:tmk_core/common/report.h ****     MOUSE_BTN3 = (1 << 2),
  41:tmk_core/common/report.h ****     MOUSE_BTN4 = (1 << 3),
  42:tmk_core/common/report.h ****     MOUSE_BTN5 = (1 << 4)
  43:tmk_core/common/report.h **** };
  44:tmk_core/common/report.h **** 
  45:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  46:tmk_core/common/report.h ****  *
  47:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  48:tmk_core/common/report.h ****  */
  49:tmk_core/common/report.h **** enum consumer_usages {
  50:tmk_core/common/report.h ****     // 15.5 Display Controls
  51:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  52:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  53:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  54:tmk_core/common/report.h ****     // 15.7 Transport Controls
  55:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  56:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  57:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  58:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  59:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  60:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  61:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  62:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  63:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  64:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  65:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  66:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  67:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  68:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  69:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  70:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  71:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  72:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  73:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  74:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  75:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  76:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  77:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  78:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  79:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  80:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  81:tmk_core/common/report.h ****     AC_HOME                = 0x223,
  82:tmk_core/common/report.h ****     AC_BACK                = 0x224,
  83:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
  84:tmk_core/common/report.h ****     AC_STOP                = 0x226,
  85:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
  86:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
  87:tmk_core/common/report.h **** };
  88:tmk_core/common/report.h **** 
  89:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
  90:tmk_core/common/report.h ****  *
  91:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
  92:tmk_core/common/report.h ****  */
  93:tmk_core/common/report.h **** enum desktop_usages {
  94:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
  95:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN = 0x81,
  96:tmk_core/common/report.h ****     SYSTEM_SLEEP      = 0x82,
  97:tmk_core/common/report.h ****     SYSTEM_WAKE_UP    = 0x83
  98:tmk_core/common/report.h **** };
  99:tmk_core/common/report.h **** 
 100:tmk_core/common/report.h **** // clang-format on
 101:tmk_core/common/report.h **** 
 102:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 103:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 104:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 105:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 106:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 107:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 108:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 109:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 110:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 111:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 112:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 113:tmk_core/common/report.h **** #    else
 114:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 115:tmk_core/common/report.h **** #    endif
 116:tmk_core/common/report.h **** #endif
 117:tmk_core/common/report.h **** 
 118:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 119:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 120:tmk_core/common/report.h **** #else
 121:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 122:tmk_core/common/report.h **** #endif
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 125:tmk_core/common/report.h **** 
 126:tmk_core/common/report.h **** /* VUSB hardcodes keyboard and mouse+extrakey only */
 127:tmk_core/common/report.h **** #if defined(PROTOCOL_VUSB)
 128:tmk_core/common/report.h **** #    undef KEYBOARD_SHARED_EP
 129:tmk_core/common/report.h **** #    undef MOUSE_SHARED_EP
 130:tmk_core/common/report.h **** #endif
 131:tmk_core/common/report.h **** 
 132:tmk_core/common/report.h **** #ifdef __cplusplus
 133:tmk_core/common/report.h **** extern "C" {
 134:tmk_core/common/report.h **** #endif
 135:tmk_core/common/report.h **** 
 136:tmk_core/common/report.h **** /*
 137:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 138:tmk_core/common/report.h ****  *
 139:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 140:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 141:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 142:tmk_core/common/report.h ****  *
 143:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 144:tmk_core/common/report.h ****  *
 145:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 146:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 147:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 148:tmk_core/common/report.h ****  *
 149:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 150:tmk_core/common/report.h ****  *
 151:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 152:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 153:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 154:tmk_core/common/report.h ****  *
 155:tmk_core/common/report.h ****  */
 156:tmk_core/common/report.h **** typedef union {
 157:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 158:tmk_core/common/report.h ****     struct {
 159:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 160:tmk_core/common/report.h ****         uint8_t report_id;
 161:tmk_core/common/report.h **** #endif
 162:tmk_core/common/report.h ****         uint8_t mods;
 163:tmk_core/common/report.h ****         uint8_t reserved;
 164:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 165:tmk_core/common/report.h ****     };
 166:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 167:tmk_core/common/report.h ****     struct nkro_report {
 168:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 169:tmk_core/common/report.h ****         uint8_t report_id;
 170:tmk_core/common/report.h **** #    endif
 171:tmk_core/common/report.h ****         uint8_t mods;
 172:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 173:tmk_core/common/report.h ****     } nkro;
 174:tmk_core/common/report.h **** #endif
 175:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 176:tmk_core/common/report.h **** 
 177:tmk_core/common/report.h **** typedef struct {
 178:tmk_core/common/report.h ****     uint8_t  report_id;
 179:tmk_core/common/report.h ****     uint16_t usage;
 180:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 181:tmk_core/common/report.h **** 
 182:tmk_core/common/report.h **** typedef struct {
 183:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 184:tmk_core/common/report.h ****     uint8_t report_id;
 185:tmk_core/common/report.h **** #endif
 186:tmk_core/common/report.h ****     uint8_t buttons;
 187:tmk_core/common/report.h ****     int8_t  x;
 188:tmk_core/common/report.h ****     int8_t  y;
 189:tmk_core/common/report.h ****     int8_t  v;
 190:tmk_core/common/report.h ****     int8_t  h;
 191:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 192:tmk_core/common/report.h **** 
 193:tmk_core/common/report.h **** typedef struct {
 194:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 195:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 196:tmk_core/common/report.h **** #endif
 197:tmk_core/common/report.h **** 
 198:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 199:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 200:tmk_core/common/report.h **** #endif
 201:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 202:tmk_core/common/report.h **** 
 203:tmk_core/common/report.h **** /* keycode to system usage */
 204:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 255               		.loc 2 204 24 view .LVU48
 256               	.LBE22:
 205:tmk_core/common/report.h ****     switch (key) {
 257               		.loc 2 205 5 view .LVU49
 822:tmk_core/common/action.c ****     else if
 258               		.loc 1 822 27 is_stmt 0 view .LVU50
 259 005c F0E0      		ldi r31,0
 260 005e E050      		subi r30,lo8(-(CSWTCH.10))
 261 0060 F040      		sbci r31,hi8(-(CSWTCH.10))
 262 0062 8081      		ld r24,Z
 263 0064 90E0      		ldi r25,0
 264               	/* epilogue start */
 265               		.loc 1 833 1 view .LVU51
 266 0066 CF91      		pop r28
 267               	.LVL21:
 822:tmk_core/common/action.c ****     else if
 268               		.loc 1 822 27 view .LVU52
 269 0068 0C94 0000 		jmp host_system_send
 270               	.LVL22:
 271               	.L10:
 823:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 272               		.loc 1 823 10 is_stmt 1 view .LVU53
 824:tmk_core/common/action.c **** #endif
 273               		.loc 1 824 9 is_stmt 0 view .LVU54
 274 006c E8E5      		ldi r30,lo8(88)
 275 006e EC0F      		add r30,r28
 276 0070 E731      		cpi r30,lo8(23)
 277 0072 00F4      		brsh .L11
 824:tmk_core/common/action.c **** #endif
 278               		.loc 1 824 29 is_stmt 1 view .LVU55
 279               	.LVL23:
 280               	.LBB23:
 281               	.LBI23:
 206:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 207:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 208:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 209:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 210:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 211:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 212:tmk_core/common/report.h ****         default:
 213:tmk_core/common/report.h ****             return 0;
 214:tmk_core/common/report.h ****     }
 215:tmk_core/common/report.h **** }
 216:tmk_core/common/report.h **** 
 217:tmk_core/common/report.h **** /* keycode to consumer usage */
 218:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 282               		.loc 2 218 24 view .LVU56
 283               	.LBE23:
 219:tmk_core/common/report.h ****     switch (key) {
 284               		.loc 2 219 5 view .LVU57
 824:tmk_core/common/action.c **** #endif
 285               		.loc 1 824 29 is_stmt 0 view .LVU58
 286 0074 F0E0      		ldi r31,0
 287 0076 EE0F      		lsl r30
 288 0078 FF1F      		rol r31
 289 007a E050      		subi r30,lo8(-(CSWTCH.11))
 290 007c F040      		sbci r31,hi8(-(CSWTCH.11))
 291 007e 8081      		ld r24,Z
 292 0080 9181      		ldd r25,Z+1
 293               	/* epilogue start */
 294               		.loc 1 833 1 view .LVU59
 295 0082 CF91      		pop r28
 296               	.LVL24:
 824:tmk_core/common/action.c **** #endif
 297               		.loc 1 824 29 view .LVU60
 298 0084 0C94 0000 		jmp host_consumer_send
 299               	.LVL25:
 300               	.L11:
 827:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 301               		.loc 1 827 10 is_stmt 1 view .LVU61
 828:tmk_core/common/action.c ****             mousekey_on(code);
 302               		.loc 1 828 9 is_stmt 0 view .LVU62
 303 0088 C03F      		cpi r28,lo8(-16)
 304 008a 00F0      		brlo .L5
 829:tmk_core/common/action.c ****             mousekey_send();
 305               		.loc 1 829 13 is_stmt 1 view .LVU63
 306 008c 8C2F      		mov r24,r28
 307 008e 0E94 0000 		call mousekey_on
 308               	.LVL26:
 830:tmk_core/common/action.c ****         }
 309               		.loc 1 830 13 view .LVU64
 310               	/* epilogue start */
 311               		.loc 1 833 1 is_stmt 0 view .LVU65
 312 0092 CF91      		pop r28
 313               	.LVL27:
 830:tmk_core/common/action.c ****         }
 314               		.loc 1 830 13 view .LVU66
 315 0094 0C94 0000 		jmp mousekey_send
 316               	.LVL28:
 317               	.L5:
 318               	/* epilogue start */
 319               		.loc 1 833 1 view .LVU67
 320 0098 CF91      		pop r28
 321               	.LVL29:
 322               		.loc 1 833 1 view .LVU68
 323 009a 0895      		ret
 324               		.cfi_endproc
 325               	.LFE23:
 327               		.section	.text.unregister_code,"ax",@progbits
 328               	.global	unregister_code
 330               	unregister_code:
 331               	.LVL30:
 332               	.LFB24:
 834:tmk_core/common/action.c **** 
 835:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 836:tmk_core/common/action.c ****  *
 837:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 838:tmk_core/common/action.c ****  */
 839:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 333               		.loc 1 839 36 is_stmt 1 view -0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 840:tmk_core/common/action.c ****     if (code == KC_NO) {
 339               		.loc 1 840 5 view .LVU70
 340               		.loc 1 840 8 is_stmt 0 view .LVU71
 341 0000 8823      		tst r24
 342 0002 01F0      		breq .L19
 841:tmk_core/common/action.c ****         return;
 842:tmk_core/common/action.c ****     }
 843:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 844:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 845:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 846:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 847:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 848:tmk_core/common/action.c **** #    endif
 849:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 850:tmk_core/common/action.c ****         send_keyboard_report();
 851:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 852:tmk_core/common/action.c ****         send_keyboard_report();
 853:tmk_core/common/action.c ****     }
 854:tmk_core/common/action.c **** 
 855:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 856:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 857:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 858:tmk_core/common/action.c **** #    endif
 859:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 860:tmk_core/common/action.c ****         send_keyboard_report();
 861:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 862:tmk_core/common/action.c ****         send_keyboard_report();
 863:tmk_core/common/action.c ****     }
 864:tmk_core/common/action.c **** 
 865:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 866:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 867:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 868:tmk_core/common/action.c **** #    endif
 869:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 870:tmk_core/common/action.c ****         send_keyboard_report();
 871:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 872:tmk_core/common/action.c ****         send_keyboard_report();
 873:tmk_core/common/action.c ****     }
 874:tmk_core/common/action.c **** #endif
 875:tmk_core/common/action.c **** 
 876:tmk_core/common/action.c ****     else if
 343               		.loc 1 876 10 is_stmt 1 view .LVU72
 877:tmk_core/common/action.c ****         IS_KEY(code) {
 344               		.loc 1 877 9 is_stmt 0 view .LVU73
 345 0004 9CEF      		ldi r25,lo8(-4)
 346 0006 980F      		add r25,r24
 347 0008 913A      		cpi r25,lo8(-95)
 348 000a 00F4      		brsh .L21
 878:tmk_core/common/action.c ****             del_key(code);
 349               		.loc 1 878 13 is_stmt 1 view .LVU74
 350 000c 0E94 0000 		call del_key
 351               	.LVL31:
 879:tmk_core/common/action.c ****             send_keyboard_report();
 352               		.loc 1 879 13 view .LVU75
 353               	.L28:
 880:tmk_core/common/action.c ****         }
 881:tmk_core/common/action.c ****     else if
 882:tmk_core/common/action.c ****         IS_MOD(code) {
 883:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 884:tmk_core/common/action.c ****             send_keyboard_report();
 354               		.loc 1 884 13 view .LVU76
 355 0010 0C94 0000 		jmp send_keyboard_report
 356               	.LVL32:
 357               	.L21:
 881:tmk_core/common/action.c ****         IS_MOD(code) {
 358               		.loc 1 881 10 view .LVU77
 882:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 359               		.loc 1 882 9 is_stmt 0 view .LVU78
 360 0014 90E2      		ldi r25,lo8(32)
 361 0016 980F      		add r25,r24
 362 0018 9830      		cpi r25,lo8(8)
 363 001a 00F4      		brsh .L22
 883:tmk_core/common/action.c ****             send_keyboard_report();
 364               		.loc 1 883 13 is_stmt 1 view .LVU79
 883:tmk_core/common/action.c ****             send_keyboard_report();
 365               		.loc 1 883 22 is_stmt 0 view .LVU80
 366 001c 8770      		andi r24,lo8(7)
 367               	.LVL33:
 883:tmk_core/common/action.c ****             send_keyboard_report();
 368               		.loc 1 883 13 view .LVU81
 369 001e 91E0      		ldi r25,lo8(1)
 370 0020 00C0      		rjmp 2f
 371               		1:
 372 0022 990F      		lsl r25
 373               		2:
 374 0024 8A95      		dec r24
 375 0026 02F4      		brpl 1b
 376 0028 892F      		mov r24,r25
 377 002a 0E94 0000 		call del_mods
 378               	.LVL34:
 379 002e 00C0      		rjmp .L28
 380               	.LVL35:
 381               	.L22:
 885:tmk_core/common/action.c ****         }
 886:tmk_core/common/action.c ****     else if
 382               		.loc 1 886 10 is_stmt 1 view .LVU82
 887:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 383               		.loc 1 887 9 is_stmt 0 view .LVU83
 384 0030 9BE5      		ldi r25,lo8(91)
 385 0032 980F      		add r25,r24
 386 0034 9330      		cpi r25,lo8(3)
 387 0036 00F4      		brsh .L23
 388               		.loc 1 887 27 is_stmt 1 discriminator 1 view .LVU84
 389 0038 90E0      		ldi r25,0
 390 003a 80E0      		ldi r24,0
 391               	.LVL36:
 392               		.loc 1 887 27 is_stmt 0 discriminator 1 view .LVU85
 393 003c 0C94 0000 		jmp host_system_send
 394               	.LVL37:
 395               	.L23:
 888:tmk_core/common/action.c ****     else if
 396               		.loc 1 888 10 is_stmt 1 view .LVU86
 889:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 397               		.loc 1 889 9 is_stmt 0 view .LVU87
 398 0040 98E5      		ldi r25,lo8(88)
 399 0042 980F      		add r25,r24
 400 0044 9731      		cpi r25,lo8(23)
 401 0046 00F4      		brsh .L24
 402               		.loc 1 889 29 is_stmt 1 discriminator 1 view .LVU88
 403 0048 90E0      		ldi r25,0
 404 004a 80E0      		ldi r24,0
 405               	.LVL38:
 406               		.loc 1 889 29 is_stmt 0 discriminator 1 view .LVU89
 407 004c 0C94 0000 		jmp host_consumer_send
 408               	.LVL39:
 409               	.L24:
 890:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 891:tmk_core/common/action.c ****     else if
 410               		.loc 1 891 10 is_stmt 1 view .LVU90
 892:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 411               		.loc 1 892 9 is_stmt 0 view .LVU91
 412 0050 803F      		cpi r24,lo8(-16)
 413 0052 00F0      		brlo .L19
 893:tmk_core/common/action.c ****             mousekey_off(code);
 414               		.loc 1 893 13 is_stmt 1 view .LVU92
 415 0054 0E94 0000 		call mousekey_off
 416               	.LVL40:
 894:tmk_core/common/action.c ****             mousekey_send();
 417               		.loc 1 894 13 view .LVU93
 418 0058 0C94 0000 		jmp mousekey_send
 419               	.LVL41:
 420               	.L19:
 421               	/* epilogue start */
 895:tmk_core/common/action.c ****         }
 896:tmk_core/common/action.c **** #endif
 897:tmk_core/common/action.c **** }
 422               		.loc 1 897 1 is_stmt 0 view .LVU94
 423 005c 0895      		ret
 424               		.cfi_endproc
 425               	.LFE24:
 427               		.section	.text.tap_code,"ax",@progbits
 428               	.global	tap_code
 430               	tap_code:
 431               	.LVL42:
 432               	.LFB25:
 898:tmk_core/common/action.c **** 
 899:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 900:tmk_core/common/action.c ****  *
 901:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 902:tmk_core/common/action.c ****  */
 903:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 433               		.loc 1 903 29 is_stmt 1 view -0
 434               		.cfi_startproc
 435               		.loc 1 903 29 is_stmt 0 view .LVU96
 436 0000 CF93      		push r28
 437               	.LCFI5:
 438               		.cfi_def_cfa_offset 3
 439               		.cfi_offset 28, -2
 440               	/* prologue: function */
 441               	/* frame size = 0 */
 442               	/* stack size = 1 */
 443               	.L__stack_usage = 1
 444 0002 C82F      		mov r28,r24
 904:tmk_core/common/action.c ****     register_code(code);
 445               		.loc 1 904 5 is_stmt 1 view .LVU97
 446 0004 0E94 0000 		call register_code
 447               	.LVL43:
 905:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 448               		.loc 1 905 5 view .LVU98
 449               		.loc 1 905 8 is_stmt 0 view .LVU99
 450 0008 C933      		cpi r28,lo8(57)
 451 000a 01F4      		brne .L31
 906:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 452               		.loc 1 906 9 is_stmt 1 view .LVU100
 453               	.LVL44:
 454               	.LBB24:
 455               	.LBI24:
 456               		.file 3 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 457               		.loc 3 166 1 view .LVU101
 458               	.LBB25:
 167:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	double __tmp ;
 459               		.loc 3 168 2 view .LVU102
 169:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 460               		.loc 3 172 2 view .LVU103
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 461               		.loc 3 173 2 view .LVU104
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 462               		.loc 3 174 2 view .LVU105
 175:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 463               		.loc 3 184 3 view .LVU106
 185:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 464               		.loc 3 187 2 view .LVU107
 465 000c 2FEF      		ldi r18,lo8(255999)
 466 000e 87EE      		ldi r24,hi8(255999)
 467 0010 93E0      		ldi r25,hlo8(255999)
 468 0012 2150      	1:	subi r18,1
 469 0014 8040      		sbci r24,0
 470 0016 9040      		sbci r25,0
 471 0018 01F4      		brne 1b
 472 001a 00C0      		rjmp .
 473 001c 0000      		nop
 474               	.LVL45:
 475               	.L31:
 476               		.loc 3 187 2 is_stmt 0 view .LVU108
 477               	.LBE25:
 478               	.LBE24:
 907:tmk_core/common/action.c ****     } else {
 908:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 909:tmk_core/common/action.c ****     }
 910:tmk_core/common/action.c ****     unregister_code(code);
 479               		.loc 1 910 5 is_stmt 1 view .LVU109
 480 001e 8C2F      		mov r24,r28
 481               	/* epilogue start */
 911:tmk_core/common/action.c **** }
 482               		.loc 1 911 1 is_stmt 0 view .LVU110
 483 0020 CF91      		pop r28
 484               	.LVL46:
 910:tmk_core/common/action.c **** }
 485               		.loc 1 910 5 view .LVU111
 486 0022 0C94 0000 		jmp unregister_code
 487               	.LVL47:
 910:tmk_core/common/action.c **** }
 488               		.loc 1 910 5 view .LVU112
 489               		.cfi_endproc
 490               	.LFE25:
 492               		.section	.text.register_mods,"ax",@progbits
 493               	.global	register_mods
 495               	register_mods:
 496               	.LVL48:
 497               	.LFB26:
 912:tmk_core/common/action.c **** 
 913:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:tmk_core/common/action.c ****  *
 915:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 916:tmk_core/common/action.c ****  */
 917:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 498               		.loc 1 917 34 is_stmt 1 view -0
 499               		.cfi_startproc
 500               	/* prologue: function */
 501               	/* frame size = 0 */
 502               	/* stack size = 0 */
 503               	.L__stack_usage = 0
 918:tmk_core/common/action.c ****     if (mods) {
 504               		.loc 1 918 5 view .LVU114
 505               		.loc 1 918 8 is_stmt 0 view .LVU115
 506 0000 8823      		tst r24
 507 0002 01F0      		breq .L32
 919:tmk_core/common/action.c ****         add_mods(mods);
 508               		.loc 1 919 9 is_stmt 1 view .LVU116
 509 0004 0E94 0000 		call add_mods
 510               	.LVL49:
 920:tmk_core/common/action.c ****         send_keyboard_report();
 511               		.loc 1 920 9 view .LVU117
 512 0008 0C94 0000 		jmp send_keyboard_report
 513               	.LVL50:
 514               	.L32:
 515               	/* epilogue start */
 921:tmk_core/common/action.c ****     }
 922:tmk_core/common/action.c **** }
 516               		.loc 1 922 1 is_stmt 0 view .LVU118
 517 000c 0895      		ret
 518               		.cfi_endproc
 519               	.LFE26:
 521               		.section	.text.unregister_mods,"ax",@progbits
 522               	.global	unregister_mods
 524               	unregister_mods:
 525               	.LVL51:
 526               	.LFB27:
 923:tmk_core/common/action.c **** 
 924:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:tmk_core/common/action.c ****  *
 926:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:tmk_core/common/action.c ****  */
 928:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 527               		.loc 1 928 36 is_stmt 1 view -0
 528               		.cfi_startproc
 529               	/* prologue: function */
 530               	/* frame size = 0 */
 531               	/* stack size = 0 */
 532               	.L__stack_usage = 0
 929:tmk_core/common/action.c ****     if (mods) {
 533               		.loc 1 929 5 view .LVU120
 534               		.loc 1 929 8 is_stmt 0 view .LVU121
 535 0000 8823      		tst r24
 536 0002 01F0      		breq .L34
 930:tmk_core/common/action.c ****         del_mods(mods);
 537               		.loc 1 930 9 is_stmt 1 view .LVU122
 538 0004 0E94 0000 		call del_mods
 539               	.LVL52:
 931:tmk_core/common/action.c ****         send_keyboard_report();
 540               		.loc 1 931 9 view .LVU123
 541 0008 0C94 0000 		jmp send_keyboard_report
 542               	.LVL53:
 543               	.L34:
 544               	/* epilogue start */
 932:tmk_core/common/action.c ****     }
 933:tmk_core/common/action.c **** }
 545               		.loc 1 933 1 is_stmt 0 view .LVU124
 546 000c 0895      		ret
 547               		.cfi_endproc
 548               	.LFE27:
 550               		.section	.text.process_action,"ax",@progbits
 551               	.global	process_action
 553               	process_action:
 554               	.LVL54:
 555               	.LFB22:
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 556               		.loc 1 227 59 is_stmt 1 view -0
 557               		.cfi_startproc
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 558               		.loc 1 227 59 is_stmt 0 view .LVU126
 559 0000 BF92      		push r11
 560               	.LCFI6:
 561               		.cfi_def_cfa_offset 3
 562               		.cfi_offset 11, -2
 563 0002 CF92      		push r12
 564               	.LCFI7:
 565               		.cfi_def_cfa_offset 4
 566               		.cfi_offset 12, -3
 567 0004 DF92      		push r13
 568               	.LCFI8:
 569               		.cfi_def_cfa_offset 5
 570               		.cfi_offset 13, -4
 571 0006 EF92      		push r14
 572               	.LCFI9:
 573               		.cfi_def_cfa_offset 6
 574               		.cfi_offset 14, -5
 575 0008 FF92      		push r15
 576               	.LCFI10:
 577               		.cfi_def_cfa_offset 7
 578               		.cfi_offset 15, -6
 579 000a 0F93      		push r16
 580               	.LCFI11:
 581               		.cfi_def_cfa_offset 8
 582               		.cfi_offset 16, -7
 583 000c 1F93      		push r17
 584               	.LCFI12:
 585               		.cfi_def_cfa_offset 9
 586               		.cfi_offset 17, -8
 587 000e CF93      		push r28
 588               	.LCFI13:
 589               		.cfi_def_cfa_offset 10
 590               		.cfi_offset 28, -9
 591 0010 DF93      		push r29
 592               	.LCFI14:
 593               		.cfi_def_cfa_offset 11
 594               		.cfi_offset 29, -10
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 9 */
 598               	.L__stack_usage = 9
 599 0012 7C01      		movw r14,r24
 600 0014 D62F      		mov r29,r22
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 601               		.loc 1 227 59 view .LVU127
 602 0016 C72F      		mov r28,r23
 228:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 603               		.loc 1 228 5 is_stmt 1 view .LVU128
 604               	.LVL55:
 230:tmk_core/common/action.c **** #endif
 605               		.loc 1 230 5 view .LVU129
 230:tmk_core/common/action.c **** #endif
 606               		.loc 1 230 36 is_stmt 0 view .LVU130
 607 0018 FC01      		movw r30,r24
 608 001a 0581      		ldd r16,Z+5
 609 001c 0295      		swap r16
 610 001e 0F70      		andi r16,lo8(15)
 611               	.LVL56:
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 612               		.loc 1 233 5 is_stmt 1 view .LVU131
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 613               		.loc 1 233 14 is_stmt 0 view .LVU132
 614 0020 1281      		ldd r17,Z+2
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 615               		.loc 1 233 8 view .LVU133
 616 0022 1111      		cpse r17,__zero_reg__
 235:tmk_core/common/action.c ****     }
 617               		.loc 1 235 9 is_stmt 1 view .LVU134
 618 0024 0E94 0000 		call clear_weak_mods
 619               	.LVL57:
 620               	.L37:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 621               		.loc 1 239 5 view .LVU135
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 622               		.loc 1 241 5 view .LVU136
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 623               		.loc 1 241 9 is_stmt 0 view .LVU137
 624 0028 0E94 0000 		call is_oneshot_layer_active
 625               	.LVL58:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 626               		.loc 1 241 9 view .LVU138
 627 002c D82E      		mov r13,r24
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 628               		.loc 1 241 8 view .LVU139
 629 002e 8823      		tst r24
 630 0030 01F0      		breq .L38
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 631               		.loc 1 241 35 discriminator 1 view .LVU140
 632 0032 1123      		tst r17
 633 0034 01F0      		breq .L114
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 634               		.loc 1 241 71 discriminator 2 view .LVU141
 635 0036 8C2F      		mov r24,r28
 636 0038 807F      		andi r24,lo8(-16)
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 637               		.loc 1 241 52 discriminator 2 view .LVU142
 638 003a 8034      		cpi r24,lo8(64)
 639 003c 01F0      		breq .L39
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 640               		.loc 1 241 87 discriminator 3 view .LVU143
 641 003e 80E2      		ldi r24,lo8(32)
 642               	.LVL59:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 643               		.loc 1 241 87 discriminator 3 view .LVU144
 644 0040 8D0F      		add r24,r29
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 645               		.loc 1 241 84 discriminator 3 view .LVU145
 646 0042 8830      		cpi r24,lo8(8)
 647 0044 00F0      		brlo .L114
 648               	.L39:
 246:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 649               		.loc 1 246 9 is_stmt 1 view .LVU146
 650 0046 82E0      		ldi r24,lo8(2)
 651 0048 0E94 0000 		call clear_oneshot_layer_state
 652               	.LVL60:
 247:tmk_core/common/action.c ****     }
 653               		.loc 1 247 9 view .LVU147
 247:tmk_core/common/action.c ****     }
 654               		.loc 1 247 31 is_stmt 0 view .LVU148
 655 004c 0E94 0000 		call is_oneshot_layer_active
 656               	.LVL61:
 247:tmk_core/common/action.c ****     }
 657               		.loc 1 247 9 view .LVU149
 658 0050 91E0      		ldi r25,lo8(1)
 659 0052 D82E      		mov r13,r24
 660 0054 D926      		eor r13,r25
 661               	.LVL62:
 662               	.L38:
 251:tmk_core/common/action.c ****         /* Key and Mods */
 663               		.loc 1 251 5 is_stmt 1 view .LVU150
 251:tmk_core/common/action.c ****         /* Key and Mods */
 664               		.loc 1 251 24 is_stmt 0 view .LVU151
 665 0056 CC2E      		mov r12,r28
 666 0058 C294      		swap r12
 667 005a 9FE0      		ldi r25,lo8(15)
 668 005c C922      		and r12,r25
 251:tmk_core/common/action.c ****         /* Key and Mods */
 669               		.loc 1 251 5 view .LVU152
 670 005e FBE0      		ldi r31,lo8(11)
 671 0060 FC15      		cp r31,r12
 672 0062 00F0      		brlo .L40
 673 0064 EC2D      		mov r30,r12
 674 0066 F0E0      		ldi r31,0
 675 0068 E050      		subi r30,lo8(-(gs(.L42)))
 676 006a F040      		sbci r31,hi8(-(gs(.L42)))
 677 006c 0C94 0000 		jmp __tablejump2__
 678               		.section	.jumptables.gcc.process_action,"a",@progbits
 679               		.p2align	1
 680               	.L42:
 681 0000 0000      		.word gs(.L48)
 682 0002 0000      		.word gs(.L48)
 683 0004 0000      		.word gs(.L47)
 684 0006 0000      		.word gs(.L47)
 685 0008 0000      		.word gs(.L46)
 686 000a 0000      		.word gs(.L45)
 687 000c 0000      		.word gs(.L40)
 688 000e 0000      		.word gs(.L40)
 689 0010 0000      		.word gs(.L44)
 690 0012 0000      		.word gs(.L43)
 691 0014 0000      		.word gs(.L41)
 692 0016 0000      		.word gs(.L41)
 693               		.section	.text.process_action
 694               	.LVL63:
 695               	.L114:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 696               		.loc 1 239 10 view .LVU153
 697 0070 D12C      		mov r13,__zero_reg__
 698 0072 00C0      		rjmp .L38
 699               	.LVL64:
 700               	.L48:
 701               	.LBB26:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 702               		.loc 1 255 13 is_stmt 1 view .LVU154
 703 0074 0C2F      		mov r16,r28
 704               	.LVL65:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 705               		.loc 1 255 13 is_stmt 0 view .LVU155
 706 0076 0F70      		andi r16,lo8(15)
 255:tmk_core/common/action.c ****             if (event.pressed) {
 707               		.loc 1 255 44 view .LVU156
 708 0078 C07F      		andi r28,lo8(-16)
 709               	.LVL66:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 710               		.loc 1 255 21 view .LVU157
 711 007a 01F0      		breq .L49
 255:tmk_core/common/action.c ****             if (event.pressed) {
 712               		.loc 1 255 21 discriminator 2 view .LVU158
 713 007c 0295      		swap r16
 714 007e 007F      		andi r16,lo8(-16)
 715               	.L49:
 716               	.LVL67:
 256:tmk_core/common/action.c ****                 if (mods) {
 717               		.loc 1 256 13 is_stmt 1 discriminator 4 view .LVU159
 256:tmk_core/common/action.c ****                 if (mods) {
 718               		.loc 1 256 16 is_stmt 0 discriminator 4 view .LVU160
 719 0080 1123      		tst r17
 720 0082 01F0      		breq .L50
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 721               		.loc 1 257 17 is_stmt 1 view .LVU161
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 722               		.loc 1 257 20 is_stmt 0 view .LVU162
 723 0084 0023      		tst r16
 724 0086 01F0      		breq .L148
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 725               		.loc 1 258 21 is_stmt 1 view .LVU163
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 726               		.loc 1 258 25 is_stmt 0 view .LVU164
 727 0088 80E2      		ldi r24,lo8(32)
 728 008a 8D0F      		add r24,r29
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 729               		.loc 1 258 24 view .LVU165
 730 008c 8830      		cpi r24,lo8(8)
 731 008e 00F0      		brlo .L52
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 732               		.loc 1 258 49 discriminator 1 view .LVU166
 733 0090 D111      		cpse r29,__zero_reg__
 734 0092 00C0      		rjmp .L53
 735               	.L52:
 262:tmk_core/common/action.c ****                     } else {
 736               		.loc 1 262 25 is_stmt 1 view .LVU167
 737 0094 802F      		mov r24,r16
 738 0096 0E94 0000 		call add_mods
 739               	.LVL68:
 740               	.L54:
 266:tmk_core/common/action.c ****                 }
 741               		.loc 1 266 21 view .LVU168
 742 009a 0E94 0000 		call send_keyboard_report
 743               	.LVL69:
 268:tmk_core/common/action.c ****             } else {
 744               		.loc 1 268 17 view .LVU169
 745               	.L148:
 268:tmk_core/common/action.c ****             } else {
 746               		.loc 1 268 17 is_stmt 0 view .LVU170
 747               	.LBE26:
 565:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 748               		.loc 1 565 75 is_stmt 1 view .LVU171
 566:tmk_core/common/action.c ****                         } else {
 749               		.loc 1 566 29 view .LVU172
 750 009e 8D2F      		mov r24,r29
 751 00a0 0E94 0000 		call register_code
 752               	.LVL70:
 753 00a4 00C0      		rjmp .L40
 754               	.LVL71:
 755               	.L53:
 756               	.LBB27:
 264:tmk_core/common/action.c ****                     }
 757               		.loc 1 264 25 view .LVU173
 758 00a6 802F      		mov r24,r16
 759 00a8 0E94 0000 		call add_weak_mods
 760               	.LVL72:
 761 00ac 00C0      		rjmp .L54
 762               	.L50:
 270:tmk_core/common/action.c ****                 if (mods) {
 763               		.loc 1 270 17 view .LVU174
 764 00ae 8D2F      		mov r24,r29
 765 00b0 0E94 0000 		call unregister_code
 766               	.LVL73:
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 767               		.loc 1 271 17 view .LVU175
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 768               		.loc 1 271 20 is_stmt 0 view .LVU176
 769 00b4 0023      		tst r16
 770 00b6 01F0      		breq .L40
 272:tmk_core/common/action.c ****                         del_mods(mods);
 771               		.loc 1 272 21 is_stmt 1 view .LVU177
 272:tmk_core/common/action.c ****                         del_mods(mods);
 772               		.loc 1 272 25 is_stmt 0 view .LVU178
 773 00b8 80E2      		ldi r24,lo8(32)
 774 00ba 8D0F      		add r24,r29
 272:tmk_core/common/action.c ****                         del_mods(mods);
 775               		.loc 1 272 24 view .LVU179
 776 00bc 8830      		cpi r24,lo8(8)
 777 00be 00F0      		brlo .L56
 272:tmk_core/common/action.c ****                         del_mods(mods);
 778               		.loc 1 272 49 discriminator 1 view .LVU180
 779 00c0 D111      		cpse r29,__zero_reg__
 780 00c2 00C0      		rjmp .L57
 781               	.L56:
 273:tmk_core/common/action.c ****                     } else {
 782               		.loc 1 273 25 is_stmt 1 view .LVU181
 783 00c4 802F      		mov r24,r16
 784 00c6 0E94 0000 		call del_mods
 785               	.LVL74:
 786               	.L58:
 277:tmk_core/common/action.c ****                 }
 787               		.loc 1 277 21 view .LVU182
 788 00ca 0E94 0000 		call send_keyboard_report
 789               	.LVL75:
 790               	.L40:
 277:tmk_core/common/action.c ****                 }
 791               		.loc 1 277 21 is_stmt 0 view .LVU183
 792               	.LBE27:
 680:tmk_core/common/action.c ****         case ACT_LAYER:
 793               		.loc 1 680 5 is_stmt 1 view .LVU184
 794 00ce EC2D      		mov r30,r12
 795 00d0 E850      		subi r30,8
 796 00d2 FF0B      		sbc r31,r31
 797 00d4 3497      		sbiw r30,4
 798 00d6 00F4      		brsh .L109
 687:tmk_core/common/action.c ****             break;
 799               		.loc 1 687 13 view .LVU185
 800 00d8 0E94 0000 		call host_keyboard_leds
 801               	.LVL76:
 802 00dc 0E94 0000 		call led_set
 803               	.LVL77:
 688:tmk_core/common/action.c ****         default:
 804               		.loc 1 688 13 view .LVU186
 805               	.L109:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 806               		.loc 1 730 5 view .LVU187
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 807               		.loc 1 730 8 is_stmt 0 view .LVU188
 808 00e0 DD20      		tst r13
 809 00e2 01F4      		brne .+2
 810 00e4 00C0      		rjmp .L36
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 811               		.loc 1 730 33 discriminator 1 view .LVU189
 812 00e6 0E94 0000 		call get_oneshot_layer_state
 813               	.LVL78:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 814               		.loc 1 730 28 discriminator 1 view .LVU190
 815 00ea 80FD      		sbrc r24,0
 816 00ec 00C0      		rjmp .L36
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 817               		.loc 1 731 9 is_stmt 1 view .LVU191
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 818               		.loc 1 731 31 is_stmt 0 view .LVU192
 819 00ee F701      		movw r30,r14
 820 00f0 1282      		std Z+2,__zero_reg__
 732:tmk_core/common/action.c ****         process_record(record);
 821               		.loc 1 732 9 is_stmt 1 view .LVU193
 822 00f2 0E94 0000 		call get_oneshot_layer
 823               	.LVL79:
 824 00f6 0E94 0000 		call layer_on
 825               	.LVL80:
 733:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 826               		.loc 1 733 9 view .LVU194
 827 00fa C701      		movw r24,r14
 828 00fc 0E94 0000 		call process_record
 829               	.LVL81:
 734:tmk_core/common/action.c ****     }
 830               		.loc 1 734 9 view .LVU195
 831 0100 0E94 0000 		call get_oneshot_layer
 832               	.LVL82:
 833               	/* epilogue start */
 737:tmk_core/common/action.c **** 
 834               		.loc 1 737 1 is_stmt 0 view .LVU196
 835 0104 DF91      		pop r29
 836               	.LVL83:
 737:tmk_core/common/action.c **** 
 837               		.loc 1 737 1 view .LVU197
 838 0106 CF91      		pop r28
 737:tmk_core/common/action.c **** 
 839               		.loc 1 737 1 view .LVU198
 840 0108 1F91      		pop r17
 841 010a 0F91      		pop r16
 842 010c FF90      		pop r15
 843 010e EF90      		pop r14
 844               	.LVL84:
 737:tmk_core/common/action.c **** 
 845               		.loc 1 737 1 view .LVU199
 846 0110 DF90      		pop r13
 847               	.LVL85:
 737:tmk_core/common/action.c **** 
 848               		.loc 1 737 1 view .LVU200
 849 0112 CF90      		pop r12
 850 0114 BF90      		pop r11
 734:tmk_core/common/action.c ****     }
 851               		.loc 1 734 9 view .LVU201
 852 0116 0C94 0000 		jmp layer_off
 853               	.LVL86:
 854               	.L57:
 855               	.LBB28:
 275:tmk_core/common/action.c ****                     }
 856               		.loc 1 275 25 is_stmt 1 view .LVU202
 857 011a 802F      		mov r24,r16
 858 011c 0E94 0000 		call del_weak_mods
 859               	.LVL87:
 860 0120 00C0      		rjmp .L58
 861               	.LVL88:
 862               	.L47:
 275:tmk_core/common/action.c ****                     }
 863               		.loc 1 275 25 is_stmt 0 view .LVU203
 864               	.LBE28:
 865               	.LBB29:
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 866               		.loc 1 284 13 is_stmt 1 view .LVU204
 867 0122 2C2F      		mov r18,r28
 868 0124 2F70      		andi r18,lo8(15)
 869 0126 B22E      		mov r11,r18
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 870               		.loc 1 284 44 is_stmt 0 view .LVU205
 871 0128 C07F      		andi r28,lo8(-16)
 872               	.LVL89:
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 873               		.loc 1 284 21 view .LVU206
 874 012a C032      		cpi r28,lo8(32)
 875 012c 01F0      		breq .L59
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 876               		.loc 1 284 21 discriminator 2 view .LVU207
 877 012e B294      		swap r11
 878 0130 80EF      		ldi r24,lo8(-16)
 879 0132 B822      		and r11,r24
 880               	.L59:
 881               	.LVL90:
 285:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 882               		.loc 1 285 13 is_stmt 1 discriminator 4 view .LVU208
 883 0134 DD23      		tst r29
 884 0136 01F0      		breq .L60
 885 0138 D130      		cpi r29,lo8(1)
 886 013a 01F0      		breq .L61
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 887               		.loc 1 340 21 view .LVU209
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 888               		.loc 1 340 24 is_stmt 0 view .LVU210
 889 013c 1123      		tst r17
 890 013e 01F0      		breq .L69
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 891               		.loc 1 341 25 is_stmt 1 view .LVU211
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 892               		.loc 1 341 28 is_stmt 0 view .LVU212
 893 0140 0023      		tst r16
 894 0142 01F0      		breq .L70
 895 0144 00C0      		rjmp .L148
 896               	.L60:
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 897               		.loc 1 289 21 is_stmt 1 view .LVU213
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 898               		.loc 1 289 24 is_stmt 0 view .LVU214
 899 0146 1123      		tst r17
 900 0148 01F0      		breq .L63
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 901               		.loc 1 290 25 is_stmt 1 view .LVU215
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 902               		.loc 1 290 28 is_stmt 0 view .LVU216
 903 014a 0111      		cpse r16,__zero_reg__
 904 014c 00C0      		rjmp .L64
 905               	.L65:
 304:tmk_core/common/action.c ****                         }
 906               		.loc 1 304 29 is_stmt 1 view .LVU217
 304:tmk_core/common/action.c ****                         }
 907               		.loc 1 304 50 is_stmt 0 view .LVU218
 908 014e 0E94 0000 		call get_oneshot_mods
 909               	.LVL91:
 304:tmk_core/common/action.c ****                         }
 910               		.loc 1 304 29 view .LVU219
 911 0152 8B29      		or r24,r11
 912               	.LVL92:
 913               	.L147:
 304:tmk_core/common/action.c ****                         }
 914               		.loc 1 304 29 view .LVU220
 915               	.LBE29:
 492:tmk_core/common/action.c ****             } else {
 916               		.loc 1 492 17 view .LVU221
 917 0154 0E94 0000 		call register_mods
 918               	.LVL93:
 919 0158 00C0      		rjmp .L40
 920               	.LVL94:
 921               	.L64:
 922               	.LBB32:
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 923               		.loc 1 293 32 is_stmt 1 view .LVU222
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 924               		.loc 1 293 35 is_stmt 0 view .LVU223
 925 015a 0130      		cpi r16,lo8(1)
 926 015c 01F4      		brne .L65
 294:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 927               		.loc 1 294 65 is_stmt 1 view .LVU224
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 928               		.loc 1 295 29 view .LVU225
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 929               		.loc 1 295 53 is_stmt 0 view .LVU226
 930 015e 0E94 0000 		call get_oneshot_mods
 931               	.LVL95:
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 932               		.loc 1 295 29 view .LVU227
 933 0162 8B29      		or r24,r11
 934 0164 0E94 0000 		call set_oneshot_mods
 935               	.LVL96:
 936 0168 00C0      		rjmp .L40
 937               	.L63:
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 938               		.loc 1 307 25 is_stmt 1 view .LVU228
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 939               		.loc 1 307 28 is_stmt 0 view .LVU229
 940 016a 0111      		cpse r16,__zero_reg__
 941 016c 00C0      		rjmp .L66
 942               	.L150:
 322:tmk_core/common/action.c ****                             unregister_mods(mods);
 943               		.loc 1 322 29 is_stmt 1 view .LVU230
 944 016e 0E94 0000 		call clear_oneshot_mods
 945               	.LVL97:
 323:tmk_core/common/action.c ****                         }
 946               		.loc 1 323 29 view .LVU231
 947               	.L71:
 372:tmk_core/common/action.c ****                             unregister_mods(mods);
 948               		.loc 1 372 67 view .LVU232
 373:tmk_core/common/action.c ****                         }
 949               		.loc 1 373 29 view .LVU233
 950 0172 8B2D      		mov r24,r11
 951 0174 0E94 0000 		call unregister_mods
 952               	.LVL98:
 953 0178 00C0      		rjmp .L40
 954               	.L66:
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 955               		.loc 1 310 32 view .LVU234
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 956               		.loc 1 310 35 is_stmt 0 view .LVU235
 957 017a 0130      		cpi r16,lo8(1)
 958 017c 01F4      		brne .+2
 959 017e 00C0      		rjmp .L40
 960 0180 00C0      		rjmp .L150
 961               	.L61:
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 962               		.loc 1 329 21 is_stmt 1 view .LVU236
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 963               		.loc 1 329 24 is_stmt 0 view .LVU237
 964 0182 1123      		tst r17
 965 0184 01F0      		breq .L68
 330:tmk_core/common/action.c ****                             register_mods(mods);
 966               		.loc 1 330 25 is_stmt 1 view .LVU238
 330:tmk_core/common/action.c ****                             register_mods(mods);
 967               		.loc 1 330 28 is_stmt 0 view .LVU239
 968 0186 0630      		cpi r16,lo8(6)
 969 0188 00F0      		brlo .+2
 970 018a 00C0      		rjmp .L40
 971               	.L70:
 359:tmk_core/common/action.c ****                             register_mods(mods);
 972               		.loc 1 359 67 is_stmt 1 view .LVU240
 360:tmk_core/common/action.c ****                         }
 973               		.loc 1 360 29 view .LVU241
 974 018c 8B2D      		mov r24,r11
 975 018e 00C0      		rjmp .L147
 976               	.L68:
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 977               		.loc 1 334 25 view .LVU242
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 978               		.loc 1 334 28 is_stmt 0 view .LVU243
 979 0190 0530      		cpi r16,lo8(5)
 980 0192 00F0      		brlo .+2
 981 0194 00C0      		rjmp .L40
 982 0196 00C0      		rjmp .L71
 983               	.L69:
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 984               		.loc 1 363 25 is_stmt 1 view .LVU244
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 985               		.loc 1 363 28 is_stmt 0 view .LVU245
 986 0198 0023      		tst r16
 987 019a 01F0      		breq .L71
 364:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 988               		.loc 1 364 71 is_stmt 1 view .LVU246
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 989               		.loc 1 365 29 view .LVU247
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 990               		.loc 1 365 32 is_stmt 0 view .LVU248
 991 019c D933      		cpi r29,lo8(57)
 992 019e 01F4      		brne .L108
 366:tmk_core/common/action.c ****                             } else {
 993               		.loc 1 366 33 is_stmt 1 view .LVU249
 994               	.LVL99:
 995               	.LBB30:
 996               	.LBI30:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 997               		.loc 3 166 1 view .LVU250
 998               	.LBB31:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 999               		.loc 3 168 2 view .LVU251
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1000               		.loc 3 172 2 view .LVU252
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1001               		.loc 3 173 2 view .LVU253
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 1002               		.loc 3 174 2 view .LVU254
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 1003               		.loc 3 184 3 view .LVU255
 1004               		.loc 3 187 2 view .LVU256
 1005 01a0 3FEF      		ldi r19,lo8(255999)
 1006 01a2 87EE      		ldi r24,hi8(255999)
 1007 01a4 93E0      		ldi r25,hlo8(255999)
 1008 01a6 3150      	1:	subi r19,1
 1009 01a8 8040      		sbci r24,0
 1010 01aa 9040      		sbci r25,0
 1011 01ac 01F4      		brne 1b
 1012               	.LVL100:
 1013               	.L151:
 1014               		.loc 3 187 2 is_stmt 0 view .LVU257
 1015               	.LBE31:
 1016               	.LBE30:
 1017               	.LBE32:
 1018               	.LBB33:
 1019               	.LBB34:
 1020 01ae 00C0      		rjmp .
 1021 01b0 0000      		nop
 1022               	.L108:
 1023               	.LBE34:
 1024               	.LBE33:
 579:tmk_core/common/action.c ****                         } else {
 1025               		.loc 1 579 29 is_stmt 1 view .LVU258
 1026 01b2 8D2F      		mov r24,r29
 1027 01b4 0E94 0000 		call unregister_code
 1028               	.LVL101:
 1029 01b8 00C0      		rjmp .L40
 1030               	.L46:
 383:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1031               		.loc 1 383 13 view .LVU259
 383:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1032               		.loc 1 383 33 is_stmt 0 view .LVU260
 1033 01ba 8C2F      		mov r24,r28
 1034 01bc 8695      		lsr r24
 1035 01be 8695      		lsr r24
 1036 01c0 8370      		andi r24,lo8(3)
 1037 01c2 01F0      		breq .L74
 1038 01c4 8130      		cpi r24,lo8(1)
 1039 01c6 01F0      		breq .+2
 1040 01c8 00C0      		rjmp .L40
 392:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1041               		.loc 1 392 21 is_stmt 1 view .LVU261
 393:tmk_core/common/action.c ****                     } else {
 1042               		.loc 1 393 25 is_stmt 0 view .LVU262
 1043 01ca 8D2F      		mov r24,r29
 1044 01cc 9C2F      		mov r25,r28
 1045 01ce 9370      		andi r25,lo8(3)
 392:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1046               		.loc 1 392 24 view .LVU263
 1047 01d0 1111      		cpse r17,__zero_reg__
 1048 01d2 00C0      		rjmp .L149
 395:tmk_core/common/action.c ****                     }
 1049               		.loc 1 395 25 is_stmt 1 view .LVU264
 1050 01d4 90E0      		ldi r25,0
 1051 01d6 80E0      		ldi r24,0
 1052               	.L149:
 1053 01d8 0E94 0000 		call host_consumer_send
 1054               	.LVL102:
 1055 01dc 00C0      		rjmp .L40
 1056               	.L74:
 385:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1057               		.loc 1 385 21 view .LVU265
 386:tmk_core/common/action.c ****                     } else {
 1058               		.loc 1 386 25 is_stmt 0 view .LVU266
 1059 01de 8D2F      		mov r24,r29
 1060 01e0 9C2F      		mov r25,r28
 1061 01e2 9370      		andi r25,lo8(3)
 385:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1062               		.loc 1 385 24 view .LVU267
 1063 01e4 1111      		cpse r17,__zero_reg__
 1064 01e6 00C0      		rjmp .L143
 388:tmk_core/common/action.c ****                     }
 1065               		.loc 1 388 25 is_stmt 1 view .LVU268
 1066 01e8 90E0      		ldi r25,0
 1067 01ea 80E0      		ldi r24,0
 1068               	.L143:
 1069 01ec 0E94 0000 		call host_system_send
 1070               	.LVL103:
 1071 01f0 00C0      		rjmp .L40
 1072               	.L45:
 404:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1073               		.loc 1 404 13 view .LVU269
 405:tmk_core/common/action.c ****                 switch (action.key.code) {
 1074               		.loc 1 405 17 is_stmt 0 view .LVU270
 1075 01f2 8D2F      		mov r24,r29
 404:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1076               		.loc 1 404 16 view .LVU271
 1077 01f4 1123      		tst r17
 1078 01f6 01F0      		breq .L78
 405:tmk_core/common/action.c ****                 switch (action.key.code) {
 1079               		.loc 1 405 17 is_stmt 1 view .LVU272
 1080 01f8 0E94 0000 		call mousekey_on
 1081               	.LVL104:
 406:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 1082               		.loc 1 406 17 view .LVU273
 419:tmk_core/common/action.c ****                         break;
 1083               		.loc 1 419 25 view .LVU274
 1084               	.L144:
 424:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 1085               		.loc 1 424 17 view .LVU275
 437:tmk_core/common/action.c ****                         break;
 1086               		.loc 1 437 25 view .LVU276
 1087 01fc 0E94 0000 		call mousekey_send
 1088               	.LVL105:
 438:tmk_core/common/action.c ****                 }
 1089               		.loc 1 438 25 view .LVU277
 1090 0200 00C0      		rjmp .L40
 1091               	.L78:
 423:tmk_core/common/action.c ****                 switch (action.key.code) {
 1092               		.loc 1 423 17 view .LVU278
 1093 0202 0E94 0000 		call mousekey_off
 1094               	.LVL106:
 1095 0206 00C0      		rjmp .L144
 1096               	.L44:
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1097               		.loc 1 445 13 view .LVU279
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1098               		.loc 1 445 39 is_stmt 0 view .LVU280
 1099 0208 8C2F      		mov r24,r28
 1100 020a 8370      		andi r24,lo8(3)
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1101               		.loc 1 445 16 view .LVU281
 1102 020c 01F0      		breq .+2
 1103 020e 00C0      		rjmp .L79
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1104               		.loc 1 447 17 is_stmt 1 view .LVU282
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1105               		.loc 1 447 20 is_stmt 0 view .LVU283
 1106 0210 1111      		cpse r17,__zero_reg__
 1107 0212 00C0      		rjmp .L40
 1108               	.LBB36:
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1109               		.loc 1 448 21 is_stmt 1 view .LVU284
 1110               	.LVL107:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1111               		.loc 1 449 21 view .LVU285
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1112               		.loc 1 448 61 is_stmt 0 view .LVU286
 1113 0214 4D2F      		mov r20,r29
 1114 0216 4295      		swap r20
 1115 0218 4695      		lsr r20
 1116 021a 4770      		andi r20,lo8(7)
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1117               		.loc 1 448 35 view .LVU287
 1118 021c 440F      		lsl r20
 1119 021e 440F      		lsl r20
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1120               		.loc 1 449 77 view .LVU288
 1121 0220 0D2F      		mov r16,r29
 1122               	.LVL108:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1123               		.loc 1 449 77 view .LVU289
 1124 0222 0F70      		andi r16,lo8(15)
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1125               		.loc 1 449 44 view .LVU290
 1126 0224 10E0      		ldi r17,0
 1127               	.LVL109:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1128               		.loc 1 449 44 view .LVU291
 1129 0226 30E0      		ldi r19,0
 1130 0228 20E0      		ldi r18,0
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1131               		.loc 1 449 35 view .LVU292
 1132 022a 042E      		mov r0,r20
 1133 022c 00C0      		rjmp 2f
 1134               		1:
 1135 022e 000F      		lsl r16
 1136 0230 111F      		rol r17
 1137 0232 221F      		rol r18
 1138 0234 331F      		rol r19
 1139               		2:
 1140 0236 0A94      		dec r0
 1141 0238 02F4      		brpl 1b
 1142               	.LVL110:
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1143               		.loc 1 450 21 is_stmt 1 view .LVU293
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1144               		.loc 1 450 104 is_stmt 0 view .LVU294
 1145 023a 60E0      		ldi r22,0
 1146 023c 70E0      		ldi r23,0
 1147 023e CB01      		movw r24,r22
 1148 0240 D4FF      		sbrs r29,4
 1149 0242 00C0      		rjmp .L80
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1150               		.loc 1 450 94 discriminator 1 view .LVU295
 1151 0244 6FE0      		ldi r22,lo8(15)
 1152 0246 70E0      		ldi r23,0
 1153 0248 80E0      		ldi r24,0
 1154 024a 90E0      		ldi r25,0
 1155 024c 00C0      		rjmp 2f
 1156               		1:
 1157 024e 660F      		lsl r22
 1158 0250 771F      		rol r23
 1159 0252 881F      		rol r24
 1160 0254 991F      		rol r25
 1161               		2:
 1162 0256 4A95      		dec r20
 1163 0258 02F4      		brpl 1b
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1164               		.loc 1 450 104 discriminator 1 view .LVU296
 1165 025a 6095      		com r22
 1166 025c 7095      		com r23
 1167 025e 8095      		com r24
 1168 0260 9095      		com r25
 1169               	.L80:
 1170               	.LVL111:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1171               		.loc 1 451 21 is_stmt 1 discriminator 4 view .LVU297
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1172               		.loc 1 451 47 is_stmt 0 discriminator 4 view .LVU298
 1173 0262 C695      		lsr r28
 1174 0264 C695      		lsr r28
 1175               	.LVL112:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1176               		.loc 1 451 47 discriminator 4 view .LVU299
 1177 0266 C370      		andi r28,lo8(3)
 1178 0268 602B      		or r22,r16
 1179               	.LVL113:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1180               		.loc 1 451 47 discriminator 4 view .LVU300
 1181 026a 712B      		or r23,r17
 1182 026c 822B      		or r24,r18
 1183 026e 932B      		or r25,r19
 1184 0270 C230      		cpi r28,lo8(2)
 1185 0272 01F0      		breq .L81
 1186 0274 00F4      		brsh .L82
 1187 0276 C130      		cpi r28,lo8(1)
 1188 0278 01F0      		breq .L83
 453:tmk_core/common/action.c ****                             break;
 1189               		.loc 1 453 29 is_stmt 1 view .LVU301
 1190 027a 0E94 0000 		call default_layer_and
 1191               	.LVL114:
 454:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1192               		.loc 1 454 29 view .LVU302
 1193 027e 00C0      		rjmp .L40
 1194               	.L83:
 456:tmk_core/common/action.c ****                             break;
 1195               		.loc 1 456 29 view .LVU303
 1196 0280 0E94 0000 		call default_layer_or
 1197               	.LVL115:
 457:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1198               		.loc 1 457 29 view .LVU304
 1199 0284 00C0      		rjmp .L40
 1200               	.L81:
 459:tmk_core/common/action.c ****                             break;
 1201               		.loc 1 459 29 view .LVU305
 1202 0286 0E94 0000 		call default_layer_xor
 1203               	.LVL116:
 460:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1204               		.loc 1 460 29 view .LVU306
 1205 028a 00C0      		rjmp .L40
 1206               	.L82:
 462:tmk_core/common/action.c ****                             break;
 1207               		.loc 1 462 29 view .LVU307
 1208 028c 0E94 0000 		call default_layer_set
 1209               	.LVL117:
 463:tmk_core/common/action.c ****                     }
 1210               		.loc 1 463 29 view .LVU308
 1211 0290 00C0      		rjmp .L40
 1212               	.LVL118:
 1213               	.L79:
 463:tmk_core/common/action.c ****                     }
 1214               		.loc 1 463 29 is_stmt 0 view .LVU309
 1215               	.LBE36:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1216               		.loc 1 468 17 is_stmt 1 view .LVU310
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1217               		.loc 1 468 21 is_stmt 0 view .LVU311
 1218 0292 8695      		lsr r24
 1219 0294 1123      		tst r17
 1220 0296 01F0      		breq .L85
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1221               		.loc 1 468 21 discriminator 1 view .LVU312
 1222 0298 8C2F      		mov r24,r28
 1223 029a 8170      		andi r24,lo8(1)
 1224               	.L85:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1225               		.loc 1 468 20 discriminator 4 view .LVU313
 1226 029c 8823      		tst r24
 1227 029e 01F4      		brne .+2
 1228 02a0 00C0      		rjmp .L40
 1229               	.LBB37:
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1230               		.loc 1 469 21 is_stmt 1 view .LVU314
 1231               	.LVL119:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1232               		.loc 1 470 21 view .LVU315
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1233               		.loc 1 469 61 is_stmt 0 view .LVU316
 1234 02a2 4D2F      		mov r20,r29
 1235 02a4 4295      		swap r20
 1236 02a6 4695      		lsr r20
 1237 02a8 4770      		andi r20,lo8(7)
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1238               		.loc 1 469 35 view .LVU317
 1239 02aa 440F      		lsl r20
 1240 02ac 440F      		lsl r20
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1241               		.loc 1 470 77 view .LVU318
 1242 02ae 0D2F      		mov r16,r29
 1243               	.LVL120:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1244               		.loc 1 470 77 view .LVU319
 1245 02b0 0F70      		andi r16,lo8(15)
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1246               		.loc 1 470 44 view .LVU320
 1247 02b2 10E0      		ldi r17,0
 1248               	.LVL121:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1249               		.loc 1 470 44 view .LVU321
 1250 02b4 30E0      		ldi r19,0
 1251 02b6 20E0      		ldi r18,0
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1252               		.loc 1 470 35 view .LVU322
 1253 02b8 042E      		mov r0,r20
 1254 02ba 00C0      		rjmp 2f
 1255               		1:
 1256 02bc 000F      		lsl r16
 1257 02be 111F      		rol r17
 1258 02c0 221F      		rol r18
 1259 02c2 331F      		rol r19
 1260               		2:
 1261 02c4 0A94      		dec r0
 1262 02c6 02F4      		brpl 1b
 1263               	.LVL122:
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1264               		.loc 1 471 21 is_stmt 1 view .LVU323
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1265               		.loc 1 471 104 is_stmt 0 view .LVU324
 1266 02c8 60E0      		ldi r22,0
 1267 02ca 70E0      		ldi r23,0
 1268 02cc CB01      		movw r24,r22
 1269 02ce D4FF      		sbrs r29,4
 1270 02d0 00C0      		rjmp .L86
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1271               		.loc 1 471 94 discriminator 1 view .LVU325
 1272 02d2 6FE0      		ldi r22,lo8(15)
 1273 02d4 70E0      		ldi r23,0
 1274 02d6 80E0      		ldi r24,0
 1275 02d8 90E0      		ldi r25,0
 1276 02da 00C0      		rjmp 2f
 1277               		1:
 1278 02dc 660F      		lsl r22
 1279 02de 771F      		rol r23
 1280 02e0 881F      		rol r24
 1281 02e2 991F      		rol r25
 1282               		2:
 1283 02e4 4A95      		dec r20
 1284 02e6 02F4      		brpl 1b
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1285               		.loc 1 471 104 discriminator 1 view .LVU326
 1286 02e8 6095      		com r22
 1287 02ea 7095      		com r23
 1288 02ec 8095      		com r24
 1289 02ee 9095      		com r25
 1290               	.L86:
 1291               	.LVL123:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1292               		.loc 1 472 21 is_stmt 1 discriminator 4 view .LVU327
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1293               		.loc 1 472 47 is_stmt 0 discriminator 4 view .LVU328
 1294 02f0 C695      		lsr r28
 1295 02f2 C695      		lsr r28
 1296               	.LVL124:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1297               		.loc 1 472 47 discriminator 4 view .LVU329
 1298 02f4 C370      		andi r28,lo8(3)
 1299 02f6 602B      		or r22,r16
 1300               	.LVL125:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1301               		.loc 1 472 47 discriminator 4 view .LVU330
 1302 02f8 712B      		or r23,r17
 1303 02fa 822B      		or r24,r18
 1304 02fc 932B      		or r25,r19
 1305 02fe C230      		cpi r28,lo8(2)
 1306 0300 01F0      		breq .L87
 1307 0302 00F4      		brsh .L88
 1308 0304 C130      		cpi r28,lo8(1)
 1309 0306 01F0      		breq .L89
 474:tmk_core/common/action.c ****                             break;
 1310               		.loc 1 474 29 is_stmt 1 view .LVU331
 1311 0308 0E94 0000 		call layer_and
 1312               	.LVL126:
 475:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1313               		.loc 1 475 29 view .LVU332
 1314 030c 00C0      		rjmp .L40
 1315               	.L89:
 477:tmk_core/common/action.c ****                             break;
 1316               		.loc 1 477 29 view .LVU333
 1317 030e 0E94 0000 		call layer_or
 1318               	.LVL127:
 478:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1319               		.loc 1 478 29 view .LVU334
 1320 0312 00C0      		rjmp .L40
 1321               	.L87:
 480:tmk_core/common/action.c ****                             break;
 1322               		.loc 1 480 29 view .LVU335
 1323 0314 0E94 0000 		call layer_xor
 1324               	.LVL128:
 481:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1325               		.loc 1 481 29 view .LVU336
 1326 0318 00C0      		rjmp .L40
 1327               	.L88:
 483:tmk_core/common/action.c ****                             break;
 1328               		.loc 1 483 29 view .LVU337
 1329 031a 0E94 0000 		call layer_state_set
 1330               	.LVL129:
 484:tmk_core/common/action.c ****                     }
 1331               		.loc 1 484 29 view .LVU338
 1332 031e 00C0      		rjmp .L40
 1333               	.LVL130:
 1334               	.L43:
 484:tmk_core/common/action.c ****                     }
 1335               		.loc 1 484 29 is_stmt 0 view .LVU339
 1336               	.LBE37:
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1337               		.loc 1 490 13 is_stmt 1 view .LVU340
 1338 0320 CF70      		andi r28,lo8(15)
 1339               	.LVL131:
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1340               		.loc 1 490 16 is_stmt 0 view .LVU341
 1341 0322 1123      		tst r17
 1342 0324 01F0      		breq .L90
 491:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1343               		.loc 1 491 17 is_stmt 1 view .LVU342
 1344 0326 8C2F      		mov r24,r28
 1345 0328 0E94 0000 		call layer_on
 1346               	.LVL132:
 492:tmk_core/common/action.c ****             } else {
 1347               		.loc 1 492 17 view .LVU343
 1348 032c 8D2F      		mov r24,r29
 1349 032e 00C0      		rjmp .L147
 1350               	.L90:
 494:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1351               		.loc 1 494 17 view .LVU344
 1352 0330 8D2F      		mov r24,r29
 1353 0332 0E94 0000 		call unregister_mods
 1354               	.LVL133:
 495:tmk_core/common/action.c ****             }
 1355               		.loc 1 495 17 view .LVU345
 1356 0336 8C2F      		mov r24,r28
 1357               	.LVL134:
 1358               	.L142:
 582:tmk_core/common/action.c ****                         }
 1359               		.loc 1 582 29 is_stmt 0 view .LVU346
 1360 0338 0E94 0000 		call layer_off
 1361               	.LVL135:
 1362 033c 00C0      		rjmp .L40
 1363               	.L41:
 501:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1364               		.loc 1 501 13 is_stmt 1 view .LVU347
 1365 033e D23F      		cpi r29,lo8(-14)
 1366 0340 01F0      		breq .L91
 1367 0342 00F4      		brsh .L92
 1368 0344 D03F      		cpi r29,lo8(-16)
 1369 0346 01F0      		breq .L93
 1370 0348 D13F      		cpi r29,lo8(-15)
 1371 034a 01F0      		breq .L94
 1372               	.L95:
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1373               		.loc 1 563 21 view .LVU348
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1374               		.loc 1 563 24 is_stmt 0 view .LVU349
 1375 034c 1123      		tst r17
 1376 034e 01F4      		brne .+2
 1377 0350 00C0      		rjmp .L104
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1378               		.loc 1 564 25 is_stmt 1 view .LVU350
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1379               		.loc 1 564 28 is_stmt 0 view .LVU351
 1380 0352 0111      		cpse r16,__zero_reg__
 1381 0354 00C0      		rjmp .L148
 568:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1382               		.loc 1 568 76 is_stmt 1 view .LVU352
 569:tmk_core/common/action.c ****                         }
 1383               		.loc 1 569 29 view .LVU353
 1384 0356 8C2F      		mov r24,r28
 1385 0358 8F71      		andi r24,lo8(31)
 1386 035a 00C0      		rjmp .L145
 1387               	.L92:
 1388 035c D33F      		cpi r29,lo8(-13)
 1389 035e 01F0      		breq .L96
 1390 0360 D43F      		cpi r29,lo8(-12)
 1391 0362 01F4      		brne .L95
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1392               		.loc 1 549 21 view .LVU354
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1393               		.loc 1 549 24 is_stmt 0 view .LVU355
 1394 0364 1123      		tst r17
 1395 0366 01F0      		breq .L103
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1396               		.loc 1 550 25 is_stmt 1 view .LVU356
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1397               		.loc 1 550 50 is_stmt 0 view .LVU357
 1398 0368 CF71      		andi r28,lo8(31)
 1399               	.LVL136:
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1400               		.loc 1 550 25 view .LVU358
 1401 036a 8C2F      		mov r24,r28
 1402 036c 0E94 0000 		call layer_on
 1403               	.LVL137:
 551:tmk_core/common/action.c ****                     } else {
 1404               		.loc 1 551 25 is_stmt 1 view .LVU359
 1405 0370 63E0      		ldi r22,lo8(3)
 1406 0372 8C2F      		mov r24,r28
 1407 0374 0E94 0000 		call set_oneshot_layer
 1408               	.LVL138:
 1409 0378 00C0      		rjmp .L40
 1410               	.LVL139:
 1411               	.L93:
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1412               		.loc 1 504 21 view .LVU360
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1413               		.loc 1 504 24 is_stmt 0 view .LVU361
 1414 037a 1123      		tst r17
 1415 037c 01F0      		breq .L98
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1416               		.loc 1 505 25 is_stmt 1 view .LVU362
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1417               		.loc 1 505 28 is_stmt 0 view .LVU363
 1418 037e 0530      		cpi r16,lo8(5)
 1419 0380 00F0      		brlo .+2
 1420 0382 00C0      		rjmp .L40
 1421               	.L99:
 506:tmk_core/common/action.c ****                         }
 1422               		.loc 1 506 29 is_stmt 1 view .LVU364
 1423 0384 8C2F      		mov r24,r28
 1424 0386 8F71      		andi r24,lo8(31)
 1425 0388 0E94 0000 		call layer_invert
 1426               	.LVL140:
 1427 038c 00C0      		rjmp .L40
 1428               	.L98:
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1429               		.loc 1 509 25 view .LVU365
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1430               		.loc 1 509 28 is_stmt 0 view .LVU366
 1431 038e 0630      		cpi r16,lo8(6)
 1432 0390 00F0      		brlo .+2
 1433 0392 00C0      		rjmp .L40
 1434 0394 00C0      		rjmp .L99
 1435               	.L94:
 515:tmk_core/common/action.c ****                     break;
 1436               		.loc 1 515 21 is_stmt 1 view .LVU367
 1437 0396 8C2F      		mov r24,r28
 1438 0398 8F71      		andi r24,lo8(31)
 515:tmk_core/common/action.c ****                     break;
 1439               		.loc 1 515 68 is_stmt 0 view .LVU368
 1440 039a 1123      		tst r17
 1441 039c 01F0      		breq .L142
 1442               	.L145:
 569:tmk_core/common/action.c ****                         }
 1443               		.loc 1 569 29 view .LVU369
 1444 039e 0E94 0000 		call layer_on
 1445               	.LVL141:
 1446 03a2 00C0      		rjmp .L40
 1447               	.L91:
 518:tmk_core/common/action.c ****                     break;
 1448               		.loc 1 518 21 is_stmt 1 view .LVU370
 1449 03a4 8C2F      		mov r24,r28
 1450 03a6 8F71      		andi r24,lo8(31)
 518:tmk_core/common/action.c ****                     break;
 1451               		.loc 1 518 69 is_stmt 0 view .LVU371
 1452 03a8 1123      		tst r17
 1453 03aa 01F0      		breq .L145
 1454 03ac 00C0      		rjmp .L142
 1455               	.L96:
 521:tmk_core/common/action.c ****                     break;
 1456               		.loc 1 521 21 is_stmt 1 view .LVU372
 521:tmk_core/common/action.c ****                     break;
 1457               		.loc 1 521 70 is_stmt 0 view .LVU373
 1458 03ae 1123      		tst r17
 1459 03b0 01F0      		breq .L102
 521:tmk_core/common/action.c ****                     break;
 1460               		.loc 1 521 37 discriminator 1 view .LVU374
 1461 03b2 8C2F      		mov r24,r28
 1462 03b4 8F71      		andi r24,lo8(31)
 1463 03b6 0E94 0000 		call layer_move
 1464               	.LVL142:
 1465 03ba 00C0      		rjmp .L40
 1466               	.L102:
 521:tmk_core/common/action.c ****                     break;
 1467               		.loc 1 521 72 discriminator 2 view .LVU375
 1468 03bc 0E94 0000 		call layer_clear
 1469               	.LVL143:
 1470 03c0 00C0      		rjmp .L40
 1471               	.L103:
 553:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1472               		.loc 1 553 25 is_stmt 1 view .LVU376
 1473 03c2 81E0      		ldi r24,lo8(1)
 1474 03c4 0E94 0000 		call clear_oneshot_layer_state
 1475               	.LVL144:
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1476               		.loc 1 554 25 view .LVU377
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1477               		.loc 1 554 28 is_stmt 0 view .LVU378
 1478 03c8 0230      		cpi r16,lo8(2)
 1479 03ca 00F4      		brsh .+2
 1480 03cc 00C0      		rjmp .L40
 555:tmk_core/common/action.c ****                         }
 1481               		.loc 1 555 29 is_stmt 1 view .LVU379
 1482 03ce 82E0      		ldi r24,lo8(2)
 1483 03d0 0E94 0000 		call clear_oneshot_layer_state
 1484               	.LVL145:
 1485 03d4 00C0      		rjmp .L40
 1486               	.L104:
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1487               		.loc 1 572 25 view .LVU380
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1488               		.loc 1 572 28 is_stmt 0 view .LVU381
 1489 03d6 0023      		tst r16
 1490 03d8 01F0      		breq .L106
 573:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1491               		.loc 1 573 77 is_stmt 1 view .LVU382
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1492               		.loc 1 574 29 view .LVU383
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1493               		.loc 1 574 32 is_stmt 0 view .LVU384
 1494 03da D933      		cpi r29,lo8(57)
 1495 03dc 01F0      		breq .+2
 1496 03de 00C0      		rjmp .L108
 575:tmk_core/common/action.c ****                             } else {
 1497               		.loc 1 575 33 is_stmt 1 view .LVU385
 1498               	.LVL146:
 1499               	.LBB38:
 1500               	.LBI33:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 1501               		.loc 3 166 1 view .LVU386
 1502               	.LBB35:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1503               		.loc 3 168 2 view .LVU387
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1504               		.loc 3 172 2 view .LVU388
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1505               		.loc 3 173 2 view .LVU389
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 1506               		.loc 3 174 2 view .LVU390
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 1507               		.loc 3 184 3 view .LVU391
 1508               		.loc 3 187 2 view .LVU392
 1509 03e0 EFEF      		ldi r30,lo8(255999)
 1510 03e2 F7EE      		ldi r31,hi8(255999)
 1511 03e4 23E0      		ldi r18,hlo8(255999)
 1512 03e6 E150      	1:	subi r30,1
 1513 03e8 F040      		sbci r31,0
 1514 03ea 2040      		sbci r18,0
 1515 03ec 01F4      		brne 1b
 1516 03ee 00C0      		rjmp .L151
 1517               	.LVL147:
 1518               	.L106:
 1519               		.loc 3 187 2 is_stmt 0 view .LVU393
 1520               	.LBE35:
 1521               	.LBE38:
 581:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1522               		.loc 1 581 79 is_stmt 1 view .LVU394
 582:tmk_core/common/action.c ****                         }
 1523               		.loc 1 582 29 view .LVU395
 1524 03f0 8C2F      		mov r24,r28
 1525 03f2 8F71      		andi r24,lo8(31)
 1526 03f4 00C0      		rjmp .L142
 1527               	.LVL148:
 1528               	.L36:
 1529               	/* epilogue start */
 737:tmk_core/common/action.c **** 
 1530               		.loc 1 737 1 is_stmt 0 view .LVU396
 1531 03f6 DF91      		pop r29
 1532               	.LVL149:
 737:tmk_core/common/action.c **** 
 1533               		.loc 1 737 1 view .LVU397
 1534 03f8 CF91      		pop r28
 737:tmk_core/common/action.c **** 
 1535               		.loc 1 737 1 view .LVU398
 1536 03fa 1F91      		pop r17
 1537 03fc 0F91      		pop r16
 1538 03fe FF90      		pop r15
 1539 0400 EF90      		pop r14
 1540               	.LVL150:
 737:tmk_core/common/action.c **** 
 1541               		.loc 1 737 1 view .LVU399
 1542 0402 DF90      		pop r13
 1543               	.LVL151:
 737:tmk_core/common/action.c **** 
 1544               		.loc 1 737 1 view .LVU400
 1545 0404 CF90      		pop r12
 1546 0406 BF90      		pop r11
 1547 0408 0895      		ret
 1548               		.cfi_endproc
 1549               	.LFE22:
 1551               		.section	.text.process_record_handler,"ax",@progbits
 1552               	.global	process_record_handler
 1554               	process_record_handler:
 1555               	.LVL152:
 1556               	.LFB21:
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1557               		.loc 1 208 50 is_stmt 1 view -0
 1558               		.cfi_startproc
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1559               		.loc 1 208 50 is_stmt 0 view .LVU402
 1560 0000 0F93      		push r16
 1561               	.LCFI15:
 1562               		.cfi_def_cfa_offset 3
 1563               		.cfi_offset 16, -2
 1564 0002 1F93      		push r17
 1565               	.LCFI16:
 1566               		.cfi_def_cfa_offset 4
 1567               		.cfi_offset 17, -3
 1568 0004 CF93      		push r28
 1569               	.LCFI17:
 1570               		.cfi_def_cfa_offset 5
 1571               		.cfi_offset 28, -4
 1572 0006 DF93      		push r29
 1573               	.LCFI18:
 1574               		.cfi_def_cfa_offset 6
 1575               		.cfi_offset 29, -5
 1576               	/* prologue: function */
 1577               	/* frame size = 0 */
 1578               	/* stack size = 4 */
 1579               	.L__stack_usage = 4
 1580 0008 EC01      		movw r28,r24
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1581               		.loc 1 209 5 is_stmt 1 view .LVU403
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1582               		.loc 1 209 23 is_stmt 0 view .LVU404
 1583 000a 6881      		ld r22,Y
 1584 000c 7981      		ldd r23,Y+1
 1585 000e 8A81      		ldd r24,Y+2
 1586               	.LVL153:
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1587               		.loc 1 209 23 view .LVU405
 1588 0010 0E94 0000 		call store_or_get_action
 1589               	.LVL154:
 1590 0014 8C01      		movw r16,r24
 1591               	.LVL155:
 210:tmk_core/common/action.c ****     debug_action(action);
 1592               		.loc 1 210 23 is_stmt 1 view .LVU406
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1593               		.loc 1 211 5 view .LVU407
 213:tmk_core/common/action.c ****     layer_debug();
 1594               		.loc 1 213 29 view .LVU408
 214:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1595               		.loc 1 214 5 view .LVU409
 1596 0016 0E94 0000 		call layer_debug
 1597               	.LVL156:
 215:tmk_core/common/action.c ****     default_layer_debug();
 1598               		.loc 1 215 37 view .LVU410
 216:tmk_core/common/action.c **** #endif
 1599               		.loc 1 216 5 view .LVU411
 1600 001a 0E94 0000 		call default_layer_debug
 1601               	.LVL157:
 218:tmk_core/common/action.c **** 
 1602               		.loc 1 218 15 view .LVU412
 220:tmk_core/common/action.c **** }
 1603               		.loc 1 220 5 view .LVU413
 220:tmk_core/common/action.c **** }
 1604               		.loc 1 220 5 is_stmt 0 view .LVU414
 1605 001e B801      		movw r22,r16
 1606 0020 CE01      		movw r24,r28
 1607               	/* epilogue start */
 221:tmk_core/common/action.c **** 
 1608               		.loc 1 221 1 view .LVU415
 1609 0022 DF91      		pop r29
 1610 0024 CF91      		pop r28
 1611               	.LVL158:
 221:tmk_core/common/action.c **** 
 1612               		.loc 1 221 1 view .LVU416
 1613 0026 1F91      		pop r17
 1614 0028 0F91      		pop r16
 1615               	.LVL159:
 220:tmk_core/common/action.c **** }
 1616               		.loc 1 220 5 view .LVU417
 1617 002a 0C94 0000 		jmp process_action
 1618               	.LVL160:
 220:tmk_core/common/action.c **** }
 1619               		.loc 1 220 5 view .LVU418
 1620               		.cfi_endproc
 1621               	.LFE21:
 1623               		.section	.text.process_record,"ax",@progbits
 1624               	.global	process_record
 1626               	process_record:
 1627               	.LVL161:
 1628               	.LFB20:
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1629               		.loc 1 190 42 is_stmt 1 view -0
 1630               		.cfi_startproc
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1631               		.loc 1 190 42 is_stmt 0 view .LVU420
 1632 0000 CF93      		push r28
 1633               	.LCFI19:
 1634               		.cfi_def_cfa_offset 3
 1635               		.cfi_offset 28, -2
 1636 0002 DF93      		push r29
 1637               	.LCFI20:
 1638               		.cfi_def_cfa_offset 4
 1639               		.cfi_offset 29, -3
 1640               	/* prologue: function */
 1641               	/* frame size = 0 */
 1642               	/* stack size = 2 */
 1643               	.L__stack_usage = 2
 1644 0004 EC01      		movw r28,r24
 191:tmk_core/common/action.c ****         return;
 1645               		.loc 1 191 5 is_stmt 1 view .LVU421
 1646               	.LBB41:
 1647               	.LBI41:
 1648               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1649               		.loc 4 48 20 view .LVU422
 1650               	.LBB42:
 1651               		.loc 4 48 51 view .LVU423
 1652               		.loc 4 48 74 is_stmt 0 view .LVU424
 1653 0006 8B81      		ldd r24,Y+3
 1654 0008 9C81      		ldd r25,Y+4
 1655               	.LVL162:
 1656               		.loc 4 48 74 view .LVU425
 1657 000a 892B      		or r24,r25
 1658 000c 01F0      		breq .L153
 1659 000e 8881      		ld r24,Y
 1660 0010 9981      		ldd r25,Y+1
 1661 0012 8923      		and r24,r25
 1662 0014 8F3F      		cpi r24,lo8(-1)
 1663 0016 01F4      		brne .L169
 1664               	.L153:
 1665               	/* epilogue start */
 1666               	.LBE42:
 1667               	.LBE41:
 206:tmk_core/common/action.c **** 
 1668               		.loc 1 206 1 view .LVU426
 1669 0018 DF91      		pop r29
 1670 001a CF91      		pop r28
 1671               	.LVL163:
 206:tmk_core/common/action.c **** 
 1672               		.loc 1 206 1 view .LVU427
 1673 001c 0895      		ret
 1674               	.LVL164:
 1675               	.L158:
 204:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1676               		.loc 1 204 5 is_stmt 1 view .LVU428
 1677 001e CE01      		movw r24,r28
 1678 0020 0E94 0000 		call process_record_handler
 1679               	.LVL165:
 205:tmk_core/common/action.c **** }
 1680               		.loc 1 205 5 view .LVU429
 1681 0024 CE01      		movw r24,r28
 1682               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 1683               		.loc 1 206 1 is_stmt 0 view .LVU430
 1684 0026 DF91      		pop r29
 1685 0028 CF91      		pop r28
 1686               	.LVL166:
 205:tmk_core/common/action.c **** }
 1687               		.loc 1 205 5 view .LVU431
 1688 002a 0C94 0000 		jmp post_process_record_quantum
 1689               	.LVL167:
 1690               	.L169:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1691               		.loc 1 195 5 is_stmt 1 view .LVU432
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1692               		.loc 1 195 10 is_stmt 0 view .LVU433
 1693 002e CE01      		movw r24,r28
 1694 0030 0E94 0000 		call process_record_quantum
 1695               	.LVL168:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1696               		.loc 1 195 8 view .LVU434
 1697 0034 8111      		cpse r24,__zero_reg__
 1698 0036 00C0      		rjmp .L158
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1699               		.loc 1 197 9 is_stmt 1 view .LVU435
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1700               		.loc 1 197 13 is_stmt 0 view .LVU436
 1701 0038 0E94 0000 		call is_oneshot_layer_active
 1702               	.LVL169:
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1703               		.loc 1 197 12 view .LVU437
 1704 003c 8823      		tst r24
 1705 003e 01F0      		breq .L153
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1706               		.loc 1 197 39 discriminator 1 view .LVU438
 1707 0040 8A81      		ldd r24,Y+2
 1708 0042 8823      		tst r24
 1709 0044 01F0      		breq .L153
 198:tmk_core/common/action.c ****         }
 1710               		.loc 1 198 13 is_stmt 1 view .LVU439
 1711 0046 82E0      		ldi r24,lo8(2)
 1712               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 1713               		.loc 1 206 1 is_stmt 0 view .LVU440
 1714 0048 DF91      		pop r29
 1715 004a CF91      		pop r28
 1716               	.LVL170:
 198:tmk_core/common/action.c ****         }
 1717               		.loc 1 198 13 view .LVU441
 1718 004c 0C94 0000 		jmp clear_oneshot_layer_state
 1719               	.LVL171:
 1720               		.cfi_endproc
 1721               	.LFE20:
 1723               		.section	.text.process_record_nocache,"ax",@progbits
 1724               	.global	process_record_nocache
 1726               	process_record_nocache:
 1727               	.LVL172:
 1728               	.LFB16:
 148:tmk_core/common/action.c ****     disable_action_cache = true;
 1729               		.loc 1 148 50 is_stmt 1 view -0
 1730               		.cfi_startproc
 1731               	/* prologue: function */
 1732               	/* frame size = 0 */
 1733               	/* stack size = 0 */
 1734               	.L__stack_usage = 0
 149:tmk_core/common/action.c ****     process_record(record);
 1735               		.loc 1 149 5 view .LVU443
 149:tmk_core/common/action.c ****     process_record(record);
 1736               		.loc 1 149 26 is_stmt 0 view .LVU444
 1737 0000 21E0      		ldi r18,lo8(1)
 1738 0002 2093 0000 		sts disable_action_cache,r18
 150:tmk_core/common/action.c ****     disable_action_cache = false;
 1739               		.loc 1 150 5 is_stmt 1 view .LVU445
 1740 0006 0E94 0000 		call process_record
 1741               	.LVL173:
 151:tmk_core/common/action.c **** }
 1742               		.loc 1 151 5 view .LVU446
 151:tmk_core/common/action.c **** }
 1743               		.loc 1 151 26 is_stmt 0 view .LVU447
 1744 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1745               	/* epilogue start */
 152:tmk_core/common/action.c **** #else
 1746               		.loc 1 152 1 view .LVU448
 1747 000e 0895      		ret
 1748               		.cfi_endproc
 1749               	.LFE16:
 1751               		.section	.text.register_weak_mods,"ax",@progbits
 1752               	.global	register_weak_mods
 1754               	register_weak_mods:
 1755               	.LVL174:
 1756               	.LFB28:
 934:tmk_core/common/action.c **** 
 935:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:tmk_core/common/action.c ****  *
 937:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 938:tmk_core/common/action.c ****  */
 939:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1757               		.loc 1 939 39 is_stmt 1 view -0
 1758               		.cfi_startproc
 1759               	/* prologue: function */
 1760               	/* frame size = 0 */
 1761               	/* stack size = 0 */
 1762               	.L__stack_usage = 0
 940:tmk_core/common/action.c ****     if (mods) {
 1763               		.loc 1 940 5 view .LVU450
 1764               		.loc 1 940 8 is_stmt 0 view .LVU451
 1765 0000 8823      		tst r24
 1766 0002 01F0      		breq .L172
 941:tmk_core/common/action.c ****         add_weak_mods(mods);
 1767               		.loc 1 941 9 is_stmt 1 view .LVU452
 1768 0004 0E94 0000 		call add_weak_mods
 1769               	.LVL175:
 942:tmk_core/common/action.c ****         send_keyboard_report();
 1770               		.loc 1 942 9 view .LVU453
 1771 0008 0C94 0000 		jmp send_keyboard_report
 1772               	.LVL176:
 1773               	.L172:
 1774               	/* epilogue start */
 943:tmk_core/common/action.c ****     }
 944:tmk_core/common/action.c **** }
 1775               		.loc 1 944 1 is_stmt 0 view .LVU454
 1776 000c 0895      		ret
 1777               		.cfi_endproc
 1778               	.LFE28:
 1780               		.section	.text.unregister_weak_mods,"ax",@progbits
 1781               	.global	unregister_weak_mods
 1783               	unregister_weak_mods:
 1784               	.LVL177:
 1785               	.LFB29:
 945:tmk_core/common/action.c **** 
 946:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:tmk_core/common/action.c ****  *
 948:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:tmk_core/common/action.c ****  */
 950:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1786               		.loc 1 950 41 is_stmt 1 view -0
 1787               		.cfi_startproc
 1788               	/* prologue: function */
 1789               	/* frame size = 0 */
 1790               	/* stack size = 0 */
 1791               	.L__stack_usage = 0
 951:tmk_core/common/action.c ****     if (mods) {
 1792               		.loc 1 951 5 view .LVU456
 1793               		.loc 1 951 8 is_stmt 0 view .LVU457
 1794 0000 8823      		tst r24
 1795 0002 01F0      		breq .L174
 952:tmk_core/common/action.c ****         del_weak_mods(mods);
 1796               		.loc 1 952 9 is_stmt 1 view .LVU458
 1797 0004 0E94 0000 		call del_weak_mods
 1798               	.LVL178:
 953:tmk_core/common/action.c ****         send_keyboard_report();
 1799               		.loc 1 953 9 view .LVU459
 1800 0008 0C94 0000 		jmp send_keyboard_report
 1801               	.LVL179:
 1802               	.L174:
 1803               	/* epilogue start */
 954:tmk_core/common/action.c ****     }
 955:tmk_core/common/action.c **** }
 1804               		.loc 1 955 1 is_stmt 0 view .LVU460
 1805 000c 0895      		ret
 1806               		.cfi_endproc
 1807               	.LFE29:
 1809               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1810               	.global	clear_keyboard_but_mods_and_keys
 1812               	clear_keyboard_but_mods_and_keys:
 1813               	.LFB32:
 956:tmk_core/common/action.c **** 
 957:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:tmk_core/common/action.c ****  *
 959:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 960:tmk_core/common/action.c ****  */
 961:tmk_core/common/action.c **** void clear_keyboard(void) {
 962:tmk_core/common/action.c ****     clear_mods();
 963:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 964:tmk_core/common/action.c **** }
 965:tmk_core/common/action.c **** 
 966:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:tmk_core/common/action.c ****  *
 968:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 969:tmk_core/common/action.c ****  */
 970:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 971:tmk_core/common/action.c ****     clear_keys();
 972:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 973:tmk_core/common/action.c **** }
 974:tmk_core/common/action.c **** 
 975:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:tmk_core/common/action.c ****  *
 977:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 978:tmk_core/common/action.c ****  */
 979:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1814               		.loc 1 979 41 is_stmt 1 view -0
 1815               		.cfi_startproc
 1816               	/* prologue: function */
 1817               	/* frame size = 0 */
 1818               	/* stack size = 0 */
 1819               	.L__stack_usage = 0
 980:tmk_core/common/action.c ****     clear_weak_mods();
 1820               		.loc 1 980 5 view .LVU462
 1821 0000 0E94 0000 		call clear_weak_mods
 1822               	.LVL180:
 981:tmk_core/common/action.c ****     clear_macro_mods();
 1823               		.loc 1 981 5 view .LVU463
 1824 0004 0E94 0000 		call clear_macro_mods
 1825               	.LVL181:
 982:tmk_core/common/action.c ****     send_keyboard_report();
 1826               		.loc 1 982 5 view .LVU464
 1827 0008 0E94 0000 		call send_keyboard_report
 1828               	.LVL182:
 983:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 984:tmk_core/common/action.c ****     mousekey_clear();
 1829               		.loc 1 984 5 view .LVU465
 1830 000c 0E94 0000 		call mousekey_clear
 1831               	.LVL183:
 985:tmk_core/common/action.c ****     mousekey_send();
 1832               		.loc 1 985 5 view .LVU466
 1833 0010 0E94 0000 		call mousekey_send
 1834               	.LVL184:
 986:tmk_core/common/action.c **** #endif
 987:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 988:tmk_core/common/action.c ****     host_system_send(0);
 1835               		.loc 1 988 5 view .LVU467
 1836 0014 90E0      		ldi r25,0
 1837 0016 80E0      		ldi r24,0
 1838 0018 0E94 0000 		call host_system_send
 1839               	.LVL185:
 989:tmk_core/common/action.c ****     host_consumer_send(0);
 1840               		.loc 1 989 5 view .LVU468
 1841 001c 90E0      		ldi r25,0
 1842 001e 80E0      		ldi r24,0
 1843 0020 0C94 0000 		jmp host_consumer_send
 1844               	.LVL186:
 1845               		.cfi_endproc
 1846               	.LFE32:
 1848               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1849               	.global	clear_keyboard_but_mods
 1851               	clear_keyboard_but_mods:
 1852               	.LFB31:
 970:tmk_core/common/action.c ****     clear_keys();
 1853               		.loc 1 970 36 view -0
 1854               		.cfi_startproc
 1855               	/* prologue: function */
 1856               	/* frame size = 0 */
 1857               	/* stack size = 0 */
 1858               	.L__stack_usage = 0
 971:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1859               		.loc 1 971 5 view .LVU470
 1860 0000 0E94 0000 		call clear_keys
 1861               	.LVL187:
 972:tmk_core/common/action.c **** }
 1862               		.loc 1 972 5 view .LVU471
 1863 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1864               	.LVL188:
 1865               		.cfi_endproc
 1866               	.LFE31:
 1868               		.section	.text.clear_keyboard,"ax",@progbits
 1869               	.global	clear_keyboard
 1871               	clear_keyboard:
 1872               	.LFB30:
 961:tmk_core/common/action.c ****     clear_mods();
 1873               		.loc 1 961 27 view -0
 1874               		.cfi_startproc
 1875               	/* prologue: function */
 1876               	/* frame size = 0 */
 1877               	/* stack size = 0 */
 1878               	.L__stack_usage = 0
 962:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1879               		.loc 1 962 5 view .LVU473
 1880 0000 0E94 0000 		call clear_mods
 1881               	.LVL189:
 963:tmk_core/common/action.c **** }
 1882               		.loc 1 963 5 view .LVU474
 1883 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1884               	.LVL190:
 1885               		.cfi_endproc
 1886               	.LFE30:
 1888               		.section	.text.is_tap_action,"ax",@progbits
 1889               	.global	is_tap_action
 1891               	is_tap_action:
 1892               	.LVL191:
 1893               	.LFB34:
 990:tmk_core/common/action.c **** #endif
 991:tmk_core/common/action.c **** }
 992:tmk_core/common/action.c **** 
 993:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:tmk_core/common/action.c ****  *
 995:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 996:tmk_core/common/action.c ****  */
 997:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 998:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 999:tmk_core/common/action.c ****     return is_tap_action(action);
1000:tmk_core/common/action.c **** }
1001:tmk_core/common/action.c **** 
1002:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:tmk_core/common/action.c ****  *
1004:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1005:tmk_core/common/action.c ****  */
1006:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1894               		.loc 1 1006 37 view -0
 1895               		.cfi_startproc
 1896               	/* prologue: function */
 1897               	/* frame size = 0 */
 1898               	/* stack size = 0 */
 1899               	.L__stack_usage = 0
1007:tmk_core/common/action.c ****     switch (action.kind.id) {
 1900               		.loc 1 1007 5 view .LVU476
 1901               		.loc 1 1007 24 is_stmt 0 view .LVU477
 1902 0000 E92F      		mov r30,r25
 1903 0002 E295      		swap r30
 1904 0004 EF70      		andi r30,lo8(15)
 1905               		.loc 1 1007 5 view .LVU478
 1906 0006 E250      		subi r30,lo8(-(-2))
 1907 0008 EE30      		cpi r30,lo8(14)
 1908 000a 00F4      		brsh .L188
 1909 000c F0E0      		ldi r31,0
 1910 000e E050      		subi r30,lo8(-(gs(.L182)))
 1911 0010 F040      		sbci r31,hi8(-(gs(.L182)))
 1912 0012 0C94 0000 		jmp __tablejump2__
 1913               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 1914               		.p2align	1
 1915               	.L182:
 1916 0000 0000      		.word gs(.L183)
 1917 0002 0000      		.word gs(.L183)
 1918 0004 0000      		.word gs(.L188)
 1919 0006 0000      		.word gs(.L188)
 1920 0008 0000      		.word gs(.L184)
 1921 000a 0000      		.word gs(.L188)
 1922 000c 0000      		.word gs(.L188)
 1923 000e 0000      		.word gs(.L188)
 1924 0010 0000      		.word gs(.L183)
 1925 0012 0000      		.word gs(.L183)
 1926 0014 0000      		.word gs(.L181)
 1927 0016 0000      		.word gs(.L188)
 1928 0018 0000      		.word gs(.L188)
 1929 001a 0000      		.word gs(.L181)
 1930               		.section	.text.is_tap_action
 1931               	.L183:
1008:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1009:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1010:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1011:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1012:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1932               		.loc 1 1012 13 is_stmt 1 view .LVU479
 1933 0016 803F      		cpi r24,lo8(-16)
 1934 0018 01F0      		breq .L191
 1935 001a 00F4      		brsh .L185
 1936 001c 883E      		cpi r24,lo8(-24)
 1937 001e 00F4      		brsh .L188
 1938               	.L191:
1013:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1014:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1015:tmk_core/common/action.c ****                 case OP_ONESHOT:
1016:tmk_core/common/action.c ****                     return true;
 1939               		.loc 1 1016 28 is_stmt 0 view .LVU480
 1940 0020 81E0      		ldi r24,lo8(1)
 1941               	.LVL192:
 1942               	/* epilogue start */
1017:tmk_core/common/action.c ****             }
1018:tmk_core/common/action.c ****             return false;
1019:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1020:tmk_core/common/action.c ****             switch (action.swap.code) {
1021:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1022:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1023:tmk_core/common/action.c ****                     return true;
1024:tmk_core/common/action.c ****             }
1025:tmk_core/common/action.c ****             return false;
1026:tmk_core/common/action.c ****         case ACT_MACRO:
1027:tmk_core/common/action.c ****         case ACT_FUNCTION:
1028:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1029:tmk_core/common/action.c ****                 return true;
1030:tmk_core/common/action.c ****             }
1031:tmk_core/common/action.c ****             return false;
1032:tmk_core/common/action.c ****     }
1033:tmk_core/common/action.c ****     return false;
1034:tmk_core/common/action.c **** }
 1943               		.loc 1 1034 1 view .LVU481
 1944 0022 0895      		ret
 1945               	.LVL193:
 1946               	.L185:
 1947               		.loc 1 1034 1 view .LVU482
 1948 0024 843F      		cpi r24,lo8(-12)
 1949 0026 01F0      		breq .L191
 1950               	.L188:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1951               		.loc 1 1018 20 view .LVU483
 1952 0028 80E0      		ldi r24,0
 1953               	.LVL194:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1954               		.loc 1 1018 20 view .LVU484
 1955 002a 0895      		ret
 1956               	.LVL195:
 1957               	.L184:
1020:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1958               		.loc 1 1020 13 is_stmt 1 view .LVU485
 1959 002c 883E      		cpi r24,lo8(-24)
 1960 002e 00F0      		brlo .L191
 1961 0030 813F      		cpi r24,lo8(-15)
 1962 0032 01F4      		brne .L188
 1963 0034 00C0      		rjmp .L191
 1964               	.L181:
1028:tmk_core/common/action.c ****                 return true;
 1965               		.loc 1 1028 13 view .LVU486
1028:tmk_core/common/action.c ****                 return true;
 1966               		.loc 1 1028 16 is_stmt 0 view .LVU487
 1967 0036 93FB      		bst r25,3
 1968 0038 8827      		clr r24
 1969 003a 80F9      		bld r24,0
 1970               	.LVL196:
1028:tmk_core/common/action.c ****                 return true;
 1971               		.loc 1 1028 16 view .LVU488
 1972 003c 0895      		ret
 1973               		.cfi_endproc
 1974               	.LFE34:
 1976               		.section	.text.is_tap_key,"ax",@progbits
 1977               	.global	is_tap_key
 1979               	is_tap_key:
 1980               	.LVL197:
 1981               	.LFB33:
 997:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1982               		.loc 1 997 31 is_stmt 1 view -0
 1983               		.cfi_startproc
 1984               	/* prologue: function */
 1985               	/* frame size = 0 */
 1986               	/* stack size = 0 */
 1987               	.L__stack_usage = 0
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 1988               		.loc 1 998 5 view .LVU490
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 1989               		.loc 1 998 23 is_stmt 0 view .LVU491
 1990 0000 0E94 0000 		call layer_switch_get_action
 1991               	.LVL198:
 999:tmk_core/common/action.c **** }
 1992               		.loc 1 999 5 is_stmt 1 view .LVU492
 999:tmk_core/common/action.c **** }
 1993               		.loc 1 999 12 is_stmt 0 view .LVU493
 1994 0004 0C94 0000 		jmp is_tap_action
 1995               	.LVL199:
 1996               		.cfi_endproc
 1997               	.LFE33:
 1999               		.section	.text.debug_event,"ax",@progbits
 2000               	.global	debug_event
 2002               	debug_event:
 2003               	.LFB35:
1035:tmk_core/common/action.c **** 
1036:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1037:tmk_core/common/action.c ****  *
1038:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1039:tmk_core/common/action.c ****  */
1040:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2004               		.loc 1 1040 36 is_stmt 1 view -0
 2005               		.cfi_startproc
 2006 0000 CF93      		push r28
 2007               	.LCFI21:
 2008               		.cfi_def_cfa_offset 3
 2009               		.cfi_offset 28, -2
 2010 0002 DF93      		push r29
 2011               	.LCFI22:
 2012               		.cfi_def_cfa_offset 4
 2013               		.cfi_offset 29, -3
 2014 0004 00D0      		rcall .
 2015 0006 00D0      		rcall .
 2016 0008 0F92      		push __tmp_reg__
 2017               	.LCFI23:
 2018               		.cfi_def_cfa_offset 9
 2019 000a CDB7      		in r28,__SP_L__
 2020 000c DEB7      		in r29,__SP_H__
 2021               	.LCFI24:
 2022               		.cfi_def_cfa_register 28
 2023               	/* prologue: function */
 2024               	/* frame size = 5 */
 2025               	/* stack size = 7 */
 2026               	.L__stack_usage = 7
 2027               		.loc 1 1040 138 view .LVU495
 2028               	/* epilogue start */
 2029               		.loc 1 1040 1 is_stmt 0 view .LVU496
 2030 000e 0F90      		pop __tmp_reg__
 2031 0010 0F90      		pop __tmp_reg__
 2032 0012 0F90      		pop __tmp_reg__
 2033 0014 0F90      		pop __tmp_reg__
 2034 0016 0F90      		pop __tmp_reg__
 2035 0018 DF91      		pop r29
 2036 001a CF91      		pop r28
 2037 001c 0895      		ret
 2038               		.cfi_endproc
 2039               	.LFE35:
 2041               		.section	.text.debug_record,"ax",@progbits
 2042               	.global	debug_record
 2044               	debug_record:
 2045               	.LFB36:
1041:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1042:tmk_core/common/action.c ****  *
1043:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1044:tmk_core/common/action.c ****  */
1045:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2046               		.loc 1 1045 39 is_stmt 1 view -0
 2047               		.cfi_startproc
 2048 0000 CF93      		push r28
 2049               	.LCFI25:
 2050               		.cfi_def_cfa_offset 3
 2051               		.cfi_offset 28, -2
 2052 0002 DF93      		push r29
 2053               	.LCFI26:
 2054               		.cfi_def_cfa_offset 4
 2055               		.cfi_offset 29, -3
 2056 0004 00D0      		rcall .
 2057 0006 00D0      		rcall .
 2058 0008 00D0      		rcall .
 2059               	.LCFI27:
 2060               		.cfi_def_cfa_offset 10
 2061 000a CDB7      		in r28,__SP_L__
 2062 000c DEB7      		in r29,__SP_H__
 2063               	.LCFI28:
 2064               		.cfi_def_cfa_register 28
 2065               	/* prologue: function */
 2066               	/* frame size = 6 */
 2067               	/* stack size = 8 */
 2068               	.L__stack_usage = 8
1046:tmk_core/common/action.c ****     debug_event(record.event);
 2069               		.loc 1 1046 5 view .LVU498
1047:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1048:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2070               		.loc 1 1048 77 view .LVU499
 2071               	/* epilogue start */
1049:tmk_core/common/action.c **** #endif
1050:tmk_core/common/action.c **** }
 2072               		.loc 1 1050 1 is_stmt 0 view .LVU500
 2073 000e 2696      		adiw r28,6
 2074 0010 0FB6      		in __tmp_reg__,__SREG__
 2075 0012 F894      		cli
 2076 0014 DEBF      		out __SP_H__,r29
 2077 0016 0FBE      		out __SREG__,__tmp_reg__
 2078 0018 CDBF      		out __SP_L__,r28
 2079 001a DF91      		pop r29
 2080 001c CF91      		pop r28
 2081 001e 0895      		ret
 2082               		.cfi_endproc
 2083               	.LFE36:
 2085               		.section	.text.debug_action,"ax",@progbits
 2086               	.global	debug_action
 2088               	debug_action:
 2089               	.LVL200:
 2090               	.LFB37:
1051:tmk_core/common/action.c **** 
1052:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1053:tmk_core/common/action.c ****  *
1054:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1055:tmk_core/common/action.c ****  */
1056:tmk_core/common/action.c **** void debug_action(action_t action) {
 2091               		.loc 1 1056 36 is_stmt 1 view -0
 2092               		.cfi_startproc
 2093               	/* prologue: function */
 2094               	/* frame size = 0 */
 2095               	/* stack size = 0 */
 2096               	.L__stack_usage = 0
1057:tmk_core/common/action.c ****     switch (action.kind.id) {
 2097               		.loc 1 1057 5 view .LVU502
1058:tmk_core/common/action.c ****         case ACT_LMODS:
1059:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1060:tmk_core/common/action.c ****             break;
1061:tmk_core/common/action.c ****         case ACT_RMODS:
1062:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1063:tmk_core/common/action.c ****             break;
1064:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1065:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1066:tmk_core/common/action.c ****             break;
1067:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1068:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1069:tmk_core/common/action.c ****             break;
1070:tmk_core/common/action.c ****         case ACT_USAGE:
1071:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1072:tmk_core/common/action.c ****             break;
1073:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1074:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1075:tmk_core/common/action.c ****             break;
1076:tmk_core/common/action.c ****         case ACT_LAYER:
1077:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1078:tmk_core/common/action.c ****             break;
1079:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1080:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1081:tmk_core/common/action.c ****             break;
1082:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1083:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1084:tmk_core/common/action.c ****             break;
1085:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1086:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1087:tmk_core/common/action.c ****             break;
1088:tmk_core/common/action.c ****         case ACT_MACRO:
1089:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1090:tmk_core/common/action.c ****             break;
1091:tmk_core/common/action.c ****         case ACT_FUNCTION:
1092:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1093:tmk_core/common/action.c ****             break;
1094:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1095:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1096:tmk_core/common/action.c ****             break;
1097:tmk_core/common/action.c ****         default:
1098:tmk_core/common/action.c ****             dprint("UNKNOWN");
1099:tmk_core/common/action.c ****             break;
1100:tmk_core/common/action.c ****     }
1101:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2098               		.loc 1 1101 75 view .LVU503
 2099               	/* epilogue start */
1102:tmk_core/common/action.c **** }
 2100               		.loc 1 1102 1 is_stmt 0 view .LVU504
 2101 0000 0895      		ret
 2102               		.cfi_endproc
 2103               	.LFE37:
 2105               		.section	.rodata.CSWTCH.11,"a"
 2108               	CSWTCH.11:
 2109 0000 E200      		.word	226
 2110 0002 E900      		.word	233
 2111 0004 EA00      		.word	234
 2112 0006 B500      		.word	181
 2113 0008 B600      		.word	182
 2114 000a B700      		.word	183
 2115 000c CD00      		.word	205
 2116 000e 8301      		.word	387
 2117 0010 CC00      		.word	204
 2118 0012 8A01      		.word	394
 2119 0014 9201      		.word	402
 2120 0016 9401      		.word	404
 2121 0018 2102      		.word	545
 2122 001a 2302      		.word	547
 2123 001c 2402      		.word	548
 2124 001e 2502      		.word	549
 2125 0020 2602      		.word	550
 2126 0022 2702      		.word	551
 2127 0024 2A02      		.word	554
 2128 0026 B300      		.word	179
 2129 0028 B400      		.word	180
 2130 002a 6F00      		.word	111
 2131 002c 7000      		.word	112
 2132               		.section	.rodata.CSWTCH.10,"a"
 2135               	CSWTCH.10:
 2136 0000 81        		.byte	-127
 2137 0001 82        		.byte	-126
 2138 0002 83        		.byte	-125
 2139               	.global	disable_action_cache
 2140               		.section	.bss.disable_action_cache,"aw",@nobits
 2143               	disable_action_cache:
 2144 0000 00        		.zero	1
 2145               		.comm	tp_buttons,2,1
 2146               		.text
 2147               	.Letext0:
 2148               		.file 5 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/stdint.h"
 2149               		.file 6 "tmk_core/common/keycode.h"
 2150               		.file 7 "tmk_core/common/host.h"
 2151               		.file 8 "tmk_core/common/mousekey.h"
 2152               		.file 9 "tmk_core/common/command.h"
 2153               		.file 10 "tmk_core/common/action_code.h"
 2154               		.file 11 "tmk_core/common/action.h"
 2155               		.file 12 "tmk_core/common/action_layer.h"
 2156               		.file 13 "tmk_core/common/action_util.h"
 2157               		.file 14 "tmk_core/common/avr/xprintf.h"
 2158               		.file 15 "tmk_core/common/debug.h"
 2159               		.file 16 "tmk_core/common/led.h"
 2160               		.file 17 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:4      *ABS*:000000000000003f __SREG__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:13     .text.action_exec:0000000000000000 action_exec
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:94     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:116    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:135    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:160    .text.register_code:0000000000000000 register_code
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:2135   .rodata.CSWTCH.10:0000000000000000 CSWTCH.10
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:2108   .rodata.CSWTCH.11:0000000000000000 CSWTCH.11
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:330    .text.unregister_code:0000000000000000 unregister_code
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:430    .text.tap_code:0000000000000000 tap_code
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:495    .text.register_mods:0000000000000000 register_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:524    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:553    .text.process_action:0000000000000000 process_action
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1626   .text.process_record:0000000000000000 process_record
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1554   .text.process_record_handler:0000000000000000 process_record_handler
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1726   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:2143   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1754   .text.register_weak_mods:0000000000000000 register_weak_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1783   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1812   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1851   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1871   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1891   .text.is_tap_action:0000000000000000 is_tap_action
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:1979   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:2002   .text.debug_event:0000000000000000 debug_event
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:2044   .text.debug_record:0000000000000000 debug_record
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccE62Gy8.s:2088   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
keyboard_report
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
host_keyboard_leds
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
