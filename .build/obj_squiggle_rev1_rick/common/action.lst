   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB15:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  55:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  58:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  59:tmk_core/common/action.c **** #endif
  60:tmk_core/common/action.c **** /** \brief Called to execute an action.
  61:tmk_core/common/action.c ****  *
  62:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  63:tmk_core/common/action.c ****  */
  64:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 64 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  65:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 65 5 view .LVU1
  66:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:tmk_core/common/action.c ****         dprint("EVENT: ");
  68:tmk_core/common/action.c ****         debug_event(event);
  69:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 69 19 view .LVU2
  70:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  71:tmk_core/common/action.c ****         retro_tapping_counter++;
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c **** 
  75:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  76:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  77:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  78:tmk_core/common/action.c ****     }
  79:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  80:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c ****     fauxclicky_check();
  83:tmk_core/common/action.c **** #endif
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  86:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  87:tmk_core/common/action.c ****         process_hand_swap(&event);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 91 5 view .LVU3
  51               		.loc 1 91 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  94:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  95:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  96:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  99:tmk_core/common/action.c ****         clear_oneshot_mods();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 102:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 103:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 104:tmk_core/common/action.c ****     }
 105:tmk_core/common/action.c **** #        endif
 106:tmk_core/common/action.c **** #    endif
 107:tmk_core/common/action.c **** #endif
 108:tmk_core/common/action.c **** 
 109:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 110:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 110 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 110 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 110 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 111:tmk_core/common/action.c **** #else
 112:tmk_core/common/action.c ****     process_record(&record);
 113:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 114:tmk_core/common/action.c ****         dprint("processed: ");
 115:tmk_core/common/action.c ****         debug_record(record);
 116:tmk_core/common/action.c ****         dprintln();
 117:tmk_core/common/action.c ****     }
 118:tmk_core/common/action.c **** #endif
 119:tmk_core/common/action.c **** }
  76               		.loc 1 119 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
 110:tmk_core/common/action.c **** #else
  85               		.loc 1 110 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE15:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB17:
 120:tmk_core/common/action.c **** 
 121:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 122:tmk_core/common/action.c **** bool swap_hands = false;
 123:tmk_core/common/action.c **** bool swap_held  = false;
 124:tmk_core/common/action.c **** 
 125:tmk_core/common/action.c **** /** \brief Process Hand Swap
 126:tmk_core/common/action.c ****  *
 127:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 128:tmk_core/common/action.c ****  */
 129:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 130:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 131:tmk_core/common/action.c **** 
 132:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 133:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 134:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 135:tmk_core/common/action.c **** 
 136:tmk_core/common/action.c ****     if (do_swap) {
 137:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 138:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 139:tmk_core/common/action.c ****     } else {
 140:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:tmk_core/common/action.c ****     }
 142:tmk_core/common/action.c **** }
 143:tmk_core/common/action.c **** #endif
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:tmk_core/common/action.c **** bool disable_action_cache = false;
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:tmk_core/common/action.c ****     disable_action_cache = true;
 150:tmk_core/common/action.c ****     process_record(record);
 151:tmk_core/common/action.c ****     disable_action_cache = false;
 152:tmk_core/common/action.c **** }
 153:tmk_core/common/action.c **** #else
 154:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:tmk_core/common/action.c **** #endif
 156:tmk_core/common/action.c **** 
 157:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 157 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 157 74 view .LVU11
 104               		.loc 1 157 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 157 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE17:
 113               		.section	.text.post_process_record_quantum,"ax",@progbits
 114               		.weak	post_process_record_quantum
 116               	post_process_record_quantum:
 117               	.LVL6:
 118               	.LFB18:
 158:tmk_core/common/action.c **** 
 159:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 119               		.loc 1 159 77 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 125               		.loc 1 159 78 view .LVU15
 126               	/* epilogue start */
 127               		.loc 1 159 1 is_stmt 0 view .LVU16
 128 0000 0895      		ret
 129               		.cfi_endproc
 130               	.LFE18:
 132               		.section	.text.process_record_tap_hint,"ax",@progbits
 133               	.global	process_record_tap_hint
 135               	process_record_tap_hint:
 136               	.LVL7:
 137               	.LFB19:
 160:tmk_core/common/action.c **** 
 161:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 162:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:tmk_core/common/action.c ****  *
 164:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 165:tmk_core/common/action.c ****  */
 166:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 138               		.loc 1 166 51 is_stmt 1 view -0
 139               		.cfi_startproc
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 167:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 144               		.loc 1 167 5 view .LVU18
 145               		.loc 1 167 23 is_stmt 0 view .LVU19
 146 0000 FC01      		movw r30,r24
 147 0002 8081      		ld r24,Z
 148 0004 9181      		ldd r25,Z+1
 149               	.LVL8:
 150               		.loc 1 167 23 view .LVU20
 151 0006 0C94 0000 		jmp layer_switch_get_action
 152               	.LVL9:
 153               		.loc 1 167 23 view .LVU21
 154               		.cfi_endproc
 155               	.LFE19:
 157               		.section	.text.register_code,"ax",@progbits
 158               	.global	register_code
 160               	register_code:
 161               	.LVL10:
 162               	.LFB23:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c ****     switch (action.kind.id) {
 170:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 172:tmk_core/common/action.c ****             switch (action.swap.code) {
 173:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 174:tmk_core/common/action.c ****                     break;
 175:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:tmk_core/common/action.c ****                 default:
 177:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 178:tmk_core/common/action.c ****                     swap_held  = true;
 179:tmk_core/common/action.c ****             }
 180:tmk_core/common/action.c ****             break;
 181:tmk_core/common/action.c **** #    endif
 182:tmk_core/common/action.c ****     }
 183:tmk_core/common/action.c **** }
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:tmk_core/common/action.c ****  *
 188:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 189:tmk_core/common/action.c ****  */
 190:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 191:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 192:tmk_core/common/action.c ****         return;
 193:tmk_core/common/action.c ****     }
 194:tmk_core/common/action.c **** 
 195:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 196:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 197:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:tmk_core/common/action.c ****         }
 200:tmk_core/common/action.c **** #endif
 201:tmk_core/common/action.c ****         return;
 202:tmk_core/common/action.c ****     }
 203:tmk_core/common/action.c **** 
 204:tmk_core/common/action.c ****     process_record_handler(record);
 205:tmk_core/common/action.c ****     post_process_record_quantum(record);
 206:tmk_core/common/action.c **** }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 209:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 210:tmk_core/common/action.c ****     dprint("ACTION: ");
 211:tmk_core/common/action.c ****     debug_action(action);
 212:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 213:tmk_core/common/action.c ****     dprint(" layer_state: ");
 214:tmk_core/common/action.c ****     layer_debug();
 215:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 216:tmk_core/common/action.c ****     default_layer_debug();
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c ****     dprintln();
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     process_action(record, action);
 221:tmk_core/common/action.c **** }
 222:tmk_core/common/action.c **** 
 223:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 224:tmk_core/common/action.c ****  *
 225:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 226:tmk_core/common/action.c ****  */
 227:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 228:tmk_core/common/action.c ****     keyevent_t event = record->event;
 229:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 230:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 231:tmk_core/common/action.c **** #endif
 232:tmk_core/common/action.c **** 
 233:tmk_core/common/action.c ****     if (event.pressed) {
 234:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 235:tmk_core/common/action.c ****         clear_weak_mods();
 236:tmk_core/common/action.c ****     }
 237:tmk_core/common/action.c **** 
 238:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 239:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 240:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 241:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 242:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 243:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 244:tmk_core/common/action.c **** #    endif
 245:tmk_core/common/action.c ****     ) {
 246:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 247:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 248:tmk_core/common/action.c ****     }
 249:tmk_core/common/action.c **** #endif
 250:tmk_core/common/action.c **** 
 251:tmk_core/common/action.c ****     switch (action.kind.id) {
 252:tmk_core/common/action.c ****         /* Key and Mods */
 253:tmk_core/common/action.c ****         case ACT_LMODS:
 254:tmk_core/common/action.c ****         case ACT_RMODS: {
 255:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 256:tmk_core/common/action.c ****             if (event.pressed) {
 257:tmk_core/common/action.c ****                 if (mods) {
 258:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 259:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 260:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 261:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 262:tmk_core/common/action.c ****                         add_mods(mods);
 263:tmk_core/common/action.c ****                     } else {
 264:tmk_core/common/action.c ****                         add_weak_mods(mods);
 265:tmk_core/common/action.c ****                     }
 266:tmk_core/common/action.c ****                     send_keyboard_report();
 267:tmk_core/common/action.c ****                 }
 268:tmk_core/common/action.c ****                 register_code(action.key.code);
 269:tmk_core/common/action.c ****             } else {
 270:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 271:tmk_core/common/action.c ****                 if (mods) {
 272:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 273:tmk_core/common/action.c ****                         del_mods(mods);
 274:tmk_core/common/action.c ****                     } else {
 275:tmk_core/common/action.c ****                         del_weak_mods(mods);
 276:tmk_core/common/action.c ****                     }
 277:tmk_core/common/action.c ****                     send_keyboard_report();
 278:tmk_core/common/action.c ****                 }
 279:tmk_core/common/action.c ****             }
 280:tmk_core/common/action.c ****         } break;
 281:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 282:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 283:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 284:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 285:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 286:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 287:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 288:tmk_core/common/action.c ****                     // Oneshot modifier
 289:tmk_core/common/action.c ****                     if (event.pressed) {
 290:tmk_core/common/action.c ****                         if (tap_count == 0) {
 291:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 292:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 293:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 294:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 295:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 296:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 297:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 299:tmk_core/common/action.c ****                             clear_oneshot_mods();
 300:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 301:tmk_core/common/action.c ****                             register_mods(mods);
 302:tmk_core/common/action.c **** #        endif
 303:tmk_core/common/action.c ****                         } else {
 304:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 305:tmk_core/common/action.c ****                         }
 306:tmk_core/common/action.c ****                     } else {
 307:tmk_core/common/action.c ****                         if (tap_count == 0) {
 308:tmk_core/common/action.c ****                             clear_oneshot_mods();
 309:tmk_core/common/action.c ****                             unregister_mods(mods);
 310:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 311:tmk_core/common/action.c ****                             // Retain Oneshot mods
 312:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 313:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 314:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 315:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 316:tmk_core/common/action.c ****                                 unregister_mods(mods);
 317:tmk_core/common/action.c ****                             }
 318:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 319:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 320:tmk_core/common/action.c **** #        endif
 321:tmk_core/common/action.c ****                         } else {
 322:tmk_core/common/action.c ****                             clear_oneshot_mods();
 323:tmk_core/common/action.c ****                             unregister_mods(mods);
 324:tmk_core/common/action.c ****                         }
 325:tmk_core/common/action.c ****                     }
 326:tmk_core/common/action.c ****                     break;
 327:tmk_core/common/action.c **** #    endif
 328:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 329:tmk_core/common/action.c ****                     if (event.pressed) {
 330:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 331:tmk_core/common/action.c ****                             register_mods(mods);
 332:tmk_core/common/action.c ****                         }
 333:tmk_core/common/action.c ****                     } else {
 334:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 335:tmk_core/common/action.c ****                             unregister_mods(mods);
 336:tmk_core/common/action.c ****                         }
 337:tmk_core/common/action.c ****                     }
 338:tmk_core/common/action.c ****                     break;
 339:tmk_core/common/action.c ****                 default:
 340:tmk_core/common/action.c ****                     if (event.pressed) {
 341:tmk_core/common/action.c ****                         if (tap_count > 0) {
 342:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 343:tmk_core/common/action.c ****                             if (
 344:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 345:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 346:tmk_core/common/action.c **** #        endif
 347:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 348:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 349:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 350:tmk_core/common/action.c ****                                 record->tap.count = 0;
 351:tmk_core/common/action.c ****                                 register_mods(mods);
 352:tmk_core/common/action.c ****                             } else
 353:tmk_core/common/action.c **** #    endif
 354:tmk_core/common/action.c ****                             {
 355:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 356:tmk_core/common/action.c ****                                 register_code(action.key.code);
 357:tmk_core/common/action.c ****                             }
 358:tmk_core/common/action.c ****                         } else {
 359:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 360:tmk_core/common/action.c ****                             register_mods(mods);
 361:tmk_core/common/action.c ****                         }
 362:tmk_core/common/action.c ****                     } else {
 363:tmk_core/common/action.c ****                         if (tap_count > 0) {
 364:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 365:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 366:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 367:tmk_core/common/action.c ****                             } else {
 368:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 369:tmk_core/common/action.c ****                             }
 370:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 371:tmk_core/common/action.c ****                         } else {
 372:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 373:tmk_core/common/action.c ****                             unregister_mods(mods);
 374:tmk_core/common/action.c ****                         }
 375:tmk_core/common/action.c ****                     }
 376:tmk_core/common/action.c ****                     break;
 377:tmk_core/common/action.c ****             }
 378:tmk_core/common/action.c ****         } break;
 379:tmk_core/common/action.c **** #endif
 380:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 381:tmk_core/common/action.c ****         /* other HID usage */
 382:tmk_core/common/action.c ****         case ACT_USAGE:
 383:tmk_core/common/action.c ****             switch (action.usage.page) {
 384:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 385:tmk_core/common/action.c ****                     if (event.pressed) {
 386:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 387:tmk_core/common/action.c ****                     } else {
 388:tmk_core/common/action.c ****                         host_system_send(0);
 389:tmk_core/common/action.c ****                     }
 390:tmk_core/common/action.c ****                     break;
 391:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 392:tmk_core/common/action.c ****                     if (event.pressed) {
 393:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 394:tmk_core/common/action.c ****                     } else {
 395:tmk_core/common/action.c ****                         host_consumer_send(0);
 396:tmk_core/common/action.c ****                     }
 397:tmk_core/common/action.c ****                     break;
 398:tmk_core/common/action.c ****             }
 399:tmk_core/common/action.c ****             break;
 400:tmk_core/common/action.c **** #endif
 401:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 402:tmk_core/common/action.c ****         /* Mouse key */
 403:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 404:tmk_core/common/action.c ****             if (event.pressed) {
 405:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 406:tmk_core/common/action.c ****                 switch (action.key.code) {
 407:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 408:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 409:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 410:tmk_core/common/action.c ****                         break;
 411:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 412:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 413:tmk_core/common/action.c ****                         break;
 414:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 415:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 416:tmk_core/common/action.c ****                         break;
 417:tmk_core/common/action.c **** #    endif
 418:tmk_core/common/action.c ****                     default:
 419:tmk_core/common/action.c ****                         mousekey_send();
 420:tmk_core/common/action.c ****                         break;
 421:tmk_core/common/action.c ****                 }
 422:tmk_core/common/action.c ****             } else {
 423:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 424:tmk_core/common/action.c ****                 switch (action.key.code) {
 425:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 426:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 427:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 428:tmk_core/common/action.c ****                         break;
 429:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 430:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 431:tmk_core/common/action.c ****                         break;
 432:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 433:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 434:tmk_core/common/action.c ****                         break;
 435:tmk_core/common/action.c **** #    endif
 436:tmk_core/common/action.c ****                     default:
 437:tmk_core/common/action.c ****                         mousekey_send();
 438:tmk_core/common/action.c ****                         break;
 439:tmk_core/common/action.c ****                 }
 440:tmk_core/common/action.c ****             }
 441:tmk_core/common/action.c ****             break;
 442:tmk_core/common/action.c **** #endif
 443:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 444:tmk_core/common/action.c ****         case ACT_LAYER:
 445:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 446:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 447:tmk_core/common/action.c ****                 if (!event.pressed) {
 448:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 449:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 450:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 451:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 452:tmk_core/common/action.c ****                         case OP_BIT_AND:
 453:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 454:tmk_core/common/action.c ****                             break;
 455:tmk_core/common/action.c ****                         case OP_BIT_OR:
 456:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 457:tmk_core/common/action.c ****                             break;
 458:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 459:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 460:tmk_core/common/action.c ****                             break;
 461:tmk_core/common/action.c ****                         case OP_BIT_SET:
 462:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 463:tmk_core/common/action.c ****                             break;
 464:tmk_core/common/action.c ****                     }
 465:tmk_core/common/action.c ****                 }
 466:tmk_core/common/action.c ****             } else {
 467:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 468:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 469:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 470:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 471:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 472:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 473:tmk_core/common/action.c ****                         case OP_BIT_AND:
 474:tmk_core/common/action.c ****                             layer_and(bits | mask);
 475:tmk_core/common/action.c ****                             break;
 476:tmk_core/common/action.c ****                         case OP_BIT_OR:
 477:tmk_core/common/action.c ****                             layer_or(bits | mask);
 478:tmk_core/common/action.c ****                             break;
 479:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 480:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 481:tmk_core/common/action.c ****                             break;
 482:tmk_core/common/action.c ****                         case OP_BIT_SET:
 483:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 484:tmk_core/common/action.c ****                             break;
 485:tmk_core/common/action.c ****                     }
 486:tmk_core/common/action.c ****                 }
 487:tmk_core/common/action.c ****             }
 488:tmk_core/common/action.c ****             break;
 489:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 490:tmk_core/common/action.c ****             if (event.pressed) {
 491:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 492:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 493:tmk_core/common/action.c ****             } else {
 494:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 495:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 496:tmk_core/common/action.c ****             }
 497:tmk_core/common/action.c ****             break;
 498:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 499:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 500:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 501:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 502:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 503:tmk_core/common/action.c ****                     /* tap toggle */
 504:tmk_core/common/action.c ****                     if (event.pressed) {
 505:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 506:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 507:tmk_core/common/action.c ****                         }
 508:tmk_core/common/action.c ****                     } else {
 509:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 510:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 511:tmk_core/common/action.c ****                         }
 512:tmk_core/common/action.c ****                     }
 513:tmk_core/common/action.c ****                     break;
 514:tmk_core/common/action.c ****                 case OP_ON_OFF:
 515:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 516:tmk_core/common/action.c ****                     break;
 517:tmk_core/common/action.c ****                 case OP_OFF_ON:
 518:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 519:tmk_core/common/action.c ****                     break;
 520:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 521:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 522:tmk_core/common/action.c ****                     break;
 523:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 524:tmk_core/common/action.c ****                 case OP_ONESHOT:
 525:tmk_core/common/action.c ****                     // Oneshot modifier
 526:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 527:tmk_core/common/action.c ****                     do_release_oneshot = false;
 528:tmk_core/common/action.c ****                     if (event.pressed) {
 529:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 530:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 531:tmk_core/common/action.c ****                             reset_oneshot_layer();
 532:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 533:tmk_core/common/action.c ****                             break;
 534:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 535:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 536:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 537:tmk_core/common/action.c ****                         }
 538:tmk_core/common/action.c ****                     } else {
 539:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 540:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 541:tmk_core/common/action.c ****                             reset_oneshot_layer();
 542:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 543:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 544:tmk_core/common/action.c ****                         } else {
 545:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     }
 548:tmk_core/common/action.c **** #            else
 549:tmk_core/common/action.c ****                     if (event.pressed) {
 550:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 551:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 552:tmk_core/common/action.c ****                     } else {
 553:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 554:tmk_core/common/action.c ****                         if (tap_count > 1) {
 555:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 556:tmk_core/common/action.c ****                         }
 557:tmk_core/common/action.c ****                     }
 558:tmk_core/common/action.c **** #            endif
 559:tmk_core/common/action.c ****                     break;
 560:tmk_core/common/action.c **** #        endif
 561:tmk_core/common/action.c ****                 default:
 562:tmk_core/common/action.c ****                     /* tap key */
 563:tmk_core/common/action.c ****                     if (event.pressed) {
 564:tmk_core/common/action.c ****                         if (tap_count > 0) {
 565:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 566:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 567:tmk_core/common/action.c ****                         } else {
 568:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 569:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 570:tmk_core/common/action.c ****                         }
 571:tmk_core/common/action.c ****                     } else {
 572:tmk_core/common/action.c ****                         if (tap_count > 0) {
 573:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 574:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 575:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 576:tmk_core/common/action.c ****                             } else {
 577:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 578:tmk_core/common/action.c ****                             }
 579:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 580:tmk_core/common/action.c ****                         } else {
 581:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 582:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 583:tmk_core/common/action.c ****                         }
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c ****                     break;
 586:tmk_core/common/action.c ****             }
 587:tmk_core/common/action.c ****             break;
 588:tmk_core/common/action.c **** #    endif
 589:tmk_core/common/action.c **** #endif
 590:tmk_core/common/action.c ****             /* Extentions */
 591:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 592:tmk_core/common/action.c ****         case ACT_MACRO:
 593:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 594:tmk_core/common/action.c ****             break;
 595:tmk_core/common/action.c **** #endif
 596:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 597:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 598:tmk_core/common/action.c ****             switch (action.swap.code) {
 599:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 602:tmk_core/common/action.c ****                     }
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 605:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 608:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 609:tmk_core/common/action.c ****                     break;
 610:tmk_core/common/action.c ****                 case OP_SH_ON:
 611:tmk_core/common/action.c ****                     if (!event.pressed) {
 612:tmk_core/common/action.c ****                         swap_hands = true;
 613:tmk_core/common/action.c ****                     }
 614:tmk_core/common/action.c ****                     break;
 615:tmk_core/common/action.c ****                 case OP_SH_OFF:
 616:tmk_core/common/action.c ****                     if (!event.pressed) {
 617:tmk_core/common/action.c ****                         swap_hands = false;
 618:tmk_core/common/action.c ****                     }
 619:tmk_core/common/action.c ****                     break;
 620:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 621:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 622:tmk_core/common/action.c ****                     if (event.pressed) {
 623:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 624:tmk_core/common/action.c ****                     } else {
 625:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 626:tmk_core/common/action.c ****                     }
 627:tmk_core/common/action.c ****                     break;
 628:tmk_core/common/action.c **** #    endif
 629:tmk_core/common/action.c **** 
 630:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 631:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 632:tmk_core/common/action.c ****                     /* tap toggle */
 633:tmk_core/common/action.c **** 
 634:tmk_core/common/action.c ****                     if (event.pressed) {
 635:tmk_core/common/action.c ****                         if (swap_held) {
 636:tmk_core/common/action.c ****                             swap_held = false;
 637:tmk_core/common/action.c ****                         } else {
 638:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 639:tmk_core/common/action.c ****                         }
 640:tmk_core/common/action.c ****                     } else {
 641:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 642:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 643:tmk_core/common/action.c ****                         }
 644:tmk_core/common/action.c ****                     }
 645:tmk_core/common/action.c ****                     break;
 646:tmk_core/common/action.c ****                 default:
 647:tmk_core/common/action.c ****                     /* tap key */
 648:tmk_core/common/action.c ****                     if (tap_count > 0) {
 649:tmk_core/common/action.c ****                         if (swap_held) {
 650:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 651:tmk_core/common/action.c ****                             swap_held  = false;
 652:tmk_core/common/action.c ****                         }
 653:tmk_core/common/action.c ****                         if (event.pressed) {
 654:tmk_core/common/action.c ****                             register_code(action.swap.code);
 655:tmk_core/common/action.c ****                         } else {
 656:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 657:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 658:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 659:tmk_core/common/action.c ****                         }
 660:tmk_core/common/action.c ****                     } else {
 661:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 662:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 663:tmk_core/common/action.c ****                             swap_held  = false;
 664:tmk_core/common/action.c ****                         }
 665:tmk_core/common/action.c ****                     }
 666:tmk_core/common/action.c **** #    endif
 667:tmk_core/common/action.c ****             }
 668:tmk_core/common/action.c **** #endif
 669:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 670:tmk_core/common/action.c ****         case ACT_FUNCTION:
 671:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 672:tmk_core/common/action.c ****             break;
 673:tmk_core/common/action.c **** #endif
 674:tmk_core/common/action.c ****         default:
 675:tmk_core/common/action.c ****             break;
 676:tmk_core/common/action.c ****     }
 677:tmk_core/common/action.c **** 
 678:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 679:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 680:tmk_core/common/action.c ****     switch (action.kind.id) {
 681:tmk_core/common/action.c ****         case ACT_LAYER:
 682:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 683:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 684:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 685:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 686:tmk_core/common/action.c **** #    endif
 687:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 688:tmk_core/common/action.c ****             break;
 689:tmk_core/common/action.c ****         default:
 690:tmk_core/common/action.c ****             break;
 691:tmk_core/common/action.c ****     }
 692:tmk_core/common/action.c **** #endif
 693:tmk_core/common/action.c **** 
 694:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 695:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 696:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 697:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 698:tmk_core/common/action.c ****     } else {
 699:tmk_core/common/action.c ****         if (event.pressed) {
 700:tmk_core/common/action.c ****             if (tap_count > 0) {
 701:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 702:tmk_core/common/action.c ****             } else {
 703:tmk_core/common/action.c ****             }
 704:tmk_core/common/action.c ****         } else {
 705:tmk_core/common/action.c ****             if (tap_count > 0) {
 706:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 707:tmk_core/common/action.c ****             } else {
 708:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 709:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 710:tmk_core/common/action.c ****                 }
 711:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 712:tmk_core/common/action.c ****             }
 713:tmk_core/common/action.c ****         }
 714:tmk_core/common/action.c ****     }
 715:tmk_core/common/action.c **** #    endif
 716:tmk_core/common/action.c **** #endif
 717:tmk_core/common/action.c **** 
 718:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 719:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 720:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 721:tmk_core/common/action.c ****         use_oneshot_swaphands();
 722:tmk_core/common/action.c ****     }
 723:tmk_core/common/action.c **** #    endif
 724:tmk_core/common/action.c **** #endif
 725:tmk_core/common/action.c **** 
 726:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 727:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 728:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 729:tmk_core/common/action.c ****      */
 730:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 731:tmk_core/common/action.c ****         record->event.pressed = false;
 732:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 733:tmk_core/common/action.c ****         process_record(record);
 734:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 735:tmk_core/common/action.c ****     }
 736:tmk_core/common/action.c **** #endif
 737:tmk_core/common/action.c **** }
 738:tmk_core/common/action.c **** 
 739:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 740:tmk_core/common/action.c ****  *
 741:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 742:tmk_core/common/action.c ****  */
 743:tmk_core/common/action.c **** void register_code(uint8_t code) {
 163               		.loc 1 743 34 is_stmt 1 view -0
 164               		.cfi_startproc
 165               		.loc 1 743 34 is_stmt 0 view .LVU23
 166 0000 CF93      		push r28
 167               	.LCFI4:
 168               		.cfi_def_cfa_offset 3
 169               		.cfi_offset 28, -2
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               	/* stack size = 1 */
 173               	.L__stack_usage = 1
 174 0002 C82F      		mov r28,r24
 744:tmk_core/common/action.c ****     if (code == KC_NO) {
 175               		.loc 1 744 5 is_stmt 1 view .LVU24
 176               		.loc 1 744 8 is_stmt 0 view .LVU25
 177 0004 8823      		tst r24
 178 0006 01F0      		breq .L5
 745:tmk_core/common/action.c ****         return;
 746:tmk_core/common/action.c ****     }
 747:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 748:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 749:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 750:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 751:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 752:tmk_core/common/action.c **** #    endif
 753:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 754:tmk_core/common/action.c ****         send_keyboard_report();
 755:tmk_core/common/action.c ****         wait_ms(100);
 756:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 757:tmk_core/common/action.c ****         send_keyboard_report();
 758:tmk_core/common/action.c ****     }
 759:tmk_core/common/action.c **** 
 760:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 761:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 762:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 763:tmk_core/common/action.c **** #    endif
 764:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 765:tmk_core/common/action.c ****         send_keyboard_report();
 766:tmk_core/common/action.c ****         wait_ms(100);
 767:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 768:tmk_core/common/action.c ****         send_keyboard_report();
 769:tmk_core/common/action.c ****     }
 770:tmk_core/common/action.c **** 
 771:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 772:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 773:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 774:tmk_core/common/action.c **** #    endif
 775:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 776:tmk_core/common/action.c ****         send_keyboard_report();
 777:tmk_core/common/action.c ****         wait_ms(100);
 778:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 779:tmk_core/common/action.c ****         send_keyboard_report();
 780:tmk_core/common/action.c ****     }
 781:tmk_core/common/action.c **** #endif
 782:tmk_core/common/action.c **** 
 783:tmk_core/common/action.c ****     else if
 179               		.loc 1 783 10 is_stmt 1 view .LVU26
 784:tmk_core/common/action.c ****         IS_KEY(code) {
 180               		.loc 1 784 9 is_stmt 0 view .LVU27
 181 0008 8CEF      		ldi r24,lo8(-4)
 182               	.LVL11:
 183               		.loc 1 784 9 view .LVU28
 184 000a 8C0F      		add r24,r28
 185 000c 813A      		cpi r24,lo8(-95)
 186 000e 00F4      		brsh .L7
 785:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 786:tmk_core/common/action.c ****             if (command_proc(code)) return;
 187               		.loc 1 786 13 is_stmt 1 view .LVU29
 787:tmk_core/common/action.c **** 
 788:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 789:tmk_core/common/action.c **** /* TODO: remove
 790:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 791:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 792:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 793:tmk_core/common/action.c **** 
 794:tmk_core/common/action.c ****             add_key(code);
 795:tmk_core/common/action.c ****             send_keyboard_report();
 796:tmk_core/common/action.c **** 
 797:tmk_core/common/action.c ****             set_mods(tmp_mods);
 798:tmk_core/common/action.c ****             send_keyboard_report();
 799:tmk_core/common/action.c ****             oneshot_cancel();
 800:tmk_core/common/action.c ****         } else
 801:tmk_core/common/action.c **** */
 802:tmk_core/common/action.c **** #endif
 803:tmk_core/common/action.c ****             {
 804:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 805:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 806:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 807:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 188               		.loc 1 807 17 view .LVU30
 189               		.loc 1 807 21 is_stmt 0 view .LVU31
 190 0010 6C2F      		mov r22,r28
 191 0012 8091 0000 		lds r24,keyboard_report
 192 0016 9091 0000 		lds r25,keyboard_report+1
 193 001a 0E94 0000 		call is_key_pressed
 194               	.LVL12:
 195               		.loc 1 807 20 view .LVU32
 196 001e 8823      		tst r24
 197 0020 01F0      		breq .L8
 808:tmk_core/common/action.c ****                     del_key(code);
 198               		.loc 1 808 21 is_stmt 1 view .LVU33
 199 0022 8C2F      		mov r24,r28
 200 0024 0E94 0000 		call del_key
 201               	.LVL13:
 809:tmk_core/common/action.c ****                     send_keyboard_report();
 202               		.loc 1 809 21 view .LVU34
 203 0028 0E94 0000 		call send_keyboard_report
 204               	.LVL14:
 205               	.L8:
 810:tmk_core/common/action.c ****                 }
 811:tmk_core/common/action.c ****                 add_key(code);
 206               		.loc 1 811 17 view .LVU35
 207 002c 8C2F      		mov r24,r28
 208 002e 0E94 0000 		call add_key
 209               	.LVL15:
 812:tmk_core/common/action.c ****                 send_keyboard_report();
 210               		.loc 1 812 17 view .LVU36
 211               	.L15:
 813:tmk_core/common/action.c ****             }
 814:tmk_core/common/action.c ****         }
 815:tmk_core/common/action.c ****     else if
 816:tmk_core/common/action.c ****         IS_MOD(code) {
 817:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 818:tmk_core/common/action.c ****             send_keyboard_report();
 212               		.loc 1 818 13 view .LVU37
 213               	/* epilogue start */
 819:tmk_core/common/action.c ****         }
 820:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 821:tmk_core/common/action.c ****     else if
 822:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 823:tmk_core/common/action.c ****     else if
 824:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 825:tmk_core/common/action.c **** #endif
 826:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 827:tmk_core/common/action.c ****     else if
 828:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 829:tmk_core/common/action.c ****             mousekey_on(code);
 830:tmk_core/common/action.c ****             mousekey_send();
 831:tmk_core/common/action.c ****         }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** }
 214               		.loc 1 833 1 is_stmt 0 view .LVU38
 215 0032 CF91      		pop r28
 818:tmk_core/common/action.c ****         }
 216               		.loc 1 818 13 view .LVU39
 217 0034 0C94 0000 		jmp send_keyboard_report
 218               	.LVL16:
 219               	.L7:
 815:tmk_core/common/action.c ****         IS_MOD(code) {
 220               		.loc 1 815 10 is_stmt 1 view .LVU40
 816:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 221               		.loc 1 816 9 is_stmt 0 view .LVU41
 222 0038 80E2      		ldi r24,lo8(32)
 223 003a 8C0F      		add r24,r28
 224 003c 8830      		cpi r24,lo8(8)
 225 003e 00F4      		brsh .L5
 817:tmk_core/common/action.c ****             send_keyboard_report();
 226               		.loc 1 817 13 is_stmt 1 view .LVU42
 817:tmk_core/common/action.c ****             send_keyboard_report();
 227               		.loc 1 817 22 is_stmt 0 view .LVU43
 228 0040 C770      		andi r28,lo8(7)
 229               	.LVL17:
 817:tmk_core/common/action.c ****             send_keyboard_report();
 230               		.loc 1 817 13 view .LVU44
 231 0042 81E0      		ldi r24,lo8(1)
 232 0044 00C0      		rjmp 2f
 233               		1:
 234 0046 880F      		lsl r24
 235               		2:
 236 0048 CA95      		dec r28
 237 004a 02F4      		brpl 1b
 238 004c 0E94 0000 		call add_mods
 239               	.LVL18:
 240 0050 00C0      		rjmp .L15
 241               	.LVL19:
 242               	.L5:
 243               	/* epilogue start */
 244               		.loc 1 833 1 view .LVU45
 245 0052 CF91      		pop r28
 246               	.LVL20:
 247               		.loc 1 833 1 view .LVU46
 248 0054 0895      		ret
 249               		.cfi_endproc
 250               	.LFE23:
 252               		.section	.text.unregister_code,"ax",@progbits
 253               	.global	unregister_code
 255               	unregister_code:
 256               	.LVL21:
 257               	.LFB24:
 834:tmk_core/common/action.c **** 
 835:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 836:tmk_core/common/action.c ****  *
 837:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 838:tmk_core/common/action.c ****  */
 839:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 258               		.loc 1 839 36 is_stmt 1 view -0
 259               		.cfi_startproc
 260               	/* prologue: function */
 261               	/* frame size = 0 */
 262               	/* stack size = 0 */
 263               	.L__stack_usage = 0
 840:tmk_core/common/action.c ****     if (code == KC_NO) {
 264               		.loc 1 840 5 view .LVU48
 265               		.loc 1 840 8 is_stmt 0 view .LVU49
 266 0000 8823      		tst r24
 267 0002 01F0      		breq .L16
 841:tmk_core/common/action.c ****         return;
 842:tmk_core/common/action.c ****     }
 843:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 844:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 845:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 846:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 847:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 848:tmk_core/common/action.c **** #    endif
 849:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 850:tmk_core/common/action.c ****         send_keyboard_report();
 851:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 852:tmk_core/common/action.c ****         send_keyboard_report();
 853:tmk_core/common/action.c ****     }
 854:tmk_core/common/action.c **** 
 855:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 856:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 857:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 858:tmk_core/common/action.c **** #    endif
 859:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 860:tmk_core/common/action.c ****         send_keyboard_report();
 861:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 862:tmk_core/common/action.c ****         send_keyboard_report();
 863:tmk_core/common/action.c ****     }
 864:tmk_core/common/action.c **** 
 865:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 866:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 867:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 868:tmk_core/common/action.c **** #    endif
 869:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 870:tmk_core/common/action.c ****         send_keyboard_report();
 871:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 872:tmk_core/common/action.c ****         send_keyboard_report();
 873:tmk_core/common/action.c ****     }
 874:tmk_core/common/action.c **** #endif
 875:tmk_core/common/action.c **** 
 876:tmk_core/common/action.c ****     else if
 268               		.loc 1 876 10 is_stmt 1 view .LVU50
 877:tmk_core/common/action.c ****         IS_KEY(code) {
 269               		.loc 1 877 9 is_stmt 0 view .LVU51
 270 0004 9CEF      		ldi r25,lo8(-4)
 271 0006 980F      		add r25,r24
 272 0008 913A      		cpi r25,lo8(-95)
 273 000a 00F4      		brsh .L18
 878:tmk_core/common/action.c ****             del_key(code);
 274               		.loc 1 878 13 is_stmt 1 view .LVU52
 275 000c 0E94 0000 		call del_key
 276               	.LVL22:
 879:tmk_core/common/action.c ****             send_keyboard_report();
 277               		.loc 1 879 13 view .LVU53
 278               	.L24:
 880:tmk_core/common/action.c ****         }
 881:tmk_core/common/action.c ****     else if
 882:tmk_core/common/action.c ****         IS_MOD(code) {
 883:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 884:tmk_core/common/action.c ****             send_keyboard_report();
 279               		.loc 1 884 13 view .LVU54
 280 0010 0C94 0000 		jmp send_keyboard_report
 281               	.LVL23:
 282               	.L18:
 881:tmk_core/common/action.c ****         IS_MOD(code) {
 283               		.loc 1 881 10 view .LVU55
 882:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 284               		.loc 1 882 9 is_stmt 0 view .LVU56
 285 0014 90E2      		ldi r25,lo8(32)
 286 0016 980F      		add r25,r24
 287 0018 9830      		cpi r25,lo8(8)
 288 001a 00F4      		brsh .L19
 883:tmk_core/common/action.c ****             send_keyboard_report();
 289               		.loc 1 883 13 is_stmt 1 view .LVU57
 883:tmk_core/common/action.c ****             send_keyboard_report();
 290               		.loc 1 883 22 is_stmt 0 view .LVU58
 291 001c 8770      		andi r24,lo8(7)
 292               	.LVL24:
 883:tmk_core/common/action.c ****             send_keyboard_report();
 293               		.loc 1 883 13 view .LVU59
 294 001e 91E0      		ldi r25,lo8(1)
 295 0020 00C0      		rjmp 2f
 296               		1:
 297 0022 990F      		lsl r25
 298               		2:
 299 0024 8A95      		dec r24
 300 0026 02F4      		brpl 1b
 301 0028 892F      		mov r24,r25
 302 002a 0E94 0000 		call del_mods
 303               	.LVL25:
 304 002e 00C0      		rjmp .L24
 305               	.LVL26:
 306               	.L19:
 885:tmk_core/common/action.c ****         }
 886:tmk_core/common/action.c ****     else if
 307               		.loc 1 886 10 is_stmt 1 view .LVU60
 887:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 308               		.loc 1 887 9 is_stmt 0 view .LVU61
 309 0030 9BE5      		ldi r25,lo8(91)
 310 0032 980F      		add r25,r24
 311 0034 9330      		cpi r25,lo8(3)
 312 0036 00F4      		brsh .L20
 313               		.loc 1 887 27 is_stmt 1 discriminator 1 view .LVU62
 314 0038 90E0      		ldi r25,0
 315 003a 80E0      		ldi r24,0
 316               	.LVL27:
 317               		.loc 1 887 27 is_stmt 0 discriminator 1 view .LVU63
 318 003c 0C94 0000 		jmp host_system_send
 319               	.LVL28:
 320               	.L20:
 888:tmk_core/common/action.c ****     else if
 321               		.loc 1 888 10 is_stmt 1 view .LVU64
 889:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 322               		.loc 1 889 9 is_stmt 0 view .LVU65
 323 0040 885A      		subi r24,lo8(-(88))
 324               	.LVL29:
 325               		.loc 1 889 9 view .LVU66
 326 0042 8731      		cpi r24,lo8(23)
 327 0044 00F4      		brsh .L16
 328               		.loc 1 889 29 is_stmt 1 discriminator 1 view .LVU67
 329 0046 90E0      		ldi r25,0
 330 0048 80E0      		ldi r24,0
 331               	.LVL30:
 332               		.loc 1 889 29 is_stmt 0 discriminator 1 view .LVU68
 333 004a 0C94 0000 		jmp host_consumer_send
 334               	.LVL31:
 335               	.L16:
 336               	/* epilogue start */
 890:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 891:tmk_core/common/action.c ****     else if
 892:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 893:tmk_core/common/action.c ****             mousekey_off(code);
 894:tmk_core/common/action.c ****             mousekey_send();
 895:tmk_core/common/action.c ****         }
 896:tmk_core/common/action.c **** #endif
 897:tmk_core/common/action.c **** }
 337               		.loc 1 897 1 view .LVU69
 338 004e 0895      		ret
 339               		.cfi_endproc
 340               	.LFE24:
 342               		.section	.text.tap_code,"ax",@progbits
 343               	.global	tap_code
 345               	tap_code:
 346               	.LVL32:
 347               	.LFB25:
 898:tmk_core/common/action.c **** 
 899:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 900:tmk_core/common/action.c ****  *
 901:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 902:tmk_core/common/action.c ****  */
 903:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 348               		.loc 1 903 29 is_stmt 1 view -0
 349               		.cfi_startproc
 350               		.loc 1 903 29 is_stmt 0 view .LVU71
 351 0000 CF93      		push r28
 352               	.LCFI5:
 353               		.cfi_def_cfa_offset 3
 354               		.cfi_offset 28, -2
 355               	/* prologue: function */
 356               	/* frame size = 0 */
 357               	/* stack size = 1 */
 358               	.L__stack_usage = 1
 359 0002 C82F      		mov r28,r24
 904:tmk_core/common/action.c ****     register_code(code);
 360               		.loc 1 904 5 is_stmt 1 view .LVU72
 361 0004 0E94 0000 		call register_code
 362               	.LVL33:
 905:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 363               		.loc 1 905 5 view .LVU73
 364               		.loc 1 905 8 is_stmt 0 view .LVU74
 365 0008 C933      		cpi r28,lo8(57)
 366 000a 01F4      		brne .L27
 906:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 367               		.loc 1 906 9 is_stmt 1 view .LVU75
 368               	.LVL34:
 369               	.LBB18:
 370               	.LBI18:
 371               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 372               		.loc 2 166 1 view .LVU76
 373               	.LBB19:
 167:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	double __tmp ;
 374               		.loc 2 168 2 view .LVU77
 169:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 375               		.loc 2 172 2 view .LVU78
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 376               		.loc 2 173 2 view .LVU79
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 377               		.loc 2 174 2 view .LVU80
 175:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 378               		.loc 2 184 3 view .LVU81
 185:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 379               		.loc 2 187 2 view .LVU82
 380 000c 2FEF      		ldi r18,lo8(255999)
 381 000e 87EE      		ldi r24,hi8(255999)
 382 0010 93E0      		ldi r25,hlo8(255999)
 383 0012 2150      	1:	subi r18,1
 384 0014 8040      		sbci r24,0
 385 0016 9040      		sbci r25,0
 386 0018 01F4      		brne 1b
 387 001a 00C0      		rjmp .
 388 001c 0000      		nop
 389               	.LVL35:
 390               	.L27:
 391               		.loc 2 187 2 is_stmt 0 view .LVU83
 392               	.LBE19:
 393               	.LBE18:
 907:tmk_core/common/action.c ****     } else {
 908:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 909:tmk_core/common/action.c ****     }
 910:tmk_core/common/action.c ****     unregister_code(code);
 394               		.loc 1 910 5 is_stmt 1 view .LVU84
 395 001e 8C2F      		mov r24,r28
 396               	/* epilogue start */
 911:tmk_core/common/action.c **** }
 397               		.loc 1 911 1 is_stmt 0 view .LVU85
 398 0020 CF91      		pop r28
 399               	.LVL36:
 910:tmk_core/common/action.c **** }
 400               		.loc 1 910 5 view .LVU86
 401 0022 0C94 0000 		jmp unregister_code
 402               	.LVL37:
 910:tmk_core/common/action.c **** }
 403               		.loc 1 910 5 view .LVU87
 404               		.cfi_endproc
 405               	.LFE25:
 407               		.section	.text.register_mods,"ax",@progbits
 408               	.global	register_mods
 410               	register_mods:
 411               	.LVL38:
 412               	.LFB26:
 912:tmk_core/common/action.c **** 
 913:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:tmk_core/common/action.c ****  *
 915:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 916:tmk_core/common/action.c ****  */
 917:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 413               		.loc 1 917 34 is_stmt 1 view -0
 414               		.cfi_startproc
 415               	/* prologue: function */
 416               	/* frame size = 0 */
 417               	/* stack size = 0 */
 418               	.L__stack_usage = 0
 918:tmk_core/common/action.c ****     if (mods) {
 419               		.loc 1 918 5 view .LVU89
 420               		.loc 1 918 8 is_stmt 0 view .LVU90
 421 0000 8823      		tst r24
 422 0002 01F0      		breq .L28
 919:tmk_core/common/action.c ****         add_mods(mods);
 423               		.loc 1 919 9 is_stmt 1 view .LVU91
 424 0004 0E94 0000 		call add_mods
 425               	.LVL39:
 920:tmk_core/common/action.c ****         send_keyboard_report();
 426               		.loc 1 920 9 view .LVU92
 427 0008 0C94 0000 		jmp send_keyboard_report
 428               	.LVL40:
 429               	.L28:
 430               	/* epilogue start */
 921:tmk_core/common/action.c ****     }
 922:tmk_core/common/action.c **** }
 431               		.loc 1 922 1 is_stmt 0 view .LVU93
 432 000c 0895      		ret
 433               		.cfi_endproc
 434               	.LFE26:
 436               		.section	.text.unregister_mods,"ax",@progbits
 437               	.global	unregister_mods
 439               	unregister_mods:
 440               	.LVL41:
 441               	.LFB27:
 923:tmk_core/common/action.c **** 
 924:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:tmk_core/common/action.c ****  *
 926:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:tmk_core/common/action.c ****  */
 928:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 442               		.loc 1 928 36 is_stmt 1 view -0
 443               		.cfi_startproc
 444               	/* prologue: function */
 445               	/* frame size = 0 */
 446               	/* stack size = 0 */
 447               	.L__stack_usage = 0
 929:tmk_core/common/action.c ****     if (mods) {
 448               		.loc 1 929 5 view .LVU95
 449               		.loc 1 929 8 is_stmt 0 view .LVU96
 450 0000 8823      		tst r24
 451 0002 01F0      		breq .L30
 930:tmk_core/common/action.c ****         del_mods(mods);
 452               		.loc 1 930 9 is_stmt 1 view .LVU97
 453 0004 0E94 0000 		call del_mods
 454               	.LVL42:
 931:tmk_core/common/action.c ****         send_keyboard_report();
 455               		.loc 1 931 9 view .LVU98
 456 0008 0C94 0000 		jmp send_keyboard_report
 457               	.LVL43:
 458               	.L30:
 459               	/* epilogue start */
 932:tmk_core/common/action.c ****     }
 933:tmk_core/common/action.c **** }
 460               		.loc 1 933 1 is_stmt 0 view .LVU99
 461 000c 0895      		ret
 462               		.cfi_endproc
 463               	.LFE27:
 465               		.section	.text.process_action,"ax",@progbits
 466               	.global	process_action
 468               	process_action:
 469               	.LVL44:
 470               	.LFB22:
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 471               		.loc 1 227 59 is_stmt 1 view -0
 472               		.cfi_startproc
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 473               		.loc 1 227 59 is_stmt 0 view .LVU101
 474 0000 BF92      		push r11
 475               	.LCFI6:
 476               		.cfi_def_cfa_offset 3
 477               		.cfi_offset 11, -2
 478 0002 CF92      		push r12
 479               	.LCFI7:
 480               		.cfi_def_cfa_offset 4
 481               		.cfi_offset 12, -3
 482 0004 DF92      		push r13
 483               	.LCFI8:
 484               		.cfi_def_cfa_offset 5
 485               		.cfi_offset 13, -4
 486 0006 EF92      		push r14
 487               	.LCFI9:
 488               		.cfi_def_cfa_offset 6
 489               		.cfi_offset 14, -5
 490 0008 FF92      		push r15
 491               	.LCFI10:
 492               		.cfi_def_cfa_offset 7
 493               		.cfi_offset 15, -6
 494 000a 0F93      		push r16
 495               	.LCFI11:
 496               		.cfi_def_cfa_offset 8
 497               		.cfi_offset 16, -7
 498 000c 1F93      		push r17
 499               	.LCFI12:
 500               		.cfi_def_cfa_offset 9
 501               		.cfi_offset 17, -8
 502 000e CF93      		push r28
 503               	.LCFI13:
 504               		.cfi_def_cfa_offset 10
 505               		.cfi_offset 28, -9
 506 0010 DF93      		push r29
 507               	.LCFI14:
 508               		.cfi_def_cfa_offset 11
 509               		.cfi_offset 29, -10
 510               	/* prologue: function */
 511               	/* frame size = 0 */
 512               	/* stack size = 9 */
 513               	.L__stack_usage = 9
 514 0012 7C01      		movw r14,r24
 515 0014 D62F      		mov r29,r22
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 516               		.loc 1 227 59 view .LVU102
 517 0016 C72F      		mov r28,r23
 228:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 518               		.loc 1 228 5 is_stmt 1 view .LVU103
 519               	.LVL45:
 230:tmk_core/common/action.c **** #endif
 520               		.loc 1 230 5 view .LVU104
 230:tmk_core/common/action.c **** #endif
 521               		.loc 1 230 36 is_stmt 0 view .LVU105
 522 0018 FC01      		movw r30,r24
 523 001a 1581      		ldd r17,Z+5
 524 001c 1295      		swap r17
 525 001e 1F70      		andi r17,lo8(15)
 526               	.LVL46:
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 527               		.loc 1 233 5 is_stmt 1 view .LVU106
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 528               		.loc 1 233 14 is_stmt 0 view .LVU107
 529 0020 0281      		ldd r16,Z+2
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 530               		.loc 1 233 8 view .LVU108
 531 0022 0111      		cpse r16,__zero_reg__
 235:tmk_core/common/action.c ****     }
 532               		.loc 1 235 9 is_stmt 1 view .LVU109
 533 0024 0E94 0000 		call clear_weak_mods
 534               	.LVL47:
 535               	.L33:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 536               		.loc 1 239 5 view .LVU110
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 537               		.loc 1 241 5 view .LVU111
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 538               		.loc 1 241 9 is_stmt 0 view .LVU112
 539 0028 0E94 0000 		call is_oneshot_layer_active
 540               	.LVL48:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 541               		.loc 1 241 9 view .LVU113
 542 002c D82E      		mov r13,r24
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 543               		.loc 1 241 8 view .LVU114
 544 002e 8823      		tst r24
 545 0030 01F0      		breq .L34
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 546               		.loc 1 241 35 discriminator 1 view .LVU115
 547 0032 0023      		tst r16
 548 0034 01F0      		breq .L103
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 549               		.loc 1 241 71 discriminator 2 view .LVU116
 550 0036 8C2F      		mov r24,r28
 551 0038 807F      		andi r24,lo8(-16)
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 552               		.loc 1 241 52 discriminator 2 view .LVU117
 553 003a 8034      		cpi r24,lo8(64)
 554 003c 01F0      		breq .L35
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 555               		.loc 1 241 87 discriminator 3 view .LVU118
 556 003e 80E2      		ldi r24,lo8(32)
 557               	.LVL49:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 558               		.loc 1 241 87 discriminator 3 view .LVU119
 559 0040 8D0F      		add r24,r29
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 560               		.loc 1 241 84 discriminator 3 view .LVU120
 561 0042 8830      		cpi r24,lo8(8)
 562 0044 00F0      		brlo .L103
 563               	.L35:
 246:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 564               		.loc 1 246 9 is_stmt 1 view .LVU121
 565 0046 82E0      		ldi r24,lo8(2)
 566 0048 0E94 0000 		call clear_oneshot_layer_state
 567               	.LVL50:
 247:tmk_core/common/action.c ****     }
 568               		.loc 1 247 9 view .LVU122
 247:tmk_core/common/action.c ****     }
 569               		.loc 1 247 31 is_stmt 0 view .LVU123
 570 004c 0E94 0000 		call is_oneshot_layer_active
 571               	.LVL51:
 247:tmk_core/common/action.c ****     }
 572               		.loc 1 247 9 view .LVU124
 573 0050 91E0      		ldi r25,lo8(1)
 574 0052 D82E      		mov r13,r24
 575 0054 D926      		eor r13,r25
 576               	.LVL52:
 577               	.L34:
 251:tmk_core/common/action.c ****         /* Key and Mods */
 578               		.loc 1 251 5 is_stmt 1 view .LVU125
 251:tmk_core/common/action.c ****         /* Key and Mods */
 579               		.loc 1 251 24 is_stmt 0 view .LVU126
 580 0056 CC2E      		mov r12,r28
 581 0058 C294      		swap r12
 582 005a 9FE0      		ldi r25,lo8(15)
 583 005c C922      		and r12,r25
 251:tmk_core/common/action.c ****         /* Key and Mods */
 584               		.loc 1 251 5 view .LVU127
 585 005e FBE0      		ldi r31,lo8(11)
 586 0060 FC15      		cp r31,r12
 587 0062 00F0      		brlo .L36
 588 0064 EC2D      		mov r30,r12
 589 0066 F0E0      		ldi r31,0
 590 0068 E050      		subi r30,lo8(-(gs(.L38)))
 591 006a F040      		sbci r31,hi8(-(gs(.L38)))
 592 006c 0C94 0000 		jmp __tablejump2__
 593               		.section	.jumptables.gcc.process_action,"a",@progbits
 594               		.p2align	1
 595               	.L38:
 596 0000 0000      		.word gs(.L42)
 597 0002 0000      		.word gs(.L42)
 598 0004 0000      		.word gs(.L41)
 599 0006 0000      		.word gs(.L41)
 600 0008 0000      		.word gs(.L36)
 601 000a 0000      		.word gs(.L36)
 602 000c 0000      		.word gs(.L36)
 603 000e 0000      		.word gs(.L36)
 604 0010 0000      		.word gs(.L40)
 605 0012 0000      		.word gs(.L39)
 606 0014 0000      		.word gs(.L37)
 607 0016 0000      		.word gs(.L37)
 608               		.section	.text.process_action
 609               	.LVL53:
 610               	.L103:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 611               		.loc 1 239 10 view .LVU128
 612 0070 D12C      		mov r13,__zero_reg__
 613 0072 00C0      		rjmp .L34
 614               	.LVL54:
 615               	.L42:
 616               	.LBB20:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 617               		.loc 1 255 13 is_stmt 1 view .LVU129
 618 0074 1C2F      		mov r17,r28
 619               	.LVL55:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 620               		.loc 1 255 13 is_stmt 0 view .LVU130
 621 0076 1F70      		andi r17,lo8(15)
 255:tmk_core/common/action.c ****             if (event.pressed) {
 622               		.loc 1 255 44 view .LVU131
 623 0078 C07F      		andi r28,lo8(-16)
 624               	.LVL56:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 625               		.loc 1 255 21 view .LVU132
 626 007a 01F0      		breq .L43
 255:tmk_core/common/action.c ****             if (event.pressed) {
 627               		.loc 1 255 21 discriminator 2 view .LVU133
 628 007c 1295      		swap r17
 629 007e 107F      		andi r17,lo8(-16)
 630               	.L43:
 631               	.LVL57:
 256:tmk_core/common/action.c ****                 if (mods) {
 632               		.loc 1 256 13 is_stmt 1 discriminator 4 view .LVU134
 256:tmk_core/common/action.c ****                 if (mods) {
 633               		.loc 1 256 16 is_stmt 0 discriminator 4 view .LVU135
 634 0080 0023      		tst r16
 635 0082 01F0      		breq .L44
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 636               		.loc 1 257 17 is_stmt 1 view .LVU136
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 637               		.loc 1 257 20 is_stmt 0 view .LVU137
 638 0084 1123      		tst r17
 639 0086 01F0      		breq .L135
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 640               		.loc 1 258 21 is_stmt 1 view .LVU138
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 641               		.loc 1 258 25 is_stmt 0 view .LVU139
 642 0088 80E2      		ldi r24,lo8(32)
 643 008a 8D0F      		add r24,r29
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 644               		.loc 1 258 24 view .LVU140
 645 008c 8830      		cpi r24,lo8(8)
 646 008e 00F0      		brlo .L46
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 647               		.loc 1 258 49 discriminator 1 view .LVU141
 648 0090 D111      		cpse r29,__zero_reg__
 649 0092 00C0      		rjmp .L47
 650               	.L46:
 262:tmk_core/common/action.c ****                     } else {
 651               		.loc 1 262 25 is_stmt 1 view .LVU142
 652 0094 812F      		mov r24,r17
 653 0096 0E94 0000 		call add_mods
 654               	.LVL58:
 655               	.L48:
 266:tmk_core/common/action.c ****                 }
 656               		.loc 1 266 21 view .LVU143
 657 009a 0E94 0000 		call send_keyboard_report
 658               	.LVL59:
 268:tmk_core/common/action.c ****             } else {
 659               		.loc 1 268 17 view .LVU144
 660               	.L135:
 268:tmk_core/common/action.c ****             } else {
 661               		.loc 1 268 17 is_stmt 0 view .LVU145
 662               	.LBE20:
 565:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 663               		.loc 1 565 75 is_stmt 1 view .LVU146
 566:tmk_core/common/action.c ****                         } else {
 664               		.loc 1 566 29 view .LVU147
 665 009e 8D2F      		mov r24,r29
 666 00a0 0E94 0000 		call register_code
 667               	.LVL60:
 668 00a4 00C0      		rjmp .L36
 669               	.LVL61:
 670               	.L47:
 671               	.LBB21:
 264:tmk_core/common/action.c ****                     }
 672               		.loc 1 264 25 view .LVU148
 673 00a6 812F      		mov r24,r17
 674 00a8 0E94 0000 		call add_weak_mods
 675               	.LVL62:
 676 00ac 00C0      		rjmp .L48
 677               	.L44:
 270:tmk_core/common/action.c ****                 if (mods) {
 678               		.loc 1 270 17 view .LVU149
 679 00ae 8D2F      		mov r24,r29
 680 00b0 0E94 0000 		call unregister_code
 681               	.LVL63:
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 682               		.loc 1 271 17 view .LVU150
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 683               		.loc 1 271 20 is_stmt 0 view .LVU151
 684 00b4 1123      		tst r17
 685 00b6 01F0      		breq .L36
 272:tmk_core/common/action.c ****                         del_mods(mods);
 686               		.loc 1 272 21 is_stmt 1 view .LVU152
 272:tmk_core/common/action.c ****                         del_mods(mods);
 687               		.loc 1 272 25 is_stmt 0 view .LVU153
 688 00b8 80E2      		ldi r24,lo8(32)
 689 00ba 8D0F      		add r24,r29
 272:tmk_core/common/action.c ****                         del_mods(mods);
 690               		.loc 1 272 24 view .LVU154
 691 00bc 8830      		cpi r24,lo8(8)
 692 00be 00F0      		brlo .L50
 272:tmk_core/common/action.c ****                         del_mods(mods);
 693               		.loc 1 272 49 discriminator 1 view .LVU155
 694 00c0 D111      		cpse r29,__zero_reg__
 695 00c2 00C0      		rjmp .L51
 696               	.L50:
 273:tmk_core/common/action.c ****                     } else {
 697               		.loc 1 273 25 is_stmt 1 view .LVU156
 698 00c4 812F      		mov r24,r17
 699 00c6 0E94 0000 		call del_mods
 700               	.LVL64:
 701               	.L52:
 277:tmk_core/common/action.c ****                 }
 702               		.loc 1 277 21 view .LVU157
 703 00ca 0E94 0000 		call send_keyboard_report
 704               	.LVL65:
 705               	.L36:
 277:tmk_core/common/action.c ****                 }
 706               		.loc 1 277 21 is_stmt 0 view .LVU158
 707               	.LBE21:
 680:tmk_core/common/action.c ****         case ACT_LAYER:
 708               		.loc 1 680 5 is_stmt 1 view .LVU159
 709 00ce EC2D      		mov r30,r12
 710 00d0 E850      		subi r30,8
 711 00d2 FF0B      		sbc r31,r31
 712 00d4 3497      		sbiw r30,4
 713 00d6 00F4      		brsh .L98
 687:tmk_core/common/action.c ****             break;
 714               		.loc 1 687 13 view .LVU160
 715 00d8 0E94 0000 		call host_keyboard_leds
 716               	.LVL66:
 717 00dc 0E94 0000 		call led_set
 718               	.LVL67:
 688:tmk_core/common/action.c ****         default:
 719               		.loc 1 688 13 view .LVU161
 720               	.L98:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 721               		.loc 1 730 5 view .LVU162
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 722               		.loc 1 730 8 is_stmt 0 view .LVU163
 723 00e0 DD20      		tst r13
 724 00e2 01F4      		brne .+2
 725 00e4 00C0      		rjmp .L32
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 726               		.loc 1 730 33 discriminator 1 view .LVU164
 727 00e6 0E94 0000 		call get_oneshot_layer_state
 728               	.LVL68:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 729               		.loc 1 730 28 discriminator 1 view .LVU165
 730 00ea 80FD      		sbrc r24,0
 731 00ec 00C0      		rjmp .L32
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 732               		.loc 1 731 9 is_stmt 1 view .LVU166
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 733               		.loc 1 731 31 is_stmt 0 view .LVU167
 734 00ee F701      		movw r30,r14
 735 00f0 1282      		std Z+2,__zero_reg__
 732:tmk_core/common/action.c ****         process_record(record);
 736               		.loc 1 732 9 is_stmt 1 view .LVU168
 737 00f2 0E94 0000 		call get_oneshot_layer
 738               	.LVL69:
 739 00f6 0E94 0000 		call layer_on
 740               	.LVL70:
 733:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 741               		.loc 1 733 9 view .LVU169
 742 00fa C701      		movw r24,r14
 743 00fc 0E94 0000 		call process_record
 744               	.LVL71:
 734:tmk_core/common/action.c ****     }
 745               		.loc 1 734 9 view .LVU170
 746 0100 0E94 0000 		call get_oneshot_layer
 747               	.LVL72:
 748               	/* epilogue start */
 737:tmk_core/common/action.c **** 
 749               		.loc 1 737 1 is_stmt 0 view .LVU171
 750 0104 DF91      		pop r29
 751               	.LVL73:
 737:tmk_core/common/action.c **** 
 752               		.loc 1 737 1 view .LVU172
 753 0106 CF91      		pop r28
 737:tmk_core/common/action.c **** 
 754               		.loc 1 737 1 view .LVU173
 755 0108 1F91      		pop r17
 756 010a 0F91      		pop r16
 757 010c FF90      		pop r15
 758 010e EF90      		pop r14
 759               	.LVL74:
 737:tmk_core/common/action.c **** 
 760               		.loc 1 737 1 view .LVU174
 761 0110 DF90      		pop r13
 762               	.LVL75:
 737:tmk_core/common/action.c **** 
 763               		.loc 1 737 1 view .LVU175
 764 0112 CF90      		pop r12
 765 0114 BF90      		pop r11
 734:tmk_core/common/action.c ****     }
 766               		.loc 1 734 9 view .LVU176
 767 0116 0C94 0000 		jmp layer_off
 768               	.LVL76:
 769               	.L51:
 770               	.LBB22:
 275:tmk_core/common/action.c ****                     }
 771               		.loc 1 275 25 is_stmt 1 view .LVU177
 772 011a 812F      		mov r24,r17
 773 011c 0E94 0000 		call del_weak_mods
 774               	.LVL77:
 775 0120 00C0      		rjmp .L52
 776               	.LVL78:
 777               	.L41:
 275:tmk_core/common/action.c ****                     }
 778               		.loc 1 275 25 is_stmt 0 view .LVU178
 779               	.LBE22:
 780               	.LBB23:
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 781               		.loc 1 284 13 is_stmt 1 view .LVU179
 782 0122 2C2F      		mov r18,r28
 783 0124 2F70      		andi r18,lo8(15)
 784 0126 B22E      		mov r11,r18
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 785               		.loc 1 284 44 is_stmt 0 view .LVU180
 786 0128 C07F      		andi r28,lo8(-16)
 787               	.LVL79:
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 788               		.loc 1 284 21 view .LVU181
 789 012a C032      		cpi r28,lo8(32)
 790 012c 01F0      		breq .L53
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 791               		.loc 1 284 21 discriminator 2 view .LVU182
 792 012e B294      		swap r11
 793 0130 80EF      		ldi r24,lo8(-16)
 794 0132 B822      		and r11,r24
 795               	.L53:
 796               	.LVL80:
 285:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 797               		.loc 1 285 13 is_stmt 1 discriminator 4 view .LVU183
 798 0134 DD23      		tst r29
 799 0136 01F0      		breq .L54
 800 0138 D130      		cpi r29,lo8(1)
 801 013a 01F0      		breq .L55
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 802               		.loc 1 340 21 view .LVU184
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 803               		.loc 1 340 24 is_stmt 0 view .LVU185
 804 013c 0023      		tst r16
 805 013e 01F0      		breq .L63
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 806               		.loc 1 341 25 is_stmt 1 view .LVU186
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 807               		.loc 1 341 28 is_stmt 0 view .LVU187
 808 0140 1123      		tst r17
 809 0142 01F0      		breq .L64
 810 0144 00C0      		rjmp .L135
 811               	.L54:
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 812               		.loc 1 289 21 is_stmt 1 view .LVU188
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 813               		.loc 1 289 24 is_stmt 0 view .LVU189
 814 0146 0023      		tst r16
 815 0148 01F0      		breq .L57
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 816               		.loc 1 290 25 is_stmt 1 view .LVU190
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 817               		.loc 1 290 28 is_stmt 0 view .LVU191
 818 014a 1111      		cpse r17,__zero_reg__
 819 014c 00C0      		rjmp .L58
 820               	.L59:
 304:tmk_core/common/action.c ****                         }
 821               		.loc 1 304 29 is_stmt 1 view .LVU192
 304:tmk_core/common/action.c ****                         }
 822               		.loc 1 304 50 is_stmt 0 view .LVU193
 823 014e 0E94 0000 		call get_oneshot_mods
 824               	.LVL81:
 304:tmk_core/common/action.c ****                         }
 825               		.loc 1 304 29 view .LVU194
 826 0152 8B29      		or r24,r11
 827               	.LVL82:
 828               	.L134:
 304:tmk_core/common/action.c ****                         }
 829               		.loc 1 304 29 view .LVU195
 830               	.LBE23:
 492:tmk_core/common/action.c ****             } else {
 831               		.loc 1 492 17 view .LVU196
 832 0154 0E94 0000 		call register_mods
 833               	.LVL83:
 834 0158 00C0      		rjmp .L36
 835               	.LVL84:
 836               	.L58:
 837               	.LBB26:
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 838               		.loc 1 293 32 is_stmt 1 view .LVU197
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 839               		.loc 1 293 35 is_stmt 0 view .LVU198
 840 015a 1130      		cpi r17,lo8(1)
 841 015c 01F4      		brne .L59
 294:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 842               		.loc 1 294 65 is_stmt 1 view .LVU199
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 843               		.loc 1 295 29 view .LVU200
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 844               		.loc 1 295 53 is_stmt 0 view .LVU201
 845 015e 0E94 0000 		call get_oneshot_mods
 846               	.LVL85:
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 847               		.loc 1 295 29 view .LVU202
 848 0162 8B29      		or r24,r11
 849 0164 0E94 0000 		call set_oneshot_mods
 850               	.LVL86:
 851 0168 00C0      		rjmp .L36
 852               	.L57:
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 853               		.loc 1 307 25 is_stmt 1 view .LVU203
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 854               		.loc 1 307 28 is_stmt 0 view .LVU204
 855 016a 1111      		cpse r17,__zero_reg__
 856 016c 00C0      		rjmp .L60
 857               	.L136:
 322:tmk_core/common/action.c ****                             unregister_mods(mods);
 858               		.loc 1 322 29 is_stmt 1 view .LVU205
 859 016e 0E94 0000 		call clear_oneshot_mods
 860               	.LVL87:
 323:tmk_core/common/action.c ****                         }
 861               		.loc 1 323 29 view .LVU206
 862               	.L65:
 372:tmk_core/common/action.c ****                             unregister_mods(mods);
 863               		.loc 1 372 67 view .LVU207
 373:tmk_core/common/action.c ****                         }
 864               		.loc 1 373 29 view .LVU208
 865 0172 8B2D      		mov r24,r11
 866 0174 0E94 0000 		call unregister_mods
 867               	.LVL88:
 868 0178 00C0      		rjmp .L36
 869               	.L60:
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 870               		.loc 1 310 32 view .LVU209
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 871               		.loc 1 310 35 is_stmt 0 view .LVU210
 872 017a 1130      		cpi r17,lo8(1)
 873 017c 01F4      		brne .+2
 874 017e 00C0      		rjmp .L36
 875 0180 00C0      		rjmp .L136
 876               	.L55:
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 877               		.loc 1 329 21 is_stmt 1 view .LVU211
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 878               		.loc 1 329 24 is_stmt 0 view .LVU212
 879 0182 0023      		tst r16
 880 0184 01F0      		breq .L62
 330:tmk_core/common/action.c ****                             register_mods(mods);
 881               		.loc 1 330 25 is_stmt 1 view .LVU213
 330:tmk_core/common/action.c ****                             register_mods(mods);
 882               		.loc 1 330 28 is_stmt 0 view .LVU214
 883 0186 1630      		cpi r17,lo8(6)
 884 0188 00F0      		brlo .+2
 885 018a 00C0      		rjmp .L36
 886               	.L64:
 359:tmk_core/common/action.c ****                             register_mods(mods);
 887               		.loc 1 359 67 is_stmt 1 view .LVU215
 360:tmk_core/common/action.c ****                         }
 888               		.loc 1 360 29 view .LVU216
 889 018c 8B2D      		mov r24,r11
 890 018e 00C0      		rjmp .L134
 891               	.L62:
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 892               		.loc 1 334 25 view .LVU217
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 893               		.loc 1 334 28 is_stmt 0 view .LVU218
 894 0190 1530      		cpi r17,lo8(5)
 895 0192 00F0      		brlo .+2
 896 0194 00C0      		rjmp .L36
 897 0196 00C0      		rjmp .L65
 898               	.L63:
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 899               		.loc 1 363 25 is_stmt 1 view .LVU219
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 900               		.loc 1 363 28 is_stmt 0 view .LVU220
 901 0198 1123      		tst r17
 902 019a 01F0      		breq .L65
 364:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 903               		.loc 1 364 71 is_stmt 1 view .LVU221
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 904               		.loc 1 365 29 view .LVU222
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 905               		.loc 1 365 32 is_stmt 0 view .LVU223
 906 019c D933      		cpi r29,lo8(57)
 907 019e 01F4      		brne .L97
 366:tmk_core/common/action.c ****                             } else {
 908               		.loc 1 366 33 is_stmt 1 view .LVU224
 909               	.LVL89:
 910               	.LBB24:
 911               	.LBI24:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 912               		.loc 2 166 1 view .LVU225
 913               	.LBB25:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 914               		.loc 2 168 2 view .LVU226
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 915               		.loc 2 172 2 view .LVU227
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 916               		.loc 2 173 2 view .LVU228
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 917               		.loc 2 174 2 view .LVU229
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 918               		.loc 2 184 3 view .LVU230
 919               		.loc 2 187 2 view .LVU231
 920 01a0 3FEF      		ldi r19,lo8(255999)
 921 01a2 87EE      		ldi r24,hi8(255999)
 922 01a4 93E0      		ldi r25,hlo8(255999)
 923 01a6 3150      	1:	subi r19,1
 924 01a8 8040      		sbci r24,0
 925 01aa 9040      		sbci r25,0
 926 01ac 01F4      		brne 1b
 927               	.LVL90:
 928               	.L137:
 929               		.loc 2 187 2 is_stmt 0 view .LVU232
 930               	.LBE25:
 931               	.LBE24:
 932               	.LBE26:
 933               	.LBB27:
 934               	.LBB28:
 935 01ae 00C0      		rjmp .
 936 01b0 0000      		nop
 937               	.L97:
 938               	.LBE28:
 939               	.LBE27:
 579:tmk_core/common/action.c ****                         } else {
 940               		.loc 1 579 29 is_stmt 1 view .LVU233
 941 01b2 8D2F      		mov r24,r29
 942 01b4 0E94 0000 		call unregister_code
 943               	.LVL91:
 944 01b8 00C0      		rjmp .L36
 945               	.L40:
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 946               		.loc 1 445 13 view .LVU234
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 947               		.loc 1 445 39 is_stmt 0 view .LVU235
 948 01ba 8C2F      		mov r24,r28
 949 01bc 8370      		andi r24,lo8(3)
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 950               		.loc 1 445 16 view .LVU236
 951 01be 01F0      		breq .+2
 952 01c0 00C0      		rjmp .L68
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 953               		.loc 1 447 17 is_stmt 1 view .LVU237
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 954               		.loc 1 447 20 is_stmt 0 view .LVU238
 955 01c2 0111      		cpse r16,__zero_reg__
 956 01c4 00C0      		rjmp .L36
 957               	.LBB30:
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 958               		.loc 1 448 21 is_stmt 1 view .LVU239
 959               	.LVL92:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 960               		.loc 1 449 21 view .LVU240
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 961               		.loc 1 448 61 is_stmt 0 view .LVU241
 962 01c6 4D2F      		mov r20,r29
 963 01c8 4295      		swap r20
 964 01ca 4695      		lsr r20
 965 01cc 4770      		andi r20,lo8(7)
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 966               		.loc 1 448 35 view .LVU242
 967 01ce 440F      		lsl r20
 968 01d0 440F      		lsl r20
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 969               		.loc 1 449 77 view .LVU243
 970 01d2 0D2F      		mov r16,r29
 971               	.LVL93:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 972               		.loc 1 449 77 view .LVU244
 973 01d4 0F70      		andi r16,lo8(15)
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 974               		.loc 1 449 44 view .LVU245
 975 01d6 10E0      		ldi r17,0
 976               	.LVL94:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 977               		.loc 1 449 44 view .LVU246
 978 01d8 30E0      		ldi r19,0
 979 01da 20E0      		ldi r18,0
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 980               		.loc 1 449 35 view .LVU247
 981 01dc 042E      		mov r0,r20
 982 01de 00C0      		rjmp 2f
 983               		1:
 984 01e0 000F      		lsl r16
 985 01e2 111F      		rol r17
 986 01e4 221F      		rol r18
 987 01e6 331F      		rol r19
 988               		2:
 989 01e8 0A94      		dec r0
 990 01ea 02F4      		brpl 1b
 991               	.LVL95:
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 992               		.loc 1 450 21 is_stmt 1 view .LVU248
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 993               		.loc 1 450 104 is_stmt 0 view .LVU249
 994 01ec 60E0      		ldi r22,0
 995 01ee 70E0      		ldi r23,0
 996 01f0 CB01      		movw r24,r22
 997 01f2 D4FF      		sbrs r29,4
 998 01f4 00C0      		rjmp .L69
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 999               		.loc 1 450 94 discriminator 1 view .LVU250
 1000 01f6 6FE0      		ldi r22,lo8(15)
 1001 01f8 70E0      		ldi r23,0
 1002 01fa 80E0      		ldi r24,0
 1003 01fc 90E0      		ldi r25,0
 1004 01fe 00C0      		rjmp 2f
 1005               		1:
 1006 0200 660F      		lsl r22
 1007 0202 771F      		rol r23
 1008 0204 881F      		rol r24
 1009 0206 991F      		rol r25
 1010               		2:
 1011 0208 4A95      		dec r20
 1012 020a 02F4      		brpl 1b
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1013               		.loc 1 450 104 discriminator 1 view .LVU251
 1014 020c 6095      		com r22
 1015 020e 7095      		com r23
 1016 0210 8095      		com r24
 1017 0212 9095      		com r25
 1018               	.L69:
 1019               	.LVL96:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1020               		.loc 1 451 21 is_stmt 1 discriminator 4 view .LVU252
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1021               		.loc 1 451 47 is_stmt 0 discriminator 4 view .LVU253
 1022 0214 C695      		lsr r28
 1023 0216 C695      		lsr r28
 1024               	.LVL97:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1025               		.loc 1 451 47 discriminator 4 view .LVU254
 1026 0218 C370      		andi r28,lo8(3)
 1027 021a 602B      		or r22,r16
 1028               	.LVL98:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1029               		.loc 1 451 47 discriminator 4 view .LVU255
 1030 021c 712B      		or r23,r17
 1031 021e 822B      		or r24,r18
 1032 0220 932B      		or r25,r19
 1033 0222 C230      		cpi r28,lo8(2)
 1034 0224 01F0      		breq .L70
 1035 0226 00F4      		brsh .L71
 1036 0228 C130      		cpi r28,lo8(1)
 1037 022a 01F0      		breq .L72
 453:tmk_core/common/action.c ****                             break;
 1038               		.loc 1 453 29 is_stmt 1 view .LVU256
 1039 022c 0E94 0000 		call default_layer_and
 1040               	.LVL99:
 454:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1041               		.loc 1 454 29 view .LVU257
 1042 0230 00C0      		rjmp .L36
 1043               	.L72:
 456:tmk_core/common/action.c ****                             break;
 1044               		.loc 1 456 29 view .LVU258
 1045 0232 0E94 0000 		call default_layer_or
 1046               	.LVL100:
 457:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1047               		.loc 1 457 29 view .LVU259
 1048 0236 00C0      		rjmp .L36
 1049               	.L70:
 459:tmk_core/common/action.c ****                             break;
 1050               		.loc 1 459 29 view .LVU260
 1051 0238 0E94 0000 		call default_layer_xor
 1052               	.LVL101:
 460:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1053               		.loc 1 460 29 view .LVU261
 1054 023c 00C0      		rjmp .L36
 1055               	.L71:
 462:tmk_core/common/action.c ****                             break;
 1056               		.loc 1 462 29 view .LVU262
 1057 023e 0E94 0000 		call default_layer_set
 1058               	.LVL102:
 463:tmk_core/common/action.c ****                     }
 1059               		.loc 1 463 29 view .LVU263
 1060 0242 00C0      		rjmp .L36
 1061               	.LVL103:
 1062               	.L68:
 463:tmk_core/common/action.c ****                     }
 1063               		.loc 1 463 29 is_stmt 0 view .LVU264
 1064               	.LBE30:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1065               		.loc 1 468 17 is_stmt 1 view .LVU265
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1066               		.loc 1 468 21 is_stmt 0 view .LVU266
 1067 0244 8695      		lsr r24
 1068 0246 0023      		tst r16
 1069 0248 01F0      		breq .L74
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1070               		.loc 1 468 21 discriminator 1 view .LVU267
 1071 024a 8C2F      		mov r24,r28
 1072 024c 8170      		andi r24,lo8(1)
 1073               	.L74:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1074               		.loc 1 468 20 discriminator 4 view .LVU268
 1075 024e 8823      		tst r24
 1076 0250 01F4      		brne .+2
 1077 0252 00C0      		rjmp .L36
 1078               	.LBB31:
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1079               		.loc 1 469 21 is_stmt 1 view .LVU269
 1080               	.LVL104:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1081               		.loc 1 470 21 view .LVU270
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1082               		.loc 1 469 61 is_stmt 0 view .LVU271
 1083 0254 4D2F      		mov r20,r29
 1084 0256 4295      		swap r20
 1085 0258 4695      		lsr r20
 1086 025a 4770      		andi r20,lo8(7)
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1087               		.loc 1 469 35 view .LVU272
 1088 025c 440F      		lsl r20
 1089 025e 440F      		lsl r20
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1090               		.loc 1 470 77 view .LVU273
 1091 0260 0D2F      		mov r16,r29
 1092               	.LVL105:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1093               		.loc 1 470 77 view .LVU274
 1094 0262 0F70      		andi r16,lo8(15)
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1095               		.loc 1 470 44 view .LVU275
 1096 0264 10E0      		ldi r17,0
 1097               	.LVL106:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1098               		.loc 1 470 44 view .LVU276
 1099 0266 30E0      		ldi r19,0
 1100 0268 20E0      		ldi r18,0
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1101               		.loc 1 470 35 view .LVU277
 1102 026a 042E      		mov r0,r20
 1103 026c 00C0      		rjmp 2f
 1104               		1:
 1105 026e 000F      		lsl r16
 1106 0270 111F      		rol r17
 1107 0272 221F      		rol r18
 1108 0274 331F      		rol r19
 1109               		2:
 1110 0276 0A94      		dec r0
 1111 0278 02F4      		brpl 1b
 1112               	.LVL107:
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1113               		.loc 1 471 21 is_stmt 1 view .LVU278
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1114               		.loc 1 471 104 is_stmt 0 view .LVU279
 1115 027a 60E0      		ldi r22,0
 1116 027c 70E0      		ldi r23,0
 1117 027e CB01      		movw r24,r22
 1118 0280 D4FF      		sbrs r29,4
 1119 0282 00C0      		rjmp .L75
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1120               		.loc 1 471 94 discriminator 1 view .LVU280
 1121 0284 6FE0      		ldi r22,lo8(15)
 1122 0286 70E0      		ldi r23,0
 1123 0288 80E0      		ldi r24,0
 1124 028a 90E0      		ldi r25,0
 1125 028c 00C0      		rjmp 2f
 1126               		1:
 1127 028e 660F      		lsl r22
 1128 0290 771F      		rol r23
 1129 0292 881F      		rol r24
 1130 0294 991F      		rol r25
 1131               		2:
 1132 0296 4A95      		dec r20
 1133 0298 02F4      		brpl 1b
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1134               		.loc 1 471 104 discriminator 1 view .LVU281
 1135 029a 6095      		com r22
 1136 029c 7095      		com r23
 1137 029e 8095      		com r24
 1138 02a0 9095      		com r25
 1139               	.L75:
 1140               	.LVL108:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1141               		.loc 1 472 21 is_stmt 1 discriminator 4 view .LVU282
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1142               		.loc 1 472 47 is_stmt 0 discriminator 4 view .LVU283
 1143 02a2 C695      		lsr r28
 1144 02a4 C695      		lsr r28
 1145               	.LVL109:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1146               		.loc 1 472 47 discriminator 4 view .LVU284
 1147 02a6 C370      		andi r28,lo8(3)
 1148 02a8 602B      		or r22,r16
 1149               	.LVL110:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1150               		.loc 1 472 47 discriminator 4 view .LVU285
 1151 02aa 712B      		or r23,r17
 1152 02ac 822B      		or r24,r18
 1153 02ae 932B      		or r25,r19
 1154 02b0 C230      		cpi r28,lo8(2)
 1155 02b2 01F0      		breq .L76
 1156 02b4 00F4      		brsh .L77
 1157 02b6 C130      		cpi r28,lo8(1)
 1158 02b8 01F0      		breq .L78
 474:tmk_core/common/action.c ****                             break;
 1159               		.loc 1 474 29 is_stmt 1 view .LVU286
 1160 02ba 0E94 0000 		call layer_and
 1161               	.LVL111:
 475:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1162               		.loc 1 475 29 view .LVU287
 1163 02be 00C0      		rjmp .L36
 1164               	.L78:
 477:tmk_core/common/action.c ****                             break;
 1165               		.loc 1 477 29 view .LVU288
 1166 02c0 0E94 0000 		call layer_or
 1167               	.LVL112:
 478:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1168               		.loc 1 478 29 view .LVU289
 1169 02c4 00C0      		rjmp .L36
 1170               	.L76:
 480:tmk_core/common/action.c ****                             break;
 1171               		.loc 1 480 29 view .LVU290
 1172 02c6 0E94 0000 		call layer_xor
 1173               	.LVL113:
 481:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1174               		.loc 1 481 29 view .LVU291
 1175 02ca 00C0      		rjmp .L36
 1176               	.L77:
 483:tmk_core/common/action.c ****                             break;
 1177               		.loc 1 483 29 view .LVU292
 1178 02cc 0E94 0000 		call layer_state_set
 1179               	.LVL114:
 484:tmk_core/common/action.c ****                     }
 1180               		.loc 1 484 29 view .LVU293
 1181 02d0 00C0      		rjmp .L36
 1182               	.LVL115:
 1183               	.L39:
 484:tmk_core/common/action.c ****                     }
 1184               		.loc 1 484 29 is_stmt 0 view .LVU294
 1185               	.LBE31:
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1186               		.loc 1 490 13 is_stmt 1 view .LVU295
 1187 02d2 CF70      		andi r28,lo8(15)
 1188               	.LVL116:
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1189               		.loc 1 490 16 is_stmt 0 view .LVU296
 1190 02d4 0023      		tst r16
 1191 02d6 01F0      		breq .L79
 491:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1192               		.loc 1 491 17 is_stmt 1 view .LVU297
 1193 02d8 8C2F      		mov r24,r28
 1194 02da 0E94 0000 		call layer_on
 1195               	.LVL117:
 492:tmk_core/common/action.c ****             } else {
 1196               		.loc 1 492 17 view .LVU298
 1197 02de 8D2F      		mov r24,r29
 1198 02e0 00C0      		rjmp .L134
 1199               	.L79:
 494:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1200               		.loc 1 494 17 view .LVU299
 1201 02e2 8D2F      		mov r24,r29
 1202 02e4 0E94 0000 		call unregister_mods
 1203               	.LVL118:
 495:tmk_core/common/action.c ****             }
 1204               		.loc 1 495 17 view .LVU300
 1205 02e8 8C2F      		mov r24,r28
 1206               	.LVL119:
 1207               	.L132:
 582:tmk_core/common/action.c ****                         }
 1208               		.loc 1 582 29 is_stmt 0 view .LVU301
 1209 02ea 0E94 0000 		call layer_off
 1210               	.LVL120:
 1211 02ee 00C0      		rjmp .L36
 1212               	.L37:
 501:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1213               		.loc 1 501 13 is_stmt 1 view .LVU302
 1214 02f0 D23F      		cpi r29,lo8(-14)
 1215 02f2 01F0      		breq .L80
 1216 02f4 00F4      		brsh .L81
 1217 02f6 D03F      		cpi r29,lo8(-16)
 1218 02f8 01F0      		breq .L82
 1219 02fa D13F      		cpi r29,lo8(-15)
 1220 02fc 01F0      		breq .L83
 1221               	.L84:
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1222               		.loc 1 563 21 view .LVU303
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1223               		.loc 1 563 24 is_stmt 0 view .LVU304
 1224 02fe 0023      		tst r16
 1225 0300 01F4      		brne .+2
 1226 0302 00C0      		rjmp .L93
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1227               		.loc 1 564 25 is_stmt 1 view .LVU305
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1228               		.loc 1 564 28 is_stmt 0 view .LVU306
 1229 0304 1111      		cpse r17,__zero_reg__
 1230 0306 00C0      		rjmp .L135
 568:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1231               		.loc 1 568 76 is_stmt 1 view .LVU307
 569:tmk_core/common/action.c ****                         }
 1232               		.loc 1 569 29 view .LVU308
 1233 0308 8C2F      		mov r24,r28
 1234 030a 8F71      		andi r24,lo8(31)
 1235 030c 00C0      		rjmp .L131
 1236               	.L81:
 1237 030e D33F      		cpi r29,lo8(-13)
 1238 0310 01F0      		breq .L85
 1239 0312 D43F      		cpi r29,lo8(-12)
 1240 0314 01F4      		brne .L84
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1241               		.loc 1 549 21 view .LVU309
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1242               		.loc 1 549 24 is_stmt 0 view .LVU310
 1243 0316 0023      		tst r16
 1244 0318 01F0      		breq .L92
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1245               		.loc 1 550 25 is_stmt 1 view .LVU311
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1246               		.loc 1 550 50 is_stmt 0 view .LVU312
 1247 031a CF71      		andi r28,lo8(31)
 1248               	.LVL121:
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1249               		.loc 1 550 25 view .LVU313
 1250 031c 8C2F      		mov r24,r28
 1251 031e 0E94 0000 		call layer_on
 1252               	.LVL122:
 551:tmk_core/common/action.c ****                     } else {
 1253               		.loc 1 551 25 is_stmt 1 view .LVU314
 1254 0322 63E0      		ldi r22,lo8(3)
 1255 0324 8C2F      		mov r24,r28
 1256 0326 0E94 0000 		call set_oneshot_layer
 1257               	.LVL123:
 1258 032a 00C0      		rjmp .L36
 1259               	.LVL124:
 1260               	.L82:
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1261               		.loc 1 504 21 view .LVU315
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1262               		.loc 1 504 24 is_stmt 0 view .LVU316
 1263 032c 0023      		tst r16
 1264 032e 01F0      		breq .L87
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1265               		.loc 1 505 25 is_stmt 1 view .LVU317
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1266               		.loc 1 505 28 is_stmt 0 view .LVU318
 1267 0330 1530      		cpi r17,lo8(5)
 1268 0332 00F0      		brlo .+2
 1269 0334 00C0      		rjmp .L36
 1270               	.L88:
 506:tmk_core/common/action.c ****                         }
 1271               		.loc 1 506 29 is_stmt 1 view .LVU319
 1272 0336 8C2F      		mov r24,r28
 1273 0338 8F71      		andi r24,lo8(31)
 1274 033a 0E94 0000 		call layer_invert
 1275               	.LVL125:
 1276 033e 00C0      		rjmp .L36
 1277               	.L87:
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1278               		.loc 1 509 25 view .LVU320
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1279               		.loc 1 509 28 is_stmt 0 view .LVU321
 1280 0340 1630      		cpi r17,lo8(6)
 1281 0342 00F0      		brlo .+2
 1282 0344 00C0      		rjmp .L36
 1283 0346 00C0      		rjmp .L88
 1284               	.L83:
 515:tmk_core/common/action.c ****                     break;
 1285               		.loc 1 515 21 is_stmt 1 view .LVU322
 1286 0348 8C2F      		mov r24,r28
 1287 034a 8F71      		andi r24,lo8(31)
 515:tmk_core/common/action.c ****                     break;
 1288               		.loc 1 515 68 is_stmt 0 view .LVU323
 1289 034c 0023      		tst r16
 1290 034e 01F0      		breq .L132
 1291               	.L131:
 569:tmk_core/common/action.c ****                         }
 1292               		.loc 1 569 29 view .LVU324
 1293 0350 0E94 0000 		call layer_on
 1294               	.LVL126:
 1295 0354 00C0      		rjmp .L36
 1296               	.L80:
 518:tmk_core/common/action.c ****                     break;
 1297               		.loc 1 518 21 is_stmt 1 view .LVU325
 1298 0356 8C2F      		mov r24,r28
 1299 0358 8F71      		andi r24,lo8(31)
 518:tmk_core/common/action.c ****                     break;
 1300               		.loc 1 518 69 is_stmt 0 view .LVU326
 1301 035a 0023      		tst r16
 1302 035c 01F0      		breq .L131
 1303 035e 00C0      		rjmp .L132
 1304               	.L85:
 521:tmk_core/common/action.c ****                     break;
 1305               		.loc 1 521 21 is_stmt 1 view .LVU327
 521:tmk_core/common/action.c ****                     break;
 1306               		.loc 1 521 70 is_stmt 0 view .LVU328
 1307 0360 0023      		tst r16
 1308 0362 01F0      		breq .L91
 521:tmk_core/common/action.c ****                     break;
 1309               		.loc 1 521 37 discriminator 1 view .LVU329
 1310 0364 8C2F      		mov r24,r28
 1311 0366 8F71      		andi r24,lo8(31)
 1312 0368 0E94 0000 		call layer_move
 1313               	.LVL127:
 1314 036c 00C0      		rjmp .L36
 1315               	.L91:
 521:tmk_core/common/action.c ****                     break;
 1316               		.loc 1 521 72 discriminator 2 view .LVU330
 1317 036e 0E94 0000 		call layer_clear
 1318               	.LVL128:
 1319 0372 00C0      		rjmp .L36
 1320               	.L92:
 553:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1321               		.loc 1 553 25 is_stmt 1 view .LVU331
 1322 0374 81E0      		ldi r24,lo8(1)
 1323 0376 0E94 0000 		call clear_oneshot_layer_state
 1324               	.LVL129:
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1325               		.loc 1 554 25 view .LVU332
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1326               		.loc 1 554 28 is_stmt 0 view .LVU333
 1327 037a 1230      		cpi r17,lo8(2)
 1328 037c 00F4      		brsh .+2
 1329 037e 00C0      		rjmp .L36
 555:tmk_core/common/action.c ****                         }
 1330               		.loc 1 555 29 is_stmt 1 view .LVU334
 1331 0380 82E0      		ldi r24,lo8(2)
 1332 0382 0E94 0000 		call clear_oneshot_layer_state
 1333               	.LVL130:
 1334 0386 00C0      		rjmp .L36
 1335               	.L93:
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1336               		.loc 1 572 25 view .LVU335
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1337               		.loc 1 572 28 is_stmt 0 view .LVU336
 1338 0388 1123      		tst r17
 1339 038a 01F0      		breq .L95
 573:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1340               		.loc 1 573 77 is_stmt 1 view .LVU337
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1341               		.loc 1 574 29 view .LVU338
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1342               		.loc 1 574 32 is_stmt 0 view .LVU339
 1343 038c D933      		cpi r29,lo8(57)
 1344 038e 01F0      		breq .+2
 1345 0390 00C0      		rjmp .L97
 575:tmk_core/common/action.c ****                             } else {
 1346               		.loc 1 575 33 is_stmt 1 view .LVU340
 1347               	.LVL131:
 1348               	.LBB32:
 1349               	.LBI27:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 1350               		.loc 2 166 1 view .LVU341
 1351               	.LBB29:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1352               		.loc 2 168 2 view .LVU342
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1353               		.loc 2 172 2 view .LVU343
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1354               		.loc 2 173 2 view .LVU344
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 1355               		.loc 2 174 2 view .LVU345
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 1356               		.loc 2 184 3 view .LVU346
 1357               		.loc 2 187 2 view .LVU347
 1358 0392 EFEF      		ldi r30,lo8(255999)
 1359 0394 F7EE      		ldi r31,hi8(255999)
 1360 0396 23E0      		ldi r18,hlo8(255999)
 1361 0398 E150      	1:	subi r30,1
 1362 039a F040      		sbci r31,0
 1363 039c 2040      		sbci r18,0
 1364 039e 01F4      		brne 1b
 1365 03a0 00C0      		rjmp .L137
 1366               	.LVL132:
 1367               	.L95:
 1368               		.loc 2 187 2 is_stmt 0 view .LVU348
 1369               	.LBE29:
 1370               	.LBE32:
 581:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1371               		.loc 1 581 79 is_stmt 1 view .LVU349
 582:tmk_core/common/action.c ****                         }
 1372               		.loc 1 582 29 view .LVU350
 1373 03a2 8C2F      		mov r24,r28
 1374 03a4 8F71      		andi r24,lo8(31)
 1375 03a6 00C0      		rjmp .L132
 1376               	.LVL133:
 1377               	.L32:
 1378               	/* epilogue start */
 737:tmk_core/common/action.c **** 
 1379               		.loc 1 737 1 is_stmt 0 view .LVU351
 1380 03a8 DF91      		pop r29
 1381               	.LVL134:
 737:tmk_core/common/action.c **** 
 1382               		.loc 1 737 1 view .LVU352
 1383 03aa CF91      		pop r28
 737:tmk_core/common/action.c **** 
 1384               		.loc 1 737 1 view .LVU353
 1385 03ac 1F91      		pop r17
 1386 03ae 0F91      		pop r16
 1387 03b0 FF90      		pop r15
 1388 03b2 EF90      		pop r14
 1389               	.LVL135:
 737:tmk_core/common/action.c **** 
 1390               		.loc 1 737 1 view .LVU354
 1391 03b4 DF90      		pop r13
 1392               	.LVL136:
 737:tmk_core/common/action.c **** 
 1393               		.loc 1 737 1 view .LVU355
 1394 03b6 CF90      		pop r12
 1395 03b8 BF90      		pop r11
 1396 03ba 0895      		ret
 1397               		.cfi_endproc
 1398               	.LFE22:
 1400               		.section	.text.process_record_handler,"ax",@progbits
 1401               	.global	process_record_handler
 1403               	process_record_handler:
 1404               	.LVL137:
 1405               	.LFB21:
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1406               		.loc 1 208 50 is_stmt 1 view -0
 1407               		.cfi_startproc
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1408               		.loc 1 208 50 is_stmt 0 view .LVU357
 1409 0000 0F93      		push r16
 1410               	.LCFI15:
 1411               		.cfi_def_cfa_offset 3
 1412               		.cfi_offset 16, -2
 1413 0002 1F93      		push r17
 1414               	.LCFI16:
 1415               		.cfi_def_cfa_offset 4
 1416               		.cfi_offset 17, -3
 1417 0004 CF93      		push r28
 1418               	.LCFI17:
 1419               		.cfi_def_cfa_offset 5
 1420               		.cfi_offset 28, -4
 1421 0006 DF93      		push r29
 1422               	.LCFI18:
 1423               		.cfi_def_cfa_offset 6
 1424               		.cfi_offset 29, -5
 1425               	/* prologue: function */
 1426               	/* frame size = 0 */
 1427               	/* stack size = 4 */
 1428               	.L__stack_usage = 4
 1429 0008 EC01      		movw r28,r24
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1430               		.loc 1 209 5 is_stmt 1 view .LVU358
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1431               		.loc 1 209 23 is_stmt 0 view .LVU359
 1432 000a 6881      		ld r22,Y
 1433 000c 7981      		ldd r23,Y+1
 1434 000e 8A81      		ldd r24,Y+2
 1435               	.LVL138:
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1436               		.loc 1 209 23 view .LVU360
 1437 0010 0E94 0000 		call store_or_get_action
 1438               	.LVL139:
 1439 0014 8C01      		movw r16,r24
 1440               	.LVL140:
 210:tmk_core/common/action.c ****     debug_action(action);
 1441               		.loc 1 210 23 is_stmt 1 view .LVU361
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1442               		.loc 1 211 5 view .LVU362
 213:tmk_core/common/action.c ****     layer_debug();
 1443               		.loc 1 213 29 view .LVU363
 214:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1444               		.loc 1 214 5 view .LVU364
 1445 0016 0E94 0000 		call layer_debug
 1446               	.LVL141:
 215:tmk_core/common/action.c ****     default_layer_debug();
 1447               		.loc 1 215 37 view .LVU365
 216:tmk_core/common/action.c **** #endif
 1448               		.loc 1 216 5 view .LVU366
 1449 001a 0E94 0000 		call default_layer_debug
 1450               	.LVL142:
 218:tmk_core/common/action.c **** 
 1451               		.loc 1 218 15 view .LVU367
 220:tmk_core/common/action.c **** }
 1452               		.loc 1 220 5 view .LVU368
 220:tmk_core/common/action.c **** }
 1453               		.loc 1 220 5 is_stmt 0 view .LVU369
 1454 001e B801      		movw r22,r16
 1455 0020 CE01      		movw r24,r28
 1456               	/* epilogue start */
 221:tmk_core/common/action.c **** 
 1457               		.loc 1 221 1 view .LVU370
 1458 0022 DF91      		pop r29
 1459 0024 CF91      		pop r28
 1460               	.LVL143:
 221:tmk_core/common/action.c **** 
 1461               		.loc 1 221 1 view .LVU371
 1462 0026 1F91      		pop r17
 1463 0028 0F91      		pop r16
 1464               	.LVL144:
 220:tmk_core/common/action.c **** }
 1465               		.loc 1 220 5 view .LVU372
 1466 002a 0C94 0000 		jmp process_action
 1467               	.LVL145:
 220:tmk_core/common/action.c **** }
 1468               		.loc 1 220 5 view .LVU373
 1469               		.cfi_endproc
 1470               	.LFE21:
 1472               		.section	.text.process_record,"ax",@progbits
 1473               	.global	process_record
 1475               	process_record:
 1476               	.LVL146:
 1477               	.LFB20:
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1478               		.loc 1 190 42 is_stmt 1 view -0
 1479               		.cfi_startproc
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1480               		.loc 1 190 42 is_stmt 0 view .LVU375
 1481 0000 CF93      		push r28
 1482               	.LCFI19:
 1483               		.cfi_def_cfa_offset 3
 1484               		.cfi_offset 28, -2
 1485 0002 DF93      		push r29
 1486               	.LCFI20:
 1487               		.cfi_def_cfa_offset 4
 1488               		.cfi_offset 29, -3
 1489               	/* prologue: function */
 1490               	/* frame size = 0 */
 1491               	/* stack size = 2 */
 1492               	.L__stack_usage = 2
 1493 0004 EC01      		movw r28,r24
 191:tmk_core/common/action.c ****         return;
 1494               		.loc 1 191 5 is_stmt 1 view .LVU376
 1495               	.LBB35:
 1496               	.LBI35:
 1497               		.file 3 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1498               		.loc 3 48 20 view .LVU377
 1499               	.LBB36:
 1500               		.loc 3 48 51 view .LVU378
 1501               		.loc 3 48 74 is_stmt 0 view .LVU379
 1502 0006 8B81      		ldd r24,Y+3
 1503 0008 9C81      		ldd r25,Y+4
 1504               	.LVL147:
 1505               		.loc 3 48 74 view .LVU380
 1506 000a 892B      		or r24,r25
 1507 000c 01F0      		breq .L139
 1508 000e 8881      		ld r24,Y
 1509 0010 9981      		ldd r25,Y+1
 1510 0012 8923      		and r24,r25
 1511 0014 8F3F      		cpi r24,lo8(-1)
 1512 0016 01F4      		brne .L155
 1513               	.L139:
 1514               	/* epilogue start */
 1515               	.LBE36:
 1516               	.LBE35:
 206:tmk_core/common/action.c **** 
 1517               		.loc 1 206 1 view .LVU381
 1518 0018 DF91      		pop r29
 1519 001a CF91      		pop r28
 1520               	.LVL148:
 206:tmk_core/common/action.c **** 
 1521               		.loc 1 206 1 view .LVU382
 1522 001c 0895      		ret
 1523               	.LVL149:
 1524               	.L144:
 204:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1525               		.loc 1 204 5 is_stmt 1 view .LVU383
 1526 001e CE01      		movw r24,r28
 1527 0020 0E94 0000 		call process_record_handler
 1528               	.LVL150:
 205:tmk_core/common/action.c **** }
 1529               		.loc 1 205 5 view .LVU384
 1530 0024 CE01      		movw r24,r28
 1531               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 1532               		.loc 1 206 1 is_stmt 0 view .LVU385
 1533 0026 DF91      		pop r29
 1534 0028 CF91      		pop r28
 1535               	.LVL151:
 205:tmk_core/common/action.c **** }
 1536               		.loc 1 205 5 view .LVU386
 1537 002a 0C94 0000 		jmp post_process_record_quantum
 1538               	.LVL152:
 1539               	.L155:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1540               		.loc 1 195 5 is_stmt 1 view .LVU387
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1541               		.loc 1 195 10 is_stmt 0 view .LVU388
 1542 002e CE01      		movw r24,r28
 1543 0030 0E94 0000 		call process_record_quantum
 1544               	.LVL153:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1545               		.loc 1 195 8 view .LVU389
 1546 0034 8111      		cpse r24,__zero_reg__
 1547 0036 00C0      		rjmp .L144
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1548               		.loc 1 197 9 is_stmt 1 view .LVU390
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1549               		.loc 1 197 13 is_stmt 0 view .LVU391
 1550 0038 0E94 0000 		call is_oneshot_layer_active
 1551               	.LVL154:
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1552               		.loc 1 197 12 view .LVU392
 1553 003c 8823      		tst r24
 1554 003e 01F0      		breq .L139
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1555               		.loc 1 197 39 discriminator 1 view .LVU393
 1556 0040 8A81      		ldd r24,Y+2
 1557 0042 8823      		tst r24
 1558 0044 01F0      		breq .L139
 198:tmk_core/common/action.c ****         }
 1559               		.loc 1 198 13 is_stmt 1 view .LVU394
 1560 0046 82E0      		ldi r24,lo8(2)
 1561               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 1562               		.loc 1 206 1 is_stmt 0 view .LVU395
 1563 0048 DF91      		pop r29
 1564 004a CF91      		pop r28
 1565               	.LVL155:
 198:tmk_core/common/action.c ****         }
 1566               		.loc 1 198 13 view .LVU396
 1567 004c 0C94 0000 		jmp clear_oneshot_layer_state
 1568               	.LVL156:
 1569               		.cfi_endproc
 1570               	.LFE20:
 1572               		.section	.text.process_record_nocache,"ax",@progbits
 1573               	.global	process_record_nocache
 1575               	process_record_nocache:
 1576               	.LVL157:
 1577               	.LFB16:
 148:tmk_core/common/action.c ****     disable_action_cache = true;
 1578               		.loc 1 148 50 is_stmt 1 view -0
 1579               		.cfi_startproc
 1580               	/* prologue: function */
 1581               	/* frame size = 0 */
 1582               	/* stack size = 0 */
 1583               	.L__stack_usage = 0
 149:tmk_core/common/action.c ****     process_record(record);
 1584               		.loc 1 149 5 view .LVU398
 149:tmk_core/common/action.c ****     process_record(record);
 1585               		.loc 1 149 26 is_stmt 0 view .LVU399
 1586 0000 21E0      		ldi r18,lo8(1)
 1587 0002 2093 0000 		sts disable_action_cache,r18
 150:tmk_core/common/action.c ****     disable_action_cache = false;
 1588               		.loc 1 150 5 is_stmt 1 view .LVU400
 1589 0006 0E94 0000 		call process_record
 1590               	.LVL158:
 151:tmk_core/common/action.c **** }
 1591               		.loc 1 151 5 view .LVU401
 151:tmk_core/common/action.c **** }
 1592               		.loc 1 151 26 is_stmt 0 view .LVU402
 1593 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1594               	/* epilogue start */
 152:tmk_core/common/action.c **** #else
 1595               		.loc 1 152 1 view .LVU403
 1596 000e 0895      		ret
 1597               		.cfi_endproc
 1598               	.LFE16:
 1600               		.section	.text.register_weak_mods,"ax",@progbits
 1601               	.global	register_weak_mods
 1603               	register_weak_mods:
 1604               	.LVL159:
 1605               	.LFB28:
 934:tmk_core/common/action.c **** 
 935:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:tmk_core/common/action.c ****  *
 937:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 938:tmk_core/common/action.c ****  */
 939:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1606               		.loc 1 939 39 is_stmt 1 view -0
 1607               		.cfi_startproc
 1608               	/* prologue: function */
 1609               	/* frame size = 0 */
 1610               	/* stack size = 0 */
 1611               	.L__stack_usage = 0
 940:tmk_core/common/action.c ****     if (mods) {
 1612               		.loc 1 940 5 view .LVU405
 1613               		.loc 1 940 8 is_stmt 0 view .LVU406
 1614 0000 8823      		tst r24
 1615 0002 01F0      		breq .L158
 941:tmk_core/common/action.c ****         add_weak_mods(mods);
 1616               		.loc 1 941 9 is_stmt 1 view .LVU407
 1617 0004 0E94 0000 		call add_weak_mods
 1618               	.LVL160:
 942:tmk_core/common/action.c ****         send_keyboard_report();
 1619               		.loc 1 942 9 view .LVU408
 1620 0008 0C94 0000 		jmp send_keyboard_report
 1621               	.LVL161:
 1622               	.L158:
 1623               	/* epilogue start */
 943:tmk_core/common/action.c ****     }
 944:tmk_core/common/action.c **** }
 1624               		.loc 1 944 1 is_stmt 0 view .LVU409
 1625 000c 0895      		ret
 1626               		.cfi_endproc
 1627               	.LFE28:
 1629               		.section	.text.unregister_weak_mods,"ax",@progbits
 1630               	.global	unregister_weak_mods
 1632               	unregister_weak_mods:
 1633               	.LVL162:
 1634               	.LFB29:
 945:tmk_core/common/action.c **** 
 946:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:tmk_core/common/action.c ****  *
 948:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:tmk_core/common/action.c ****  */
 950:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1635               		.loc 1 950 41 is_stmt 1 view -0
 1636               		.cfi_startproc
 1637               	/* prologue: function */
 1638               	/* frame size = 0 */
 1639               	/* stack size = 0 */
 1640               	.L__stack_usage = 0
 951:tmk_core/common/action.c ****     if (mods) {
 1641               		.loc 1 951 5 view .LVU411
 1642               		.loc 1 951 8 is_stmt 0 view .LVU412
 1643 0000 8823      		tst r24
 1644 0002 01F0      		breq .L160
 952:tmk_core/common/action.c ****         del_weak_mods(mods);
 1645               		.loc 1 952 9 is_stmt 1 view .LVU413
 1646 0004 0E94 0000 		call del_weak_mods
 1647               	.LVL163:
 953:tmk_core/common/action.c ****         send_keyboard_report();
 1648               		.loc 1 953 9 view .LVU414
 1649 0008 0C94 0000 		jmp send_keyboard_report
 1650               	.LVL164:
 1651               	.L160:
 1652               	/* epilogue start */
 954:tmk_core/common/action.c ****     }
 955:tmk_core/common/action.c **** }
 1653               		.loc 1 955 1 is_stmt 0 view .LVU415
 1654 000c 0895      		ret
 1655               		.cfi_endproc
 1656               	.LFE29:
 1658               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1659               	.global	clear_keyboard_but_mods_and_keys
 1661               	clear_keyboard_but_mods_and_keys:
 1662               	.LFB32:
 956:tmk_core/common/action.c **** 
 957:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:tmk_core/common/action.c ****  *
 959:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 960:tmk_core/common/action.c ****  */
 961:tmk_core/common/action.c **** void clear_keyboard(void) {
 962:tmk_core/common/action.c ****     clear_mods();
 963:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 964:tmk_core/common/action.c **** }
 965:tmk_core/common/action.c **** 
 966:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:tmk_core/common/action.c ****  *
 968:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 969:tmk_core/common/action.c ****  */
 970:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 971:tmk_core/common/action.c ****     clear_keys();
 972:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 973:tmk_core/common/action.c **** }
 974:tmk_core/common/action.c **** 
 975:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:tmk_core/common/action.c ****  *
 977:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 978:tmk_core/common/action.c ****  */
 979:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1663               		.loc 1 979 41 is_stmt 1 view -0
 1664               		.cfi_startproc
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 0 */
 1668               	.L__stack_usage = 0
 980:tmk_core/common/action.c ****     clear_weak_mods();
 1669               		.loc 1 980 5 view .LVU417
 1670 0000 0E94 0000 		call clear_weak_mods
 1671               	.LVL165:
 981:tmk_core/common/action.c ****     clear_macro_mods();
 1672               		.loc 1 981 5 view .LVU418
 1673 0004 0E94 0000 		call clear_macro_mods
 1674               	.LVL166:
 982:tmk_core/common/action.c ****     send_keyboard_report();
 1675               		.loc 1 982 5 view .LVU419
 1676 0008 0C94 0000 		jmp send_keyboard_report
 1677               	.LVL167:
 1678               		.cfi_endproc
 1679               	.LFE32:
 1681               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1682               	.global	clear_keyboard_but_mods
 1684               	clear_keyboard_but_mods:
 1685               	.LFB31:
 970:tmk_core/common/action.c ****     clear_keys();
 1686               		.loc 1 970 36 view -0
 1687               		.cfi_startproc
 1688               	/* prologue: function */
 1689               	/* frame size = 0 */
 1690               	/* stack size = 0 */
 1691               	.L__stack_usage = 0
 971:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1692               		.loc 1 971 5 view .LVU421
 1693 0000 0E94 0000 		call clear_keys
 1694               	.LVL168:
 972:tmk_core/common/action.c **** }
 1695               		.loc 1 972 5 view .LVU422
 1696 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1697               	.LVL169:
 1698               		.cfi_endproc
 1699               	.LFE31:
 1701               		.section	.text.clear_keyboard,"ax",@progbits
 1702               	.global	clear_keyboard
 1704               	clear_keyboard:
 1705               	.LFB30:
 961:tmk_core/common/action.c ****     clear_mods();
 1706               		.loc 1 961 27 view -0
 1707               		.cfi_startproc
 1708               	/* prologue: function */
 1709               	/* frame size = 0 */
 1710               	/* stack size = 0 */
 1711               	.L__stack_usage = 0
 962:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1712               		.loc 1 962 5 view .LVU424
 1713 0000 0E94 0000 		call clear_mods
 1714               	.LVL170:
 963:tmk_core/common/action.c **** }
 1715               		.loc 1 963 5 view .LVU425
 1716 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1717               	.LVL171:
 1718               		.cfi_endproc
 1719               	.LFE30:
 1721               		.section	.text.is_tap_action,"ax",@progbits
 1722               	.global	is_tap_action
 1724               	is_tap_action:
 1725               	.LVL172:
 1726               	.LFB34:
 983:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 984:tmk_core/common/action.c ****     mousekey_clear();
 985:tmk_core/common/action.c ****     mousekey_send();
 986:tmk_core/common/action.c **** #endif
 987:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 988:tmk_core/common/action.c ****     host_system_send(0);
 989:tmk_core/common/action.c ****     host_consumer_send(0);
 990:tmk_core/common/action.c **** #endif
 991:tmk_core/common/action.c **** }
 992:tmk_core/common/action.c **** 
 993:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:tmk_core/common/action.c ****  *
 995:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 996:tmk_core/common/action.c ****  */
 997:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 998:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 999:tmk_core/common/action.c ****     return is_tap_action(action);
1000:tmk_core/common/action.c **** }
1001:tmk_core/common/action.c **** 
1002:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:tmk_core/common/action.c ****  *
1004:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1005:tmk_core/common/action.c ****  */
1006:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1727               		.loc 1 1006 37 view -0
 1728               		.cfi_startproc
 1729               	/* prologue: function */
 1730               	/* frame size = 0 */
 1731               	/* stack size = 0 */
 1732               	.L__stack_usage = 0
1007:tmk_core/common/action.c ****     switch (action.kind.id) {
 1733               		.loc 1 1007 5 view .LVU427
 1734               		.loc 1 1007 24 is_stmt 0 view .LVU428
 1735 0000 E92F      		mov r30,r25
 1736 0002 E295      		swap r30
 1737 0004 EF70      		andi r30,lo8(15)
 1738               		.loc 1 1007 5 view .LVU429
 1739 0006 E250      		subi r30,lo8(-(-2))
 1740 0008 EE30      		cpi r30,lo8(14)
 1741 000a 00F4      		brsh .L174
 1742 000c F0E0      		ldi r31,0
 1743 000e E050      		subi r30,lo8(-(gs(.L168)))
 1744 0010 F040      		sbci r31,hi8(-(gs(.L168)))
 1745 0012 0C94 0000 		jmp __tablejump2__
 1746               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 1747               		.p2align	1
 1748               	.L168:
 1749 0000 0000      		.word gs(.L169)
 1750 0002 0000      		.word gs(.L169)
 1751 0004 0000      		.word gs(.L174)
 1752 0006 0000      		.word gs(.L174)
 1753 0008 0000      		.word gs(.L170)
 1754 000a 0000      		.word gs(.L174)
 1755 000c 0000      		.word gs(.L174)
 1756 000e 0000      		.word gs(.L174)
 1757 0010 0000      		.word gs(.L169)
 1758 0012 0000      		.word gs(.L169)
 1759 0014 0000      		.word gs(.L167)
 1760 0016 0000      		.word gs(.L174)
 1761 0018 0000      		.word gs(.L174)
 1762 001a 0000      		.word gs(.L167)
 1763               		.section	.text.is_tap_action
 1764               	.L169:
1008:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1009:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1010:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1011:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1012:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1765               		.loc 1 1012 13 is_stmt 1 view .LVU430
 1766 0016 803F      		cpi r24,lo8(-16)
 1767 0018 01F0      		breq .L177
 1768 001a 00F4      		brsh .L171
 1769 001c 883E      		cpi r24,lo8(-24)
 1770 001e 00F4      		brsh .L174
 1771               	.L177:
1013:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1014:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1015:tmk_core/common/action.c ****                 case OP_ONESHOT:
1016:tmk_core/common/action.c ****                     return true;
 1772               		.loc 1 1016 28 is_stmt 0 view .LVU431
 1773 0020 81E0      		ldi r24,lo8(1)
 1774               	.LVL173:
 1775               	/* epilogue start */
1017:tmk_core/common/action.c ****             }
1018:tmk_core/common/action.c ****             return false;
1019:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1020:tmk_core/common/action.c ****             switch (action.swap.code) {
1021:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1022:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1023:tmk_core/common/action.c ****                     return true;
1024:tmk_core/common/action.c ****             }
1025:tmk_core/common/action.c ****             return false;
1026:tmk_core/common/action.c ****         case ACT_MACRO:
1027:tmk_core/common/action.c ****         case ACT_FUNCTION:
1028:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1029:tmk_core/common/action.c ****                 return true;
1030:tmk_core/common/action.c ****             }
1031:tmk_core/common/action.c ****             return false;
1032:tmk_core/common/action.c ****     }
1033:tmk_core/common/action.c ****     return false;
1034:tmk_core/common/action.c **** }
 1776               		.loc 1 1034 1 view .LVU432
 1777 0022 0895      		ret
 1778               	.LVL174:
 1779               	.L171:
 1780               		.loc 1 1034 1 view .LVU433
 1781 0024 843F      		cpi r24,lo8(-12)
 1782 0026 01F0      		breq .L177
 1783               	.L174:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1784               		.loc 1 1018 20 view .LVU434
 1785 0028 80E0      		ldi r24,0
 1786               	.LVL175:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1787               		.loc 1 1018 20 view .LVU435
 1788 002a 0895      		ret
 1789               	.LVL176:
 1790               	.L170:
1020:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1791               		.loc 1 1020 13 is_stmt 1 view .LVU436
 1792 002c 883E      		cpi r24,lo8(-24)
 1793 002e 00F0      		brlo .L177
 1794 0030 813F      		cpi r24,lo8(-15)
 1795 0032 01F4      		brne .L174
 1796 0034 00C0      		rjmp .L177
 1797               	.L167:
1028:tmk_core/common/action.c ****                 return true;
 1798               		.loc 1 1028 13 view .LVU437
1028:tmk_core/common/action.c ****                 return true;
 1799               		.loc 1 1028 16 is_stmt 0 view .LVU438
 1800 0036 93FB      		bst r25,3
 1801 0038 8827      		clr r24
 1802 003a 80F9      		bld r24,0
 1803               	.LVL177:
1028:tmk_core/common/action.c ****                 return true;
 1804               		.loc 1 1028 16 view .LVU439
 1805 003c 0895      		ret
 1806               		.cfi_endproc
 1807               	.LFE34:
 1809               		.section	.text.is_tap_key,"ax",@progbits
 1810               	.global	is_tap_key
 1812               	is_tap_key:
 1813               	.LVL178:
 1814               	.LFB33:
 997:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1815               		.loc 1 997 31 is_stmt 1 view -0
 1816               		.cfi_startproc
 1817               	/* prologue: function */
 1818               	/* frame size = 0 */
 1819               	/* stack size = 0 */
 1820               	.L__stack_usage = 0
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 1821               		.loc 1 998 5 view .LVU441
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 1822               		.loc 1 998 23 is_stmt 0 view .LVU442
 1823 0000 0E94 0000 		call layer_switch_get_action
 1824               	.LVL179:
 999:tmk_core/common/action.c **** }
 1825               		.loc 1 999 5 is_stmt 1 view .LVU443
 999:tmk_core/common/action.c **** }
 1826               		.loc 1 999 12 is_stmt 0 view .LVU444
 1827 0004 0C94 0000 		jmp is_tap_action
 1828               	.LVL180:
 1829               		.cfi_endproc
 1830               	.LFE33:
 1832               		.section	.text.debug_event,"ax",@progbits
 1833               	.global	debug_event
 1835               	debug_event:
 1836               	.LFB35:
1035:tmk_core/common/action.c **** 
1036:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1037:tmk_core/common/action.c ****  *
1038:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1039:tmk_core/common/action.c ****  */
1040:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 1837               		.loc 1 1040 36 is_stmt 1 view -0
 1838               		.cfi_startproc
 1839 0000 CF93      		push r28
 1840               	.LCFI21:
 1841               		.cfi_def_cfa_offset 3
 1842               		.cfi_offset 28, -2
 1843 0002 DF93      		push r29
 1844               	.LCFI22:
 1845               		.cfi_def_cfa_offset 4
 1846               		.cfi_offset 29, -3
 1847 0004 00D0      		rcall .
 1848 0006 00D0      		rcall .
 1849 0008 0F92      		push __tmp_reg__
 1850               	.LCFI23:
 1851               		.cfi_def_cfa_offset 9
 1852 000a CDB7      		in r28,__SP_L__
 1853 000c DEB7      		in r29,__SP_H__
 1854               	.LCFI24:
 1855               		.cfi_def_cfa_register 28
 1856               	/* prologue: function */
 1857               	/* frame size = 5 */
 1858               	/* stack size = 7 */
 1859               	.L__stack_usage = 7
 1860               		.loc 1 1040 138 view .LVU446
 1861               	/* epilogue start */
 1862               		.loc 1 1040 1 is_stmt 0 view .LVU447
 1863 000e 0F90      		pop __tmp_reg__
 1864 0010 0F90      		pop __tmp_reg__
 1865 0012 0F90      		pop __tmp_reg__
 1866 0014 0F90      		pop __tmp_reg__
 1867 0016 0F90      		pop __tmp_reg__
 1868 0018 DF91      		pop r29
 1869 001a CF91      		pop r28
 1870 001c 0895      		ret
 1871               		.cfi_endproc
 1872               	.LFE35:
 1874               		.section	.text.debug_record,"ax",@progbits
 1875               	.global	debug_record
 1877               	debug_record:
 1878               	.LFB36:
1041:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1042:tmk_core/common/action.c ****  *
1043:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1044:tmk_core/common/action.c ****  */
1045:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 1879               		.loc 1 1045 39 is_stmt 1 view -0
 1880               		.cfi_startproc
 1881 0000 CF93      		push r28
 1882               	.LCFI25:
 1883               		.cfi_def_cfa_offset 3
 1884               		.cfi_offset 28, -2
 1885 0002 DF93      		push r29
 1886               	.LCFI26:
 1887               		.cfi_def_cfa_offset 4
 1888               		.cfi_offset 29, -3
 1889 0004 00D0      		rcall .
 1890 0006 00D0      		rcall .
 1891 0008 00D0      		rcall .
 1892               	.LCFI27:
 1893               		.cfi_def_cfa_offset 10
 1894 000a CDB7      		in r28,__SP_L__
 1895 000c DEB7      		in r29,__SP_H__
 1896               	.LCFI28:
 1897               		.cfi_def_cfa_register 28
 1898               	/* prologue: function */
 1899               	/* frame size = 6 */
 1900               	/* stack size = 8 */
 1901               	.L__stack_usage = 8
1046:tmk_core/common/action.c ****     debug_event(record.event);
 1902               		.loc 1 1046 5 view .LVU449
1047:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1048:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 1903               		.loc 1 1048 77 view .LVU450
 1904               	/* epilogue start */
1049:tmk_core/common/action.c **** #endif
1050:tmk_core/common/action.c **** }
 1905               		.loc 1 1050 1 is_stmt 0 view .LVU451
 1906 000e 2696      		adiw r28,6
 1907 0010 0FB6      		in __tmp_reg__,__SREG__
 1908 0012 F894      		cli
 1909 0014 DEBF      		out __SP_H__,r29
 1910 0016 0FBE      		out __SREG__,__tmp_reg__
 1911 0018 CDBF      		out __SP_L__,r28
 1912 001a DF91      		pop r29
 1913 001c CF91      		pop r28
 1914 001e 0895      		ret
 1915               		.cfi_endproc
 1916               	.LFE36:
 1918               		.section	.text.debug_action,"ax",@progbits
 1919               	.global	debug_action
 1921               	debug_action:
 1922               	.LVL181:
 1923               	.LFB37:
1051:tmk_core/common/action.c **** 
1052:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1053:tmk_core/common/action.c ****  *
1054:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1055:tmk_core/common/action.c ****  */
1056:tmk_core/common/action.c **** void debug_action(action_t action) {
 1924               		.loc 1 1056 36 is_stmt 1 view -0
 1925               		.cfi_startproc
 1926               	/* prologue: function */
 1927               	/* frame size = 0 */
 1928               	/* stack size = 0 */
 1929               	.L__stack_usage = 0
1057:tmk_core/common/action.c ****     switch (action.kind.id) {
 1930               		.loc 1 1057 5 view .LVU453
1058:tmk_core/common/action.c ****         case ACT_LMODS:
1059:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1060:tmk_core/common/action.c ****             break;
1061:tmk_core/common/action.c ****         case ACT_RMODS:
1062:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1063:tmk_core/common/action.c ****             break;
1064:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1065:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1066:tmk_core/common/action.c ****             break;
1067:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1068:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1069:tmk_core/common/action.c ****             break;
1070:tmk_core/common/action.c ****         case ACT_USAGE:
1071:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1072:tmk_core/common/action.c ****             break;
1073:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1074:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1075:tmk_core/common/action.c ****             break;
1076:tmk_core/common/action.c ****         case ACT_LAYER:
1077:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1078:tmk_core/common/action.c ****             break;
1079:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1080:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1081:tmk_core/common/action.c ****             break;
1082:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1083:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1084:tmk_core/common/action.c ****             break;
1085:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1086:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1087:tmk_core/common/action.c ****             break;
1088:tmk_core/common/action.c ****         case ACT_MACRO:
1089:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1090:tmk_core/common/action.c ****             break;
1091:tmk_core/common/action.c ****         case ACT_FUNCTION:
1092:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1093:tmk_core/common/action.c ****             break;
1094:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1095:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1096:tmk_core/common/action.c ****             break;
1097:tmk_core/common/action.c ****         default:
1098:tmk_core/common/action.c ****             dprint("UNKNOWN");
1099:tmk_core/common/action.c ****             break;
1100:tmk_core/common/action.c ****     }
1101:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 1931               		.loc 1 1101 75 view .LVU454
 1932               	/* epilogue start */
1102:tmk_core/common/action.c **** }
 1933               		.loc 1 1102 1 is_stmt 0 view .LVU455
 1934 0000 0895      		ret
 1935               		.cfi_endproc
 1936               	.LFE37:
 1938               	.global	disable_action_cache
 1939               		.section	.bss.disable_action_cache,"aw",@nobits
 1942               	disable_action_cache:
 1943 0000 00        		.zero	1
 1944               		.comm	tp_buttons,2,1
 1945               		.text
 1946               	.Letext0:
 1947               		.file 4 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/stdint.h"
 1948               		.file 5 "tmk_core/common/keycode.h"
 1949               		.file 6 "tmk_core/common/report.h"
 1950               		.file 7 "tmk_core/common/host.h"
 1951               		.file 8 "tmk_core/common/mousekey.h"
 1952               		.file 9 "tmk_core/common/command.h"
 1953               		.file 10 "tmk_core/common/action_code.h"
 1954               		.file 11 "tmk_core/common/action.h"
 1955               		.file 12 "tmk_core/common/action_layer.h"
 1956               		.file 13 "tmk_core/common/action_util.h"
 1957               		.file 14 "tmk_core/common/avr/xprintf.h"
 1958               		.file 15 "tmk_core/common/debug.h"
 1959               		.file 16 "tmk_core/common/led.h"
 1960               		.file 17 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:4      *ABS*:000000000000003f __SREG__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:13     .text.action_exec:0000000000000000 action_exec
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:94     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:116    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:135    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:160    .text.register_code:0000000000000000 register_code
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:255    .text.unregister_code:0000000000000000 unregister_code
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:345    .text.tap_code:0000000000000000 tap_code
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:410    .text.register_mods:0000000000000000 register_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:439    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:468    .text.process_action:0000000000000000 process_action
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1475   .text.process_record:0000000000000000 process_record
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1403   .text.process_record_handler:0000000000000000 process_record_handler
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1575   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1942   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1603   .text.register_weak_mods:0000000000000000 register_weak_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1632   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1661   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1684   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1704   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1724   .text.is_tap_action:0000000000000000 is_tap_action
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1812   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1835   .text.debug_event:0000000000000000 debug_event
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1877   .text.debug_record:0000000000000000 debug_record
/var/folders/7y/kbn66ztx1rs80r6yv6v16f4r0000gn/T//ccyqzaZN.s:1921   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
keyboard_report
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
del_mods
host_system_send
host_consumer_send
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
host_keyboard_leds
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_clear_bss
